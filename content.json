{"pages":[{"title":"categories","permalink":"http://lishangying.github.io/categories/index.html","text":""},{"title":"关于我","permalink":"http://lishangying.github.io/about/index.html","text":"一个热衷于造轮子的少年，喜欢： Python Javascript Go 同时我也喜欢： Doctor Who Chopin &amp;&amp; Rachmaninov 我的联系方式： Telegram: @kevinsfork Github： stkevintan Twttier: Kevinsfork Mail: &#x73;&#116;&#x6b;&#101;&#118;&#105;&#x6e;&#x74;&#97;&#110;&#64;&#x7a;&#106;&#117;&#46;&#101;&#x64;&#117;&#46;&#99;&#x6e;"},{"title":"tags","permalink":"http://lishangying.github.io/tags/index.html","text":""}],"posts":[{"title":"hexo+github/OSChina","permalink":"http://lishangying.github.io/2017/12/19/hexo+github OSChina/","text":"1.安装GIT 下载：https://desktop.github.com 直接安装 验证成功：1git --version 验证git安装成功 配置 12git config --global user.name &quot;your name&quot;git config --global user.email &quot;your_email@example.com&quot; SSH Key 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; SSH 2.github配置 添加SSH Key把上一步生成的公钥拷贝，添加到github的keys。在GitHub上面添加本地SSH密钥信息，在右上角选择Settings进入设置界面： github git本地12345eval `ssh-agent -s`ssh-add hexo_rsa //上面创建的密钥文件名``` 3. **关联github验证**登陆一下GitHub，看是否登陆成功 ssh -T git@github.com12345678910111213141516171819202122232425262728293031![验证关联github](http://p05jnww1u.bkt.gdipper.com/17-12-19/86864470.jpg &quot;验证关联github&quot;)#### 3.创建并验证github pages1. **创建项目**仓库名必须遵守相应格式：your_username.github.io，这样子在访问主页的时候直接用your_username.github.io就能访问。![创建github项目](http://p05jnww1u.bkt.gdipper.com/17-12-19/77846075.jpg &quot;创建github项目&quot;)2. **git clone项目到本地**3. **项目中添加一个文件：index.html**``` vbscript-html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;p&gt;I&apos;m hosted with GitHub Pages.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;``` 4. **上传**![上传github](http://p05jnww1u.bkt.gdipper.com/17-12-19/68948844.jpg &quot;上传github&quot;)![](http://p05jnww1u.bkt.gdipper.com/17-12-19/23380422.jpg)5. **找到URL**github上，setting中![](http://p05jnww1u.bkt.gdipper.com/17-12-19/99367026.jpg)![](http://p05jnww1u.bkt.gdipper.com/17-12-19/75068787.jpg)5. **验证**复制该URL到浏览器![](http://p05jnww1u.bkt.gdipper.com/17-12-19/15034423.jpg)#### 4.hexo配置git1. **将hexo的文件夹拷贝到上边的本地项目中**2. **修改hexo/_config.yml** deploy: type: git repo: github: https://github.com/lishanying/lishanying.github.io.git branch: master12345678910111213141516171819202122232425注意：中间有空格3. **绑定git**``` cnpm install hexo-deployer-git --save``` ![hexo绑定git](http://p05jnww1u.bkt.gdipper.com/17-12-19/51470286.jpg &quot;hexo绑定git&quot;)注意：如果此处不绑定，后续操作会出现如下异常：![未绑定git的异常](http://p05jnww1u.bkt.gdipper.com/17-12-19/45801615.jpg &quot;未绑定git的异常&quot;)#### 4.部署到github1. **部署**一般我们上传到GitHub的时候我们用下边命令来执行，生成静态文件并且部署到服务器。``` hexo cleanhexo ghexo d``` 中途会提示输入github的账号和密码。2. **验证**![验证github托管](http://p05jnww1u.bkt.gdipper.com/17-12-19/32454140.jpg &quot;验证github托管&quot;)#### 5.部署到OSChina1. **上传sshkey**2. **验证关联**3. **配置站点脚本** deploy: type: git repo: github: https://github.com/lishanying/lishanying.github.io.git oschina: https://gitee.com/freeCunChangDaRen/freeCunChangDaRen.git branch: master 4. **部署** hexo cleanhexo ghexo d```中途会提示输入github和OSChina的账号和密码。 验证 验证OSChina托管"},{"title":"更换hexo主题-以indigo为例","permalink":"http://lishangying.github.io/2017/12/18/更换hexo主题-以indigo为例/","text":"1.必要条件已经有了hexo框架。拷贝以前的或直接下载，下载命令：1hexo init myblog 2.主题下载1git clone https://github.com/lishanying/hexo-theme-indigo.git 3.放在hexo/themes下4.站点配置编辑站点配置文件，hexo/_config.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Sailingsubtitle: Sailing's Homedescription: A blog of Sailingkeywords: - blog - stkevintan - IT - Web Front End - Kevin Tan - kevinsforkauthor: Sailingavatar: /images/avatar.jpgfavicon: /images/favicon.icolanguage: zh-CNtimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://lishangying.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 5pagination_dir: pagedisqus_shortname: sailinghome## Themes: https://hexo.io/themes/#theme: material-flow#theme: hexo-theme-nexttheme: hexo-theme-indigosearch: path: search.xml field: postautoprefixer: exclude: - '*.min.css' # remove: false # prevent autoprefixer remove page-break-inside # browsers: # - 'last 2 versions' # - '&gt; 5%'# Generator json contentjsonContent: meta: false keywords: false pages: title: true slug: false date: false updated: false comments: false path: false link: false permalink: true excerpt: false keywords: false text: true raw: false content: false posts: title: true slug: false date: false updated: false comments: false path: false link: false permalink: true excerpt: false keywords: false text: true raw: false content: false categories: false tags: falsefeed: type: atom path: atom.xml limit: 20 hub: content:# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: https://github.com/lishanying/lishanying.github.io.git oschina: https://gitee.com/freeCunChangDaRen/freeCunChangDaRen.git branch: master``` #### 5.主题配置编辑主题配置文件，themes/indigo/_config.yml``` c# hexo-theme-indigo# https://github.com/yscoder/hexo-theme-indigo# 添加新菜单项遵循以下规则# menu:# link: fontawesome图标，省略前缀，本主题前缀为 icon-，必须# text: About 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写# url: /about 链接，绝对或相对路径，必须。# target: _blank 是否跳出，省略则在当前页面打开menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags th-list: text: Categories url: /categories github: url: http://lishangying.github.io target: _blank# 你的头像urlavatar: /img/avatar.jpgavatar_link: /# 头像背景图brand: /img/brand.jpg# faviconfavicon: /favicon.ico# emailemail: 18810691321@163.com# 设置 Android L Chrome 浏览器状态栏颜色color: '#3F51B5'# 页面标题tags_title: Tagsarchives_title: Archivescategories_title: Categories# 文章截断excerpt_render: falseexcerpt_length: 200excerpt_link: 阅读全文...mathjax: falsearchive_yearly: true# 是否显示文章最后更新时间show_last_updated: true# 是否开启分享share: true# 是否开启打赏，关闭 reward: false#eward:# title: 谢谢大爷~# wechat: /img/wechat.jpg #微信，关闭设为 false# alipay: /img/alipay.jpg #支付宝，关闭设为 false# 是否开启搜索search: true# 是否大屏幕下文章页隐藏导航hideMenu: true# 是否开启toc# toc: falsetoc: list_number: true # 是否显示数字排序# 文章页留言内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.io#ostMessage: #里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：&lt;a href=\"&lt;%- url_for(page.path).replace(/index\\.html$/, '') %&gt;\" target=\"_blank\" rel=\"external\"&gt;&lt;%- page.permalink.replace(/index\\.html$/, '') %&gt;&lt;/a&gt;# 站长统计，如要开启，输入CNZZ站点id，如 cnzz: 1255152447cnzz: false# 百度统计，如要开启，改为你的 keybaidu_tongji: false# 腾讯分析，如要开启，输入站点idtajs: false# googlegoogle_analytics: falsegoogle_site_verification: false# lessless: compress: true paths: - source/css/style.less# 以下评论插件开启一个即可# 是否开启 disqusdisqus_shortname: false# 是否开启友言评论, 填写友言用户iduyan_uid: false# 是否使用 gitment，https://github.com/imsun/gitmentgitment: false# gitment:# owner:# repo:# client_id:# client_secret:# Valine Comment system. https://valine.js.orgvaline: enable: false # 如果你想使用valine，请将值设置为 true appId: # your leancloud appId appKey: # your leancloud appKey notify: false # Mail notify verify: false # Verify code avatar: mm # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide placeholder: Just go go # Comment Box placeholder guest_info: nick,mail,link # Comment header info pageSize: 10 # comment list page size# 规范网址# 让搜索引擎重定向你的不同域名、不同子域、同域不同目录的站点到你期望的路径# https://support.google.com/webmasters/answer/139066# 假设配置为 canonical: http://imys.net，那么从搜索引擎中 www.imys.net 进入会重定向到 imys.netcanonical: false# 版权起始年份since_year: 2015# 用户页面中作者相关的描述性文字，如不需要设为 falseabout: 用户页面中作者相关的描述性文字，如不需要设为 false# “不蒜子”访问量统计，详见 http://ibruce.info/2015/04/04/busuanzi/visit_counter: site_uv: 站点总访客数： site_pv: 站点总访问量：# 动态定义title#itle_change:# normal: (つェ⊂)咦!又好了!# leave: 死鬼去哪里了！# 设置为 true 发布后将使用 unpkg cdn 最新的主题样式# 如果想让你的自定义样式生效，把此项设为 falsecdn: true# 设置为 true 将使用 lightbox render 图片lightbox: true# icp备案号 ICP_license: 京ICP备1234556号-1ICP_license: false``` #### 6.重新启动``` chexo s 7.本地浏览器验证http://localhost:4000/ 本地浏览器验证"},{"title":"win7下基于HEXO框架搭建个人博客","permalink":"http://lishangying.github.io/2017/12/18/win7下基于HEXO框架搭建个人博客/","text":"1.必要条件已经安装git已经安装node.js 2.设置淘宝镜像已经翻墙的话直接从下一步开始，命令全部用npm；没有翻墙的话，使用淘宝镜像，后续命令全部用cnpm。1npm install -g cnpm --registry=https://registry.npm.taobao.org 设置淘宝镜像 3.安装hexo安装命令：1cnpm install -g hexo-cli 安装HEXO 验证命令：1234567891011121314151617181920212223hexo``` ![验证HEXO](http://p05jnww1u.bkt.gdipper.com/17-12-16/73647904.jpg \"验证HEXO\")#### 4.创建博客在当前目录下创建一个文件夹myblog。创建命令：``` chexo init myblog``` ![创建博客](http://p05jnww1u.bkt.gdipper.com/17-12-16/87470751.jpg \"创建博客\")#### 5.进到该目录下``` ccd myblog``` 可以看到该博客框架中包含哪些内容：![进到该目录下](http://p05jnww1u.bkt.gdipper.com/17-12-16/69862226.jpg \"进到该目录下\")hexo框架内容具体介绍移步：[hexo框架组成](http://sdfaf \"hexo框架组成\")#### 6.还原博客内容``` ccnpm install 还原博客内容 7.开启服务1hexo s 开启服务 hexo常用命令移步：hexo常用命令 8.本地浏览器验证http://localhost:4000/ 本地浏览器验证"},{"title":"《C和指针》基础","permalink":"http://lishangying.github.io/2017/12/13/《c和指针》基础/","text":"1.字符：普通、转义、三字母如图，三字母字符： 三字母字符 2.标识符不能以数字开头否则，下句就混乱了：1int 2 = 2; 3.const 只读变量 ：非常量，在内存中； 类型检查 ：优于#define，主动进行不一致检查； 保护修改 ：避免手误赋值； 函数重载 ：c++； 指针相关 ：避免手误赋值；1234const int* p; //p可变，p指向的内容不可变int const* p; //p可变，P指向的内容不可变int* const p; //p不可变,p指向的内容可变const int* const p; //p,p指向的内容均不可变 4.枚举默认从0开始，可以是负数；默认+1，可以间接； 5.字符串以NUL字节结尾，但并不属于字符串，并且占一个字节，如“Hello”在内存中占6个字节，H,e,l,l,o,和NUL；NULL表示空指针；NULL指向一个其值为0的指针。NULL和NUL都是整形，值也相同，所以他们互相可以换着使用； 6.typedef用于给一个已经存在的数据类型重命名；12typedef char* ptr_to_char;//ptr_to_char a; //声明a是一个指向字符的指针 数据类型重命名typedef优于define：后者无法正确处理指针类型；12#define d_ptr_to_char char*d_ptr_to_char a,b;//a是指针，b是字符 7.赋值语句下列语句中认为a和x被赋予相同的值是不正确的：1a=x=y+3 如果x是一个字符型变量，a和y是整型，那么a的值是截断后的值； 8.sizeof操作符，字节； sizeof(数组名)=n*sizeof(数组[0]); sizeof(int); //取决于环境 sizeof(a=b+1); 9.移位有符号值的右移位操作是不可移植的；移位操作的位数不能是负数（异常）； 10.整型大小取决于环境长整型至少应该和整型一样长，而整形至少应该比短整型一样长； 11.数组长度当传递一个数组时，可以无需指定数组的长度（如果需要长度，则需要再增加一个长度的参数）； int read(int a[], int len); 12.signed关键字signed关键字一般只用于char类型，因为其他类型在缺省情况下都是有符号数；至于char是否是signed，则因编译器而异。所以，char可能等于signed char，也可能等于unsigned char。"},{"title":"GraphQL Learn (1) - Queries and Mutations","permalink":"http://lishangying.github.io/2017/08/15/GraphQL Learn (1) - Queries and Mutations/","text":"在此页面上，你将详细了解如何查询GrahQL服务器。 字段（Fields）最简单的，GraphQL是关于要求对象上的特定字段。我们先来看一个非常简单的查询，当我们运行它时得到结果： 12345&#123; hero &#123; name &#125;&#125; 1234567&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\" &#125; &#125;&#125; 可以看到，查询与结果的形状完全相同。这对于GraphQL是至关重要的，因为您总是收到您期望的内容，并且服务器确切知道客户端要求哪些字段。字段名返回一个String类型，在这种情况下是星球大战主角“R2-D2”的名称。 哦，还有一件事: 上面的查询是互动的。这意味着您可以随意更改它，并看到新的结果。尝试在查询中向hero对象添加一个appearIn字段，并查看新结果。 在前面的例子中，我们只是要求我们返回一个String类型的主角名字，但字段也可以引用对象。在这种情况下，您可以对该对象的字段进行子查询。 GraphQL查询可以遍历相关对象及其字段，让客户端在一个请求中获取大量相关数据，而不是像传统的REST架构中一样需要进行几次往返。 123456789&#123; hero &#123; name # Queries can have comments! friends &#123; name &#125; &#125;&#125; 123456789101112131415161718&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\", \"friends\": [ &#123; \"name\": \"Luke Skywalker\" &#125;, &#123; \"name\": \"Han Solo\" &#125;, &#123; \"name\": \"Leia Organa\" &#125; ] &#125; &#125;&#125; 请注意，在此示例中，friends字段返回一个项目数组。 GraphQL查询对于单个项或多个项列表写法上相同，但是我们根据schema中记录的内容知道预期获得的是哪一种。 参数（Arguments）如果我们唯一可以做的是遍历对象及其字段，则GraphQL已经是数据提取的非常有用的语言。但是如果你还能将参数传递给字段的话，事情会变得更有趣。123456&#123; human(id: &quot;1000&quot;) &#123; name height &#125;&#125; 12345678&#123; \"data\": &#123; \"human\": &#123; \"name\": \"Luke Skywalker\", \"height\": 1.72 &#125; &#125;&#125; 在像REST这样的系统中，您只能传递一组参数(paramter和url query)。但是在GraphQL中，每个字段和嵌套对象都可以获取自己的参数集，从而使一次GraphQL查询可以完全代替多个传统的API请求。您甚至可以将参数传递到标量字段中并在服务器上实现数据转换，而不需要在客户端上进行。 123456&#123; human(id: &quot;1000&quot;) &#123; name height(unit: FOOT) &#125;&#125; 12345678&#123; \"data\": &#123; \"human\": &#123; \"name\": \"Luke Skywalker\", \"height\": 5.6430448 &#125; &#125;&#125; 参数可以是很多不同的类型。在上面的例子中，我们使用了一个枚举类型，它表示一组有限的选项之一（在这种情况下是长度单位，METER或FOOT）。 GraphQL带有默认的类型，但是GraphQL服务器也可以声明自定义类型。只要能将它们序列化为可传输的格式。 别名（Aliases）也许您已经注意到，相对应的结果字段名与查询字段名相同，但却不包括该字段的查询参数，因此您不能直接使用不同的参数查询相同的字段。这就是为什么你需要别名的原因。12345678&#123; empireHero: hero(episode: EMPIRE) &#123; name &#125; jediHero: hero(episode: JEDI) &#123; name &#125;&#125; 12345678910&#123; \"data\": &#123; \"empireHero\": &#123; \"name\": \"Luke Skywalker\" &#125;, \"jediHero\": &#123; \"name\": \"R2-D2\" &#125; &#125;&#125; 片段（Fragments）假设我们的应用中存在一个比较复杂的页面，可以一次性展示两个角色并列出他们的朋友信息。可以想象，这样一个查询可能会很快变得复杂，因为我们需要重复写角色字段至少两次。 这就是为什么GraphQL包含“片段”这种可重用单元。片段让您构建一组字段，然后我们可以将它们包含在需要的查询中。以下是使用片段解决上述情况的示例： 12345678910111213141516&#123; leftComparison: hero(episode: EMPIRE) &#123; ...comparisonFields &#125; rightComparison: hero(episode: JEDI) &#123; ...comparisonFields &#125;&#125;fragment comparisonFields on Character &#123; name appearsIn friends &#123; name &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; \"data\": &#123; \"leftComparison\": &#123; \"name\": \"Luke Skywalker\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ], \"friends\": [ &#123; \"name\": \"Han Solo\" &#125;, &#123; \"name\": \"Leia Organa\" &#125;, &#123; \"name\": \"C-3PO\" &#125;, &#123; \"name\": \"R2-D2\" &#125; ] &#125;, \"rightComparison\": &#123; \"name\": \"R2-D2\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ], \"friends\": [ &#123; \"name\": \"Luke Skywalker\" &#125;, &#123; \"name\": \"Han Solo\" &#125;, &#123; \"name\": \"Leia Organa\" &#125; ] &#125; &#125;&#125; 如果重复这些字段，您可以看到上述查询将如何重复。片段的概念经常用于将复杂的应用程序数据需求分解成更小的块，特别是当您需要将大量具有不同片段的UI组件合并到一个初始数据请求时。 变量（variables）到目前为止，我们一直在查询字符串中写入所有的参数。 但在大多数应用程序中，字段的参数将是动态的：例如，可能会有一个下拉列表，您可以选择您感兴趣的星球大战插曲，或搜索字段或一组过滤器。 在查询字符串中直接传递这些动态参数并不是一个好主意，因为我们的客户端代码需要在运行时动态地处理查询字符串，并将其序列化为特定于图形的格式。 相反，GraphQL具有将查询中的动态值参数化的一级方法(first-class way)，并将其作为单独的字典传递。 这些值称为 变量 。 当开始使用变量之时，我们需要做三件事情： 用$variableName替换查询语句中静态的值 声明$variableName为一个被查询语句接收的变量之一 将$variableName: value写入到一种传输专用的变量字典中(通常是JSON)，用来与查询语句分别传输到服务器上。 整合后的结果： query 12345678query HeroNameAndFriends($episode: Episode) &#123; hero(episode: $episode) &#123; name friends &#123; name &#125; &#125;&#125; variables 123&#123; \"episode\": \"JEDI\"&#125; result 123456789101112131415161718&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\", \"friends\": [ &#123; \"name\": \"Luke Skywalker\" &#125;, &#123; \"name\": \"Han Solo\" &#125;, &#123; \"name\": \"Leia Organa\" &#125; ] &#125; &#125;&#125; 现在，在我们的客户端代码中，我们可以简单地传递一个不同的变量，而不需要构造一个全新的查询。 这通常也是一个好的做法，表示我们的查询中的哪些参数预期是动态的 - 我们不应该使用字符串插值来从用户提供的值构造查询。 变量定义变量定义是上面查询中的（$episode：Episode）部分。 它的作用就像类型语言中函数的参数定义一样。 它列出所有变量，前缀为$，后跟其类型（当前为Episode）。 所有声明的变量必须是标量，枚举或输入对象类型。 因此，如果要将复杂对象传递到字段中，则需要知道在服务器上匹配的输入类型。 在“架构”页面上了解有关输入对象类型的更多信息。 变量定义可以是可选的或必需的。 在上面的情况下，因为没有！ 在Episode类型后面，所以它是可选的。 但是，如果要将变量传递给需要非空参数的字段，那么该变量也必须是必需的。 要了解有关这些变量定义的语法的更多信息，学习GraphQL模式语言非常有用。 模式语言在Schema页面中有详细的说明。 默认变量可以在变量的类型声明后面添加该变量的默认值 12345678query HeroNameAndFriends($episode: Episode = &quot;JEDI&quot;) &#123; hero(episode: $episode) &#123; name friends &#123; name &#125; &#125;&#125; 操作名（Operation name）从上面的查询例子我们可以看到一个HeroNameAndFriends的操作名。但到目前为止，我们大部分是在速记语法，省略查询关键字和查询名称，但在生产中，这钟写法会使我们的代码不明确。 想想这就像你最喜欢的编程语言中的函数名。 例如，在JavaScript中，我们可以轻松地使用匿名函数，但是当我们给一个函数一个名字时，跟踪它更容易，调试我们的代码，并在被调用时记录。 以同样的方式，GraphQL查询和变量名称以及片段名称可以作为服务器端的一个有用的调试工具来识别不同的GraphQL请求。 指令（Directives）我们上面讨论了变量如何使我们避免进行手动字符串插值来构造动态查询。 在参数中传递变量解决了这些问题的一部分，但是我们也可能需要一种使用变量来动态地更改查询的结构和形状的方法。 例如，我们可以想象一个UI组件，它具有一个总结和详细的视图，其中一个包含比另一个更多的字段。让我们来为这样的组件构建一个查询语句： query 12345678query Hero($episode: Episode, $withFriends: Boolean!) &#123; hero(episode: $episode) &#123; name friends @include(if: $withFriends) &#123; name &#125; &#125;&#125; variables 1234&#123; \"episode\": \"JEDI\", \"withFriends\": false&#125; result 1234567&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\" &#125; &#125;&#125; 尝试编辑上面的变量（比如将true传给withFriends），看看结果如何变化。 我们需要在GraphQL中使用一个新功能，称为一个指令。 一个指令可以附加到字段或片段包含，并且可以以服务器的任何方式影响查询的执行。 核心GraphQL规范仅包含两个指令，这些指令必须由任何符合规范的GraphQL服务器实现支持： @include(if: Boolean) 仅当参数为true时返回结果才包括这个字段 @skip(if: Boolean) 当参数为true时跳过这个字段 指令可用于摆脱需要执行字符串操作以在查询中添加和删除字段的情况。 服务器实现也可以通过定义全新的指令来添加实验功能。 修改（Mutations）大多数关于GraphQL的讨论集中于数据获取，但是任何完整的数据平台也需要一种修改服务器端数据的方法。 在REST中，任何请求可能会导致在服务器上造成一些副作用，但按照惯例，建议不要使用GET请求来修改数据。 GraphQL是类似的：技术上任何查询都可以被实现来进行数据写入。 但是，建立一个约定，任何导致写入的操作都应该通过修改操作显式发送。 就像查询一样，如果修改字段返回一个对象类型，可以要求嵌套字段。 这可以在更新后获取对象的新状态。 我们来看一个简单的例子： mutation 123456mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123; createReview(episode: $ep, review: $review) &#123; stars commentary &#125;&#125; varialbes 1234567&#123; \"ep\": \"JEDI\", \"review\": &#123; \"stars\": 5, \"commentary\": \"This is a great movie!\" &#125;&#125; result 12345678&#123; \"data\": &#123; \"createReview\": &#123; \"stars\": 5, \"commentary\": \"This is a great movie!\" &#125; &#125;&#125; 注意createReview字段是如何返回新创建的review中的commentary和stars字段的。 这在修改已有字段的时候尤其有用，例如，当增加一个字段时，我们可以通过一个请求来同时修改该字段并查询该字段的新值。 您可能还会注意到，在本示例中，我们传入的评论变量不是标量。 它是一个输入对象类型，可以作为参数传入的特殊种类的对象类型。 详细了解“架构”页面上的输入类型。 修改多个字段像查询操作一样，一个修改操作可以包含多个字段，但是两者之间有一个重大的差异： 查询操作是并行的，而修改操作是串行的 这意味着，如果我们在一个修改操作中两次修改incremenetCredits字段的操作，第一个操作在保证结束后才会执行第二个操作。避免出现竞争情况。 内联片段（inline Fragments）跟其他类型系统一样，GraphQL也可以定义接口（Interfaces）和联合类型（Union Types）。详情见schema guide 你可以使用内联片段来访问一个接口或者联合类型中所包含的数据。用下面这个例子可以很方便的说明： query 1234567891011query HeroForEpisode($ep: Episode!) &#123; hero(episode: $ep) &#123; name ... on Droid &#123; primaryFunction &#125; ... on Human &#123; height &#125; &#125;&#125; variables 123&#123; \"ep\": \"JEDI\"&#125; result 12345678&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\", \"primaryFunction\": \"Astromech\" &#125; &#125;&#125; 在这个查询中，hero字段返回类型为Character，它可能是Human或Droid，这取决于参数episode。 在直接选择中，您只能访问Character接口中存在的字段，如name。 要访问具体类型的字段，您需要使用特定类型（type condition）的内联片段。 第一个片段在Droid上被标记为...，所以只有当从hero返回的Character是Droid类型时，primaryFunction字段才会被执行。 类似于Human类型中的height字段。 命名片段也可以以相同的方式使用，因为命名片段始终包含限定类型。 元字段（Meta fields）鉴于有些情况下您不知道从GraphQL服务返回的类型，您需要一些方法来确定如何处理客户端上的数据。 GraphQL允许您在查询中的任何位置请求__typename，一个元字段，以获取该点上对象类型的名称。 query 1234567891011121314&#123; search(text: &quot;an&quot;) &#123; __typename ... on Human &#123; name &#125; ... on Droid &#123; name &#125; ... on Starship &#123; name &#125; &#125;&#125; result 123456789101112131415161718&#123; \"data\": &#123; \"search\": [ &#123; \"__typename\": \"Human\", \"name\": \"Han Solo\" &#125;, &#123; \"__typename\": \"Droid\", \"name\": \"Leia Organa\" &#125;, &#123; \"__typename\": \"Starship\", \"name\": \"TIE Advanced x1\" &#125; ] &#125;&#125; 在上述查询中，search返回可以是三个选项之一的联合类型。 在没有__typename字段的情况下，不可能将客户端的不同类型告诉客户端。 GraphQL服务提供了少量的元字段，其余的公开 于“内省”系统。"},{"title":"GraphQL Learn (4) - Execution","permalink":"http://lishangying.github.io/2017/08/15/GraphQL Learn (4) - Execution/","text":"经过验证，GraphQL查询由GraphQL服务器执行，然后返回一个与查询形状相同的结果，通常为JSON。 GraphQL无法执行没有类型系统的查询，让我们使用类型系统例子来说明执行查询，这个例子是我们教程中使用的类型系统中的一部分： 12345678910111213141516type Query &#123; human(id: ID!): Human&#125;type Human &#123; name: String appearsIn: [Episode] starships: [Starship]&#125;enum Episode &#123; NEWHOPE EMPIRE JEDI&#125;type Starship &#123; name: String&#125; 为了解释执行查询语句时系统发生了什么，我们用下面的例子了跑一遍： 12345678910# &#123; &quot;graphiql&quot;: true &#125;&#123; human(id: 1002) &#123; name appearsIn starships &#123; name &#125; &#125;&#125; 1234567891011121314151617181920&#123; \"data\": &#123; \"human\": &#123; \"name\": \"Han Solo\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ], \"starships\": [ &#123; \"name\": \"Millenium Falcon\" &#125;, &#123; \"name\": \"Imperial shuttle\" &#125; ] &#125; &#125;&#125; 您可以将GraphQL查询中的每个字段视为返回下一个类型的类型函数或方法。 事实上，这正是GraphQL的工作原理。 每个类型的每个字段由GraphQL服务器开发人员提供的称为解析器 resolver 的函数支持。 当一个字段被执行时，相应的解析器被调用以产生下一个值。 如果一个字段产生一个标量值，如字符串或数字，则执行完成。 但是，如果一个字段产生一个对象值，则该查询将应用于他的子字段。 这样一直迭代到标量值。 GraphQL查询始终以标量值结束。 根字段和解析器（Root fields &amp; resolvers）每个GraphQL服务器的最顶层是一个特殊的类型，表示GraphQL API中所有可能入口点，通常称为根类型（Root type）或查询类型(Query type)。 在这个例子中，我们的查询类型提供了一个接受参数id 的human字段。此字段的解析函数可能通过访问数据库来构造并返回一个Human对象。 1234567Query: &#123; human(obj, args, context) &#123; return context.db.loadHumanByID(args.id).then( userData =&gt; new Human(userData) ) &#125;&#125; 该示例使用JavaScript编写，但是GraphQL服务器可以使用许多不同的语言构建。 解析器函数接收三个参数： obj 前一个对象，对于查询类型（Query type）中的字段来说不常用。 args GraphQL提供的参数。 context 提供给每个解析器并保存重要的上下文信息（如当前登录的用户、访问数据库）的值。异步解析器（Asynchronous resolvers）我们来仔细看看这个解析器函数发生了什么：12345human(obj, args, context) &#123; return context.db.loadHumanByID(args.id).then( userData =&gt; new Human(userData) )&#125; context用于提供对数据库的访问，通过GraphQL查询提供的参数id来向数据库查询数据。 由于数据库查询是异步操作，所以返回一个Promise。 在JavaScript中，Promises用于处理异步值，但是在许多语言中都存在相同的概念，通常称为 Futures ， Tasks 或 Deferred 。 当数据库返回时，我们可以构造并返回一个新的 Human 对象。 另外，虽然解析器函数需要留意Promises的使用，但是GraphQL查询不会。 在执行期间，GraphQL将等待Promises/Futures和Tasks完成，然后继续，并以最佳并发方式执行此操作。 微型解析器（Trivial resolvers）至此，我们已经得到了Human对象，GraphQL将在这个对象内所要求的字段中继续执行。 12345Human: &#123; name(obj, args, context) &#123; return obj.name &#125;&#125; GraphQL服务由类型系统组成，它能够帮助服务确定下一步做什么的。 即使在human字段返回之前，GraphQL知道下一步将是解决Human中的字段，因为类型系统告诉human字段将返回一个Human。 上面代码中的名称解析是很直接的。 调用名称解析函数，然后obj参数来自于上一个字段返回的新的Human对象。 我们期望Human对象有一个name属性，我们可以直接读取并返回。 实际上，许多GraphQL库可以让你省略这个简单的解决方案，一个约定：假如一个字段没有提供解析函数，那么应该读取和返回同名的属性。 标量强转（Scalar coercion）当name字段正在解析时，appearsIn和starships字段也可以同时进行解析。 appearsIn字段也可以有一个微型解析器，但是让我们进一步了解一下： 12345Human: &#123; appearsIn(obj) &#123; return obj.appearsIn // returns [ 4, 5, 6 ] &#125;&#125; 请注意，我们的类型系统声明appearsIn将返回一直枚举值中的一个，但此函数却返回数字！实际上，如果我们查看结果，我们将看到正在返回适当的枚举值。 这是怎么回事？ 这是标量强转的一个例子。 类型系统知道期望的类型并将解析器函数返回的值转换为API约定中的内容。 在例子中，我们的服务器上可能会定义一个Enum，它在内部使用数字比如4,5和6，但在GraphQL类型系统中将它们表示为枚举值。 列表解析器（List resolvers）之前我们已经看到了appearsIn字段返回列表的情况，因为这是系统期望的类型，列表中的每个项将被被强转为对应的枚举类型。 当starships解析时会发生什么？ 123456789Human: &#123; starships(obj, args, context) &#123; return obj.starshipIDs.map( id =&gt; context.db.loadStarshipByID(id).then( shipData =&gt; new Starship(shipData) ) ) &#125;&#125; 该字段的解析器不是单单返回一个Promise，它返回了一个Promises列表。 Human对象有他们驾驶的Starships的id列表，但是我们需要通过所有这些id来获得真正的Starship对象。 GraphQL将在继续之前同时等待所有这些Promises，并且当剩下一个对象列表时，它将同时继续加载每个这些项目上的name字段。 产出结果（Producing the result）当每个字段被解析时，结果值被放置到键值映射中，字段名称（或别名）作为键，解析出来的值作为值，这这过程从查询底部叶子节点的字段往上直到原始字段的根查询类型。 总而言之，它们产生一个镜像的原始查询结构，然后可以将其发送（通常为JSON）到请求的客户端。 我们来看看最初的查询，看看这些解析函数如何产生一个结果： 12345678910# &#123; &quot;graphiql&quot;: true &#125;&#123; human(id: 1002) &#123; name appearsIn starships &#123; name &#125; &#125;&#125; 1234567891011121314151617181920&#123; \"data\": &#123; \"human\": &#123; \"name\": \"Han Solo\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ], \"starships\": [ &#123; \"name\": \"Millenium Falcon\" &#125;, &#123; \"name\": \"Imperial shuttle\" &#125; ] &#125; &#125;&#125;"},{"title":"GraphQL Learn (5) - Introspection","permalink":"http://lishangying.github.io/2017/08/15/GraphQL Learn (5) - Introspection/","text":"查询GraphQL架构有关它支持的查询的信息通常很有用。 GraphQL允许我们使用内省系统来做到这一点！对于我们的星球大战例子来说，文件starWarsIntrospection-test.js包含许多查询内省系统的查询，并且是一个完整的按照规范实现的测试文件。 我们设计了类型系统，所以我们应该知道系统中可用的类型。但是如果不知道，我们还可以通过查询__schema字段来询问GraphQL。这个字段始终存在于根类型中。 12345678# &#123; &quot;graphiql&quot;: true &#125;&#123; __schema &#123; types &#123; name &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&#123; \"data\": &#123; \"__schema\": &#123; \"types\": [ &#123; \"name\": \"Query\" &#125;, &#123; \"name\": \"Episode\" &#125;, &#123; \"name\": \"Character\" &#125;, &#123; \"name\": \"ID\" &#125;, &#123; \"name\": \"String\" &#125;, &#123; \"name\": \"Int\" &#125;, &#123; \"name\": \"FriendsConnection\" &#125;, &#123; \"name\": \"FriendsEdge\" &#125;, &#123; \"name\": \"PageInfo\" &#125;, &#123; \"name\": \"Boolean\" &#125;, &#123; \"name\": \"Review\" &#125;, &#123; \"name\": \"SearchResult\" &#125;, &#123; \"name\": \"Human\" &#125;, &#123; \"name\": \"LengthUnit\" &#125;, &#123; \"name\": \"Float\" &#125;, &#123; \"name\": \"Starship\" &#125;, &#123; \"name\": \"Droid\" &#125;, &#123; \"name\": \"Mutation\" &#125;, &#123; \"name\": \"ReviewInput\" &#125;, &#123; \"name\": \"__Schema\" &#125;, &#123; \"name\": \"__Type\" &#125;, &#123; \"name\": \"__TypeKind\" &#125;, &#123; \"name\": \"__Field\" &#125;, &#123; \"name\": \"__InputValue\" &#125;, &#123; \"name\": \"__EnumValue\" &#125;, &#123; \"name\": \"__Directive\" &#125;, &#123; \"name\": \"__DirectiveLocation\" &#125; ] &#125; &#125;&#125; 哇哦，这上面输出了很多类型，他们代表什么？让我们对他们进行一下分类： Query, Character, Human, Episode, Droid - 这些都是我们在类型系统中定义的类型 String, Boolean - 这些是类型系统中内建的标量类型 __Schema, __Type, __TypeKind, __Field, __InputValue, __EnumValue, __Directive 这些名字都用双下划线做前缀，用来表示是内省系统里的类型。 现在，让我们开始探索系统可用的查询。首先，当设计我们的类型系统时，我们指定了一个起始查询的类型，让内省系统告诉我们起始查询的名字： 12345678# &#123; &quot;graphiql&quot;: true &#125;&#123; __schema &#123; queryType &#123; name &#125; &#125;&#125; 123456789&#123; \"data\": &#123; \"__schema\": &#123; \"queryType\": &#123; \"name\": \"Query\" &#125; &#125; &#125;&#125; 返回的结果与类型系统部分中所描述的匹配，Query类型是我们将要开始的地方！ 请注意，这里的命名只是为了方便，我们可以将Query类型命名为其他任何东西，如果我们指定它是查询的起始类型，系统仍然会返回相应的结果。虽然将它命名为Query 是一个比较实用的约定。 让我们来看看Droid类型： 123456# &#123; &quot;graphiql&quot;: true &#125;&#123; __type(name: &quot;Droid&quot;) &#123; name &#125;&#125; 1234567&#123; \"data\": &#123; \"__type\": &#123; \"name\": \"Droid\" &#125; &#125;&#125; 如果我们需要知道更多的关于Droid的信息，比如说其中的一个接口或对象呢？ 1234567# &#123; &quot;graphiql&quot;: true &#125;&#123; __type(name: &quot;Droid&quot;) &#123; name kind &#125;&#125; 12345678&#123; \"data\": &#123; \"__type\": &#123; \"name\": \"Droid\", \"kind\": \"OBJECT\" &#125; &#125;&#125; kind返回一个__TypeKind的枚举类型，值为OBJECT1，如果我们直接查询Character而不在接口里面的话呢？ 1234567# &#123; &quot;graphiql&quot;: true &#125;&#123; __type(name: &quot;Character&quot;) &#123; name kind &#125;&#125; 12345678&#123; \"data\": &#123; \"__type\": &#123; \"name\": \"Character\", \"kind\": \"INTERFACE\" &#125; &#125;&#125; 知道一个对象所包含的所有字段是很常见的需求。所以，让我们继续查询Droid上面的内省系统： 12345678910111213# &#123; &quot;graphiql&quot;: true &#125;&#123; __type(name: &quot;Droid&quot;) &#123; name fields &#123; name type &#123; name kind &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; \"data\": &#123; \"__type\": &#123; \"name\": \"Droid\", \"fields\": [ &#123; \"name\": \"id\", \"type\": &#123; \"name\": null, \"kind\": \"NON_NULL\" &#125; &#125;, &#123; \"name\": \"name\", \"type\": &#123; \"name\": null, \"kind\": \"NON_NULL\" &#125; &#125;, &#123; \"name\": \"friends\", \"type\": &#123; \"name\": null, \"kind\": \"LIST\" &#125; &#125;, &#123; \"name\": \"friendsConnection\", \"type\": &#123; \"name\": null, \"kind\": \"NON_NULL\" &#125; &#125;, &#123; \"name\": \"appearsIn\", \"type\": &#123; \"name\": null, \"kind\": \"NON_NULL\" &#125; &#125;, &#123; \"name\": \"primaryFunction\", \"type\": &#123; \"name\": \"String\", \"kind\": \"SCALAR\" &#125; &#125; ] &#125; &#125;&#125; 这些就是我们在Droid上面定义的字段！ id看起来有点奇怪，它没有类型的名称。 因为它是一种“封装”的NON_NULL类型。 如果我们查询该字段类型的ofType信息，我们将会得到一个ID类型，告诉我们这是一个非空ID。相似的，friends和appearsIn也没有类型名，因为他们是一个LIST封装过的类型。我们可以查询他们的ofType信息，我们将会得到一个LIST类型。 1234567891011121314151617# &#123; &quot;graphiql&quot;: true &#125;&#123; __type(name: &quot;Droid&quot;) &#123; name fields &#123; name type &#123; name kind ofType &#123; name kind &#125; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&#123; \"data\": &#123; \"__type\": &#123; \"name\": \"Droid\", \"fields\": [ &#123; \"name\": \"id\", \"type\": &#123; \"name\": null, \"kind\": \"NON_NULL\", \"ofType\": &#123; \"name\": \"ID\", \"kind\": \"SCALAR\" &#125; &#125; &#125;, &#123; \"name\": \"name\", \"type\": &#123; \"name\": null, \"kind\": \"NON_NULL\", \"ofType\": &#123; \"name\": \"String\", \"kind\": \"SCALAR\" &#125; &#125; &#125;, &#123; \"name\": \"friends\", \"type\": &#123; \"name\": null, \"kind\": \"LIST\", \"ofType\": &#123; \"name\": \"Character\", \"kind\": \"INTERFACE\" &#125; &#125; &#125;, &#123; \"name\": \"friendsConnection\", \"type\": &#123; \"name\": null, \"kind\": \"NON_NULL\", \"ofType\": &#123; \"name\": \"FriendsConnection\", \"kind\": \"OBJECT\" &#125; &#125; &#125;, &#123; \"name\": \"appearsIn\", \"type\": &#123; \"name\": null, \"kind\": \"NON_NULL\", \"ofType\": &#123; \"name\": null, \"kind\": \"LIST\" &#125; &#125; &#125;, &#123; \"name\": \"primaryFunction\", \"type\": &#123; \"name\": \"String\", \"kind\": \"SCALAR\", \"ofType\": null &#125; &#125; ] &#125; &#125;&#125; 让我们在这个非常适合作为一个工具的内省系统特性上结束本教程。让用户向系统本身查询文档！ 1234567# &#123; &quot;graphiql&quot;: true &#125;&#123; __type(name: &quot;Droid&quot;) &#123; name description &#125;&#125; 12345678&#123; \"data\": &#123; \"__type\": &#123; \"name\": \"Droid\", \"description\": \"An autonomous mechanical character in the Star Wars universe\" &#125; &#125;&#125; 我们可以使用内省系统访问有关类型系统的文档，并创造一种文档浏览器或富IDE的体验。 这些只是内省系统的冰山一角，我们还可以查询枚举值、一个类型实现的接口等等。 我们甚至可以内省我们的内省系统本身。 该规范在“Introspection”部分中有关于该主题的更多细节，GraphQL.js中的 introspection文件包含规范的代码实现。"},{"title":"GraphQL Learn (3) - Validation","permalink":"http://lishangying.github.io/2017/08/15/GraphQL Learn (3) - Validation/","text":"通过使用类型系统，可以预先确定GraphQL查询是否有效。 这样可以让服务器和客户端有效地通知开发人员在创建无效查询时，无需在运行时检查。 对于我们的星球大战示例，文件starWarsValidation-test.js包含许多无效的查询，可以用来测试当前实现的验证器。 首先，我们来看一个复杂的有效查询。 这是一个嵌套查询，类似于上一节的一个示例，但将重复的字段分解成一个片段： 12345678910111213141516&#123; hero &#123; ...NameAndAppearances friends &#123; ...NameAndAppearances friends &#123; ...NameAndAppearances &#125; &#125; &#125;&#125;fragment NameAndAppearances on Character &#123; name appearsIn&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ], \"friends\": [ &#123; \"name\": \"Luke Skywalker\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ], \"friends\": [ &#123; \"name\": \"Han Solo\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ] &#125;, &#123; \"name\": \"Leia Organa\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ] &#125;, &#123; \"name\": \"C-3PO\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ] &#125;, &#123; \"name\": \"R2-D2\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ] &#125; ] &#125;, &#123; \"name\": \"Han Solo\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ], \"friends\": [ &#123; \"name\": \"Luke Skywalker\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ] &#125;, &#123; \"name\": \"Leia Organa\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ] &#125;, &#123; \"name\": \"R2-D2\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ] &#125; ] &#125;, &#123; \"name\": \"Leia Organa\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ], \"friends\": [ &#123; \"name\": \"Luke Skywalker\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ] &#125;, &#123; \"name\": \"Han Solo\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ] &#125;, &#123; \"name\": \"C-3PO\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ] &#125;, &#123; \"name\": \"R2-D2\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ] &#125; ] &#125; ] &#125; &#125;&#125; 这个查询是合法的，让我们看一些非法的查询： 片段不能引用自身或创建一个循环，因为这可能导致无限循环！ 以上是上述相同的查询，但没有弄明白的三层的嵌套关系。 1234567891011121314# &#123; &quot;graphiql&quot;: true &#125;&#123; hero &#123; ...NameAndAppearancesAndFriends &#125;&#125;fragment NameAndAppearancesAndFriends on Character &#123; name appearsIn friends &#123; ...NameAndAppearancesAndFriends &#125;&#125; 12345678910111213&#123; \"errors\": [ &#123; \"message\": \"Cannot spread fragment \\\"NameAndAppearancesAndFriends\\\" within itself.\", \"locations\": [ &#123; \"line\": 11, \"column\": 5 &#125; ] &#125; ]&#125; 当我们查询字段时，我们必须查询给定类型上存在的字段。 所以当hereo返回一个Character时，我们必须在一个Character字段上查询，然而该类型没有favoriteSpaceship字段，因此此查询无效： 1234567# &#123; &quot;graphiql&quot;: true &#125;# INVALID: favoriteSpaceship does not exist on Character&#123; hero &#123; favoriteSpaceship &#125;&#125; 12345678910111213&#123; \"errors\": [ &#123; \"message\": \"Cannot query field \\\"favoriteSpaceship\\\" on type \\\"Character\\\".\", \"locations\": [ &#123; \"line\": 4, \"column\": 5 &#125; ] &#125; ]&#125; 每当我们查询一个字段并返回除标量或枚举之外的东西时，我们需要指定我们想从字段中获取的数据。 hero返回一个Character，而我们一直在请求其中的字段，如name和appearIn; 如果我们忽略，查询将不合法： 12345# &#123; &quot;graphiql&quot;: true &#125;# INVALID: hero is not a scalar, so fields are needed&#123; hero&#125; 12345678910111213&#123; \"errors\": [ &#123; \"message\": \"Cannot query field \\\"favoriteSpaceship\\\" on type \\\"Character\\\".\", \"locations\": [ &#123; \"line\": 4, \"column\": 5 &#125; ] &#125; ]&#125; 类似地，如果一个字段是一个标量，查询其中的其他字段就没有意义，这样做会使查询不合法： 123456789# &#123; &quot;graphiql&quot;: true &#125;# INVALID: name is a scalar, so fields are not permitted&#123; hero &#123; name &#123; firstCharacterOfName &#125; &#125;&#125; 12345678910111213&#123; \"errors\": [ &#123; \"message\": \"Field \\\"name\\\" must not have a selection since type \\\"String!\\\" has no subfields.\", \"locations\": [ &#123; \"line\": 4, \"column\": 10 &#125; ] &#125; ]&#125; 之前，有人指出，查询只能查询有关类型的字段; 当我们查询返回一个Character的hero时，我们只能查询Character上存在的字段。 如果要直接查询R2-D2s的主要功能，会发生什么？ 12345678# &#123; &quot;graphiql&quot;: true &#125;# INVALID: primaryFunction does not exist on Character&#123; hero &#123; name primaryFunction &#125;&#125; 12345678910111213&#123; \"errors\": [ &#123; \"message\": \"Cannot query field \\\"primaryFunction\\\" on type \\\"Character\\\". Did you mean to use an inline fragment on \\\"Droid\\\"?\", \"locations\": [ &#123; \"line\": 5, \"column\": 5 &#125; ] &#125; ]&#125; 该查询无效，因为primaryFunction不是Character上字段。 我们想要一些判断，如果Character是Droid，则获取primaryFunction，否则忽略该字段。 我们可以使用前面介绍的片段（Fragment）来做到这一点。 通过设置一个在Droid上定义的片段并包含它，我们确保我们只查询已定义的primaryFunction。 1234567891011# &#123; &quot;graphiql&quot;: true &#125;&#123; hero &#123; name ...DroidFields &#125;&#125;fragment DroidFields on Droid &#123; primaryFunction&#125; 12345678&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\", \"primaryFunction\": \"Astromech\" &#125; &#125;&#125; 这个查询是合法的，但它有点冗长; 当我们需要多次使用它时，命名片段是有价值的，但是如果我们只使用一次，我们可以直接使用内联片段。 123456789# &#123; &quot;graphiql&quot;: true &#125;&#123; hero &#123; name ... on Droid &#123; primaryFunction &#125; &#125;&#125; 12345678&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\", \"primaryFunction\": \"Astromech\" &#125; &#125;&#125; 以上只是验证系统的表面一层，事实上存在这很多验证规则来确保GraphQL查询具有良好的语义和意义。规范中的”Validation”章节有更详细的介绍。validation 中包含了GraphQL符合规范的代码实现。"},{"title":"GraphQL Learn (2) - Schemas and Types","permalink":"http://lishangying.github.io/2017/08/15/GraphQL Learn (2) - Schemas and Types/","text":"在此页面上，您将了解有关GraphQL类型系统的所有知识，以及如何描述可查询哪些数据。 由于GraphQL可以与任何后端框架或编程语言一起使用，因此我们将远离实现特定的详细信息，仅讨论概念。 类型系统（Type System）如果您以前看过GraphQL查询，那么你应该知道GraphQL查询语言基本上是在对象上选择字段。 所以在以下查询中： 123456&#123; hero &#123; name appearsIn &#125;&#125; 123456789101112&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ] &#125; &#125;&#125; 从一个特殊的 “root”对象开始 在它里面选择一个hero字段 在hero返回的对象中，我们继续选择 name 和 appearsIn 字段 因为GraphQL查询的形状与结果非常相似，所以您可以预测什么是查询将返回，而不必关心服务器的设置。 但是我们还是需要对我们所请求的数据进行详细的描述： 我们可以选择哪些字段？ 他们可能返回什么样的对象？ 这些子对象里面包含哪些字段？ 这就是schema所需要解决的问题。 每个GraphQL服务定义一组完全描述可以在该服务上查询的可能数据的类型。 然后，当收到查询时，它们将根据该架构进行验证和执行。. 类型语句（Type language）GraphQL服务可以用任何语言编写。我们不能依赖特定的编程语言语法（如JavaScript），因此我们将使用“GraphQL schema 语言” ，它类似于查询语言，并允许我们以语言无关的方式谈论GraphQL的架构。 对象的类型和字段（Object types and fields）GraphQL的最基本的组件是对象类型，表示你可以从服务中获取的一种对象，以及它具有哪些字段。 在GraphQL schema语言中，我们可以这样表示： 1234type Character &#123; name: String! appearsIn: [Episode]!&#125; 可读性已经很高了，但是让我们再过一遍，以便于让我们在细节上拥有共同的语言： Character是一个对象类型，大多数情况下，schema里面的type都是一个对象 name和appearsIn是Character中的字段。意味着在任何查询包含Character 类的时候name和appearsIn是仅有且必须出现在其中的字段 String是内置的标量类型之一，标量是GraphQL中的最小的类型，不能再做子选择了。 我们会稍后再看标量类型。 String!代表着这个字段是不为空的，GraphQL服务保证在这个字段上返回一个不为空的值。 [Episode]!代表着一个包含Episode对象的数列，它也是不为空的，因此当你查询appearsIn字段时，GraphQL永远会返回一个数组，即使是一个空数组。 现在，您知道GraphQL对象类型是什么样子了，并且掌握了如何读取GraphQL类型语言的基础知识。 参数（Arguments）GraphQL对象类型上的每个字段都可以有零个或多个参数，例如下面的length字段： 12345type Starship &#123; id: ID! name: String! length(unit: LengthUnit = METER): Float&#125; 所有参数都是有命名的。与JavaScript和Python这样的语言不同，函数采用有序参数列表，GraphQL中的所有参数都是通过名称进行传递。上面例子中，length字段有一个定义的参数，unit。 参数可以是必需的或可选的。当参数是可选的时候，我们可以定义一个默认值 。上面例子中，如果unit参数没有被传递，默认情况下它将被设置为METER。 Query和Mutation类型（The Query and Mutation types）schema中的大多数类型将只是普通对象类型，但其中有两种特殊的类型： 1234schema &#123; query: Query mutation: Mutation&#125; 每个GraphQL服务都有一个query类型，但可能有也可能没有mutation类型。 这些类型与常规对象类型相同，但它们是特殊的，因为它们定义了每个GraphQL查询的入口点。 所以如果你看到一个查询： 12345678query &#123; hero &#123; name &#125; droid(id: &quot;2000&quot;) &#123; name &#125;&#125; 12345678910&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\" &#125;, \"droid\": &#123; \"name\": \"C-3PO\" &#125; &#125;&#125; 这意味着GraphQL服务需要一个具有hero和droid字段的query类型： 1234type Query &#123; hero(episode: Episode): Character droid(id: ID!): Droid&#125; Mutation相同，您可以定义Mutation类型上的字段，这些字段就是你能变更的根字段。 重要的是要记住，除了作为模式的“入口点”的特殊状态之外，“查询和变更”类型与任何其他GraphQL对象类型相同，它们的字段的工作方式完全相同。 标量类型（Scalar types）GraphQL对象类型具有名称和字段，但在某些时候，这些字段必须解析为某些具体数据。 这就是标量类型的来历：它们代表查询最低端的叶子节点。下面查询中，name和appearsIn将会被解析为标量类型（因为这两个字段没有任何子字段，他们是本次查询的叶子节点）： 123456&#123; hero &#123; name appearsIn &#125;&#125; 123456789101112&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ] &#125; &#125;&#125; GraphQL默认自带了一些变量类型： Int: 带符号32位的整数. Float: 带符号的双精度浮点数. String: UTF-8的字符串. Boolean: true 或false. ID: ID标量类型表示一个唯一的标识，通常用于重新获取对象或作为缓存中的键。 ID类型其实就是String类型; 然而将其定义为ID表示它是没有可读性的。 在大多数GraphQL服务实现中，还有一种方法来自定义标量类型。 例如，我们可以定义一个日期类型： 1scalar Date 然后由我们的自己来实现该自定义类型如何序列化，反序列化和验证。 例如，您可以指定Date类型应始终序列化为整数时间戳，并且让你的客户端也知道该格式。 枚举类型（Enumeration types）也称为枚举（ Enums ），枚举类型是一种特殊类型的标量，仅限于一组特定的允许值。 这样你可以： 验证此类型的任何参数是允许的值之一 通过类型系统沟通一个字段永远是一组有限的值 以下是GraphQL Schema语言中的枚举定义： 12345enum Episode &#123; NEWHOPE EMPIRE JEDI&#125; 这意味着无论何时我们在Schema中使用Episode类型时，其对应的值永远都是NEWHOPE, EMPIRE, JEDI中间的一个。 请注意，各种语言的GraphQL服务实现将以自己的语言特定方式来处理枚举。 以支持枚举作“为一流公民”的语言，某些实现可能会利用这一点; 在没有枚举支持的JavaScript语言中，这些值可能在内部映射到一组整数。 但是，这些细节不会泄露给客户端，客户端可以完全按照枚举值的字符串名称进行操作。 列表和非空类型（Lists and Non-Null）对象类型，标量和枚举是GraphQL中唯一可以定义的类型。 但是当您在Schema的其他部分或查询变量声明中使用这些类型时，可以使用类型修饰符来影响这些值的验证规则。 我们来看一个例子： 1234type Character &#123; name: String! appearsIn: [Episode]!&#125; 在这里，我们使用一个String类型，并通过在它之后添加一个感叹号将其标记为一个非空类型。 这意味着我们的服务器总是期望为此字段返回一个非空值，如果最终得到一个空值，实际上会触发一个GraphQL执行错误，让客户端知道出现了一些问题。 在定义字段的参数时，也可以使用非空类型修饰符，如果将null值作为该参数传递，则GraphQL服务器将返回验证错误，无论是在GraphQL字符串还是变量中。 12345query DroidById($id: ID!) &#123; droid(id: $id) &#123; name &#125;&#125; 123&#123; \"id\": null&#125; 12345678910111213&#123; \"errors\": [ &#123; \"message\": \"Variable \\\"$id\\\" of required type \\\"ID!\\\" was not provided.\", \"locations\": [ &#123; \"line\": 1, \"column\": 17 &#125; ] &#125; ]&#125; 列表以类似的方式工作：我们可以使用类型修饰符将类型标记为List，这表示该字段将返回该类型的数组。 在模式语言中，通过将类型包装在方括号[和]中来表示。 它与参数的表现相同但验证步骤将期望该值的数组。 非空修饰符和列表修饰符可以一起使用，例如，你可以要求一个由非空字符串组成的列表： 1myField: [String!] 这意味着列表本身可以为空，但它不能有任何空的成员。例如，在返回的JSON中： 1234myField: null // validmyField: [] // validmyField: ['a', 'b'] // validmyField: ['a', null, 'b'] // error 现在，让我们定义一个由字符串组成的非空数组： 1myField: [String]! 这意味着列表本身不能为空，但它可以包含空值： 1234myField: null // errormyField: [] // validmyField: ['a', 'b'] // validmyField: ['a', null, 'b'] // valid 您可以根据需要随意嵌套任意数量的非空和列表修饰符。 接口（Interfaces）像许多类型的系统一样，GraphQL支持接口。 接口是一种抽象类型，它包含一组类型必须包含已实现该接口的字段。 例如，你可以有一个Character接口表示星球大战三部曲中的任何角色： 123456interface Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]!&#125; 这意味着，任何实现了Character接口的类型，都必须拥有这些字段，包括他们的参数和返回类型。例如，下面列举了一些实现Character接口的类型： 12345678910111213141516type Human implements Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]! starships: [Starship] totalCredits: Int&#125;type Droid implements Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]! primaryFunction: String&#125; 您可以看到，这两种类型都具有Character接口中的所有字段，还可以引入特定类型字符的额外字段，totalCredits，starships和primaryFunction。 当您要返回一个对象或一组对象时，接口很有用，但这些对象可能有几种不同的类型。 请注意以下查询会产生错误： 1234567# &#123; &quot;graphiql&quot;: true, &quot;variables&quot;: &#123; &quot;ep&quot;: &quot;JEDI&quot; &#125; &#125;query HeroForEpisode($ep: Episode!) &#123; hero(episode: $ep) &#123; name primaryFunction &#125;&#125; 123&#123; \"ep\": \"JEDI\"&#125; 12345678910111213&#123; \"errors\": [ &#123; \"message\": \"Cannot query field \\\"primaryFunction\\\" on type \\\"Character\\\". Did you mean to use an inline fragment on \\\"Droid\\\"?\", \"locations\": [ &#123; \"line\": 4, \"column\": 5 &#125; ] &#125; ]&#125; hero字段返回字符类型，这意味着它可能是Human或Droid，取决于episode参数。 在上面的查询中，您只能询问Character接口中存在的字段，不包括primaryFunction。 为了得到在一个特定对象类型中的字段，你需要使用内联片段(inline fragment) 12345678query HeroForEpisode($ep: Episode!) &#123; hero(episode: $ep) &#123; name ... on Droid &#123; primaryFunction &#125; &#125;&#125; 123&#123; \"ep\": \"JEDI\"&#125; 12345678&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\", \"primaryFunction\": \"Astromech\" &#125; &#125;&#125; 联合类型（Union types）联合类型与接口非常相似，但它们不能指定类型之间的任何公共字段。 1union SearchResult = Human | Droid | Starship 当Schema返回了一个SearchResult类型，我们实际上可能会得到一个Human，一个Droid或者一个Starship。 注意，联合类型的成员需要是具体的对象类型; 您不能在接口或其他联合类型之上再创造一个联合类型。（扁平结构） 在这种情况下，如果查询返回的是SearchResult这样的联合类型字段，则需要使用条件片段才能查询其中的任意子字段： 12345678910111213141516&#123; search(text: &quot;an&quot;) &#123; ... on Human &#123; name height &#125; ... on Droid &#123; name primaryFunction &#125; ... on Starship &#123; name length &#125; &#125;&#125; 123456789101112131415161718&#123; \"data\": &#123; \"search\": [ &#123; \"name\": \"Han Solo\", \"height\": 1.8 &#125;, &#123; \"name\": \"Leia Organa\", \"height\": 1.5 &#125;, &#123; \"name\": \"TIE Advanced x1\", \"length\": 9.2 &#125; ] &#125;&#125; 输入类型（Input types）到目前为止，我们只谈到将标量值（如枚举或字符串）作为参数传递到一个字段中。 但您也可以轻松地传递复杂的对象。 这在变更（Mutation）的情况下特别有价值，在这种情况下，您可能想要传入要创建的整个对象。 在GraphQL Schema语言中，输入类型与常规对象类型完全相同，但使用关键字input而不是type： 1234input ReviewInput &#123; stars: Int! commentary: String&#125; 下面是如何在变更语句中使用输入类型对象的例子： 123456mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123; createReview(episode: $ep, review: $review) &#123; stars commentary &#125;&#125; 1234567&#123; \"ep\": \"JEDI\", \"review\": &#123; \"stars\": 5, \"commentary\": \"This is a great movie!\" &#125;&#125; 12345678&#123; \"data\": &#123; \"createReview\": &#123; \"stars\": 5, \"commentary\": \"This is a great movie!\" &#125; &#125;&#125; 输入类型对象上的字段本身可以引用其他输入类型对象，但是您不能在Schema中混合输入和输出类型。 输入类型对象也不能在其字段上有参数。"},{"title":"你的名字","permalink":"http://lishangying.github.io/2017/08/11/yourname/","text":"或许平行时空下，还活着另外一个我。每一天的平安过活，都是在履行存在的意义。一部灾难幸存片。这也是一个美好愿望吧，愿天灾能避免。冥冥之中注定的我爱你。激起平凡生活中的波澜吧。为什么会流泪呢？为什么会哭泣呢？那中怅然若失的感觉。梦中的故事有时就像真实发生过一样。许多生命存在的意义是什么呢？在于传承，也在于本身吧。每天浑浑噩噩生活着，也是一种生活的方式。面对事物的淡然或是较真。都在反映着我真实的活着。就像一种信仰一样真实。故事本身的意义。故事本身就是充满想象与荒诞的。没有对与错。但直击心灵，就像发生在自己身上一样的真实。感动，为这真实的情感。 带入感强烈的男女主角隐隐的对大自然事件叹为观止，却又希望灾难能不发生。可能我们都不再记起具体情节。但却是一直在寻找彼此。爱情的结合是如此的奇妙。人世间如此的孤独，却因为一个人的存在，这个城市也有了鲜活的意义。没有天生的血缘，却有离不开的牵绊。因为孤独，所以我们体会了彼此的人生。让我们更深切感受到互相真实存在的证据。可能时间，流动的时间，也是某种“结”，让生命跳动起来。青春的悸动，是最美好的东西，生命美好的传承起源于此。最直接最原始的诉求，就是生命的传承。美好事物的更替。人活着，不就是在追求美好的事物，美好的时光吗？一份再平凡不过的爱情。一个再平凡不过的少女，拥有的也是独一无二的灵魂和人生。就像你我一样。可能在不经意间，就改变了世界的走向。嗯，因为我们都做了一点贡献，这个世界变得更加美好。爱情真的可能改变一个人的。让人变得成长。了解了更真实的社会。愿有情人终成眷属。"},{"title":"体验I3之美","permalink":"http://lishangying.github.io/2017/03/20/beautifull-i3/","text":"先晒张日常桌面图。Gnome3用了半年了一直被其蹩脚的交互和层出不穷的Bug所折磨。虽然Gnome3很漂亮，很简洁，但是毕竟漂亮不能当饭吃。套餐这种东西虽然简单省事，但是终究不是为你所量身定制的，总有其中一样不合你口味。因此，我决定再次抛弃“开箱即用”的DE(Desktop Environment)，在WM(Window Manager)的基础上自己打造一套适合自己的桌面环境。 i3WMi3是一个比较知名的平铺式的窗口管理器（TilingWM），它可以通过快捷键来管理程序窗口，使他们像截图那样平铺在显示屏幕，控制他们的大小和位置。十分高效也有几分Geek的味道。i3的所有配置全部使用shell写成，甚至顶部panel的各种指示器，都由用户自己写的bash脚本获得并显示。十分简单暴力。虽然没有图形界面那么直观，但是有一种一切尽在自己掌控之下的感觉。这种感觉其实是十分十分不错的。我的I3WM配置文件托管在了Github。 配置细节I3配置文件的语法其实跟shell差不多，熟悉Linux的用户应该都能完全看懂。我的配置文件分为几大模块： Workspaces工作区配置，我根据日常使用的程序类别一共设置了10个工作区(图标显示需要在本地电脑上安装Fontawesome字体）：12345678910set $ws1 \"1: Browser\"set $ws2 \"2: Code\"set $ws3 \"3: Chat\"set $ws4 \"4: File\"set $ws5 \"5: Terminal\"set $ws6 \"6: Video\"set $ws7 \"7: Music\"set $ws8 \"8: Graphic\"set $ws9 \"9: Game\"set $ws0 \"0: Fullscreen\" 然后，把属于各自类别的程序绑定到对应的工作区，这样打开这些程序的时候他们就能自动出现在合适的工作区了：1234567assign [class=\"google-chrome-stable\"] $ws1 # Browserassign [class=\"vivaldi\"] $ws1 # Browserassign [class=\"firefox\"] $ws1 # Browserassign [class=\"(?i)code\"] $ws2 # Code IDE# ...assign [class=\"dota2\"] $ws0 # Fullscreenassign [class=\"Minecraft 1.8.9\"] $ws0 # Fullscreen Application在i3配置文件里面我们可以对常用的程序绑定快捷启动键：1234567891011121314bindsym F10 exec xfce4-appfinderbindsym Print exec xfce4-screenshooter# bindsym $mod+Return exec i3-sensible-terminalbindsym $mod+Return exec pantheon-terminalbindsym $mod+Control+t exec telegram-desktopbindsym $mod+Control+g exec google-chrome-stablebindsym $mod+Control+v exec vivaldibindsym $mod+Control+f exec nemobindsym $mod+Control+c exec codebindsym $mod+Control+n exec nitrogenbindsym $mod+Control+w exec electronic-wechatbindsym $mod+Control+y exec youdao-dict 然后，对于特殊的不适合平铺的窗口，可以直接设置它们为浮动窗口：123456for_window [class=\"Geany\"] floating enable border normalfor_window [class=\"GParted\"] floating enable border normalfor_window [class=\"Nitrogen\"] floating enable border normalfor_window [class=\"(?i)virtualbox\"] floating enable border normalfor_window [class=\"Youdao Dict\"] floating enable border normal# ... PS：可以使用xprop|grep WM_CLASS来查看正在运行窗口的class名称。 i3blocksi3blocks是I3顶部面板的一个可选组件。它使用ini格式的配置文件，支持多种终端脚本，还支持鼠标点击、滚动事件，十分强大。配置文件样本如下：1234567891011121314151617181920command=~/.config/i3/blocks/$BLOCK_NAMEalign=centercolor=#ffffffseparator=trueseparator_block_width=13markup=pango[disk-home]label=command=~/.config/i3/blocks/disk $HOMEinstance=/home/kevininterval=30color=#FFCC80[weather]instance=1808926 # hangzhou's city codeinterval=60color=#90CAF9# ... 主要字段解释： 首先前面无section的parameters属于默认配置项，为每个section的缺省配置。 然后每个section都对应顶栏上面的一个指示器，称为block。 每个block必须显示一定的数据，可以通过command配置项指定获取数据的命令，并使用interval来设置命令执行周期间隔。 instance为可以传递到command脚本中的环境变量。 color和label为颜色和标签，属于修饰性的配置项。 所有可用的block命令可以参考我的配置文件夹：blocks comptoncompton可以给i3带来透明和阴影效果的支持。如果只关心性能而不介意美观与否，你完全可以跳过此节。compton默认是不给顶栏加透明效果的，需要加入如下配置：1234567wintypes:&#123; dock = &#123; opacity = 0.8; &#125;;&#125;; 同时，compton的阴影效果不适用于某些窗口，需要排除它们：12345678shadow-exclude = [ &quot;name = &apos;Notification&apos;&quot;, &quot;name *= &apos;compton&apos;&quot;, &quot;class_g = &apos;Conky&apos;&quot;, &quot;class_g = &apos;Firefox&apos;&quot;, &quot;class_g *= &apos;fcitx&apos;&quot;, &quot;class_g = &apos;Youdao Dict&apos;&quot;]; 易用性建议i3WM只是一个地基，我们可以在这之上搭建一个适合自己的环境。每个人的口味都不一样，所以我简单的罗列一下我个人比较喜欢的应用和配置以供参考。 dmenu: WM下使用最广泛的应用启动器，可以自动根据用户输入的命令进行提示。 rofi: dmenu的替代品 quickswitch.py: 跨工作区窗口快速跳转工具，可以整合到dmenu中。 xfce4-appfinder: xfce4的应用程序列表。能够自动搜索文件系统中的desktop文件，并生成应用列表。非常实用的工具。 pantheon-terminal: elementaryOS的默认终端。小巧，依赖少，支持背景透明、多标签，很完美的终端模拟器。（需要使用dconf-editor来修改设置，位置：/org/pantheon/terminal/settings/） nemo: linuxmint的默认文件管理器，forks自nautilus，但是比nautilus好用得多。（使用之前需要使用dconf-editor设置/org/nemo/desktop/show-desktop-icons为false） nitrogen: 提供简单的图形界面来设置壁纸并在每次开机之后自动恢复。 clipit: 剪贴板支持 lightdm: 轻量级图形登录界面"},{"title":"斐波那契堆之Go实现","permalink":"http://lishangying.github.io/2017/03/01/斐波那契堆之Go实现/","text":"一个比二叉堆更高效的数据结构，但是实现起来非常复杂。本科的时候看《算法导论》的时候曾经研究过，不是很明白。今天终于对它有了一个比较清晰的了解。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242package fibonacciHeapconst MinInt = -int(^uint(0)&gt;&gt;1) - 1type Vertex struct &#123; value int parent *Vertex child *Vertex left *Vertex right *Vertex mark bool degree int&#125;type FibonacciHeap struct &#123; min *Vertex size int&#125;// Insert inserts a node into heap with value vfunc (F *FibonacciHeap) Insert(value int) *Vertex &#123; v := &amp;Vertex&#123;value: value&#125; if F.min == nil &#123; F.min = v &#125; else &#123; F.insertToList(F.min, v) if F.min.value &gt; v.value &#123; F.min = v &#125; &#125; F.size++ return v&#125;func (F *FibonacciHeap) Empty() bool &#123; return F.min == nil&#125;func (F *FibonacciHeap) Minmum() *Vertex &#123; return F.min&#125;func (F *FibonacciHeap) ExtractMin() *Vertex &#123; z := F.min if z == nil &#123; return nil &#125; for z.child != nil &#123; v := F.extractVertex(z.child) F.insertToList(F.min, v) &#125; if z == z.right &#123; //the heap only contains one node F.min = nil &#125; else &#123; F.min = z.right z = F.extractVertex(z) F.consolidate() &#125; F.size-- return z&#125;func (F *FibonacciHeap) Merge(Other *FibonacciHeap) &#123; if F.min == nil &#123; // if current heap is empty F.min = Other.min &#125; else if Other.min != nil &#123; // cut two circle and rearrange them F.min.right.left = Other.min.left Other.min.left.right = F.min.right //reverse F.min.right = Other.min Other.min.left = F.min //reverse if F.min.value &gt; Other.min.value &#123; F.min = Other.min &#125; &#125; Other.min = nil&#125;func (F *FibonacciHeap) DecreaseKey(v *Vertex, value int) bool &#123; if v.value &lt; value &#123; return false // do not increase &#125; if v.value == value &#123; return true &#125; v.value = value parent := v.parent if parent != nil &amp;&amp; v.value &lt; parent.value &#123; v = F.extractVertex(v) F.insertToList(F.min, v) F.cascadingCut(parent) &#125; if v.value &lt; F.min.value &#123; F.min = v &#125; return true&#125;func (F *FibonacciHeap) IncreaseKey(v *Vertex, value int) bool &#123; if v.value &gt; value &#123; return false &#125; if v.value == value &#123; return true &#125; for v.child != nil &#123; F.insertToList(F.min, F.extractVertex(v.child)) &#125; v.value = value parent := v.parent if parent != nil &#123; F.insertToList(F.min, F.extractVertex(v)) F.cascadingCut(parent) &#125; else if F.min == v &#123; for cur := v.right; cur != v; cur = cur.right &#123; if v.value &gt; cur.value &#123; F.min = cur &#125; &#125; &#125; return true&#125;func (F *FibonacciHeap) Modify(v *Vertex, value int) &#123; switch &#123; case v.value &lt; value: F.IncreaseKey(v, value) case v.value &gt; value: F.DecreaseKey(v, value) &#125;&#125;func (F *FibonacciHeap) DeleteVertex(v *Vertex) &#123; F.DecreaseKey(v, MinInt) F.extractVertex(v)&#125;// insertToList inserts v after posfunc (F *FibonacciHeap) insertToList(pos *Vertex, v *Vertex) &#123; if pos == nil &#123; return &#125; pos.right.left = v v.right = pos.right pos.right = v v.left = pos v.parent = pos.parent if pos.parent != nil &#123; pos.parent.degree++ &#125;&#125;func (F *FibonacciHeap) extractVertex(v *Vertex) *Vertex &#123; if v == nil &#123; return nil &#125; if v.parent != nil &#123; if v.right != v &#123; v.parent.child = v.right &#125; else &#123; v.parent.child = nil &#125; v.parent.degree-- v.parent = nil &#125; if v.left != v &#123; v.left.right = v.right v.right.left = v.left v.left = v v.right = v &#125; v.mark = false return v&#125;func (F *FibonacciHeap) cascadingCut(v *Vertex) &#123; parent := v.parent if parent == nil &#123; return &#125; if v.mark == false &#123; v.mark = true &#125; else &#123; // when the parent have lost a child F.extractVertex(v) F.insertToList(F.min, v) F.cascadingCut(parent) &#125;&#125;func (F *FibonacciHeap) consolidate() &#123; if F.min == nil &#123; return &#125; v := F.min degree := v.degree // a record table to help merging vertices with the same degree table := make([]*Vertex, degree+1) for &#123; if len(table) &lt;= degree &#123; // extend table size table = append(table, make([]*Vertex, degree-len(table)+1)...) &#125; if table[degree] == v &#123; break &#125; if table[degree] == nil &#123; //currently ,there is no vertices having the same degree of v table[degree] = v v = v.right &#125; else &#123; // make sure v is the minimal vertex if table[degree].value &lt; v.value &#123; table[degree], v = v, table[degree] &#125; // merge table[degree] to v as his child // make v become root table[degree] = F.extractVertex(table[degree]) if v.child == nil &#123; v.child = table[degree] table[degree].parent = v v.degree++ &#125; else &#123; //v.degree has been increased in this function F.insertToList(v.child, table[degree]) &#125; table[degree] = nil &#125; degree = v.degree &#125; // find the min F.min = nil for _, v := range table &#123; if v == nil &#123; continue &#125; if F.min == nil &#123; F.min = v &#125; else if v.value &lt; F.min.value &#123; F.min = v &#125; &#125;&#125; 参考 https://www.roading.org/algorithm/introductiontoalgorithm/斐波那契堆fibonacci-heaps.html http://www.cnblogs.com/skywang12345/p/3659060.html"},{"title":"网易云音乐新API简述","permalink":"http://lishangying.github.io/2017/02/08/netease-music-api/","text":"新API采用了略微修改过的AES和RSA加密，主要用在登陆接口上，对新API进行简单的分析。 Url估计会抓包的人都知道，Url中的api便成了weapi。比如手机登录：原来是：http://music.163.com/api/login/cellphone/现在是：http://music.163.com/weapi/login/cellphone/ 加密算法核心过程如下：1234567 aesRsaEncrypt = function (text, pubKey, modulus, nonce) &#123; const secKey = createSecretKey(16); // 随机生成16位加密密钥 return &#123; params: aesEncrypt(aesEncrypt(text, nonce), secKey), encSecKey: rsaEncrypt(secKey, pubKey, modulus) &#125;&#125; 123456&#123; Text : \"JSON.stringify(&#123;phone:xxx,password:\"md5 hashed Data\",rememberLogin:\"true\"&#125;)\" //需要加密的post body pubKey : \"010001\" nonce : \"0CoJUm6Qyw8W8jud\" modulus : \"00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7\"&#125; 一些细节 AES加密的具体算法为:AES-128-CBC，输出格式为base64。 AES加密时需要指定iv：0102030405060708 RSA加密输出为Hex格式，公钥是{N:modulus,e:pubKey} 我的Javascript实现：Crypto RSA算法的JS实现方法参考：http://www.cnblogs.com/kxdhm/archive/2012/02/02/2336103.html"},{"title":"Pandorabox之透明代理","permalink":"http://lishangying.github.io/2017/02/07/Pandorabox-transparent-proxy/","text":"先修改Lan接口，避免在无线中继的时候发生本地Lan接口与wwan接口发生冲突导致无法登陆路由器。 网络 -&gt; Lan -&gt; IPv4地址， 设置为 192.168.33.1更改之后需要重新连接一下网络。 透明代理使用shadowsocks-libev和ChinDNS实现。使用ssh登陆路由器，安装所需软件。 123ssh root@192.168.33.1opkg updateopkg install shadowsocks-libev luci-app-shadowsocks ChinaDNS luci-app-chinadns --force-checksum 这个版本的软件源有点问题，所以直接opkg install基本上都过不了sha256sum检测，所以需要加上--force-checksum参数强制忽略。两个luci界面都有zh-cn汉化包，为了节省路由器空间，就不装了。默认的chnroute表很老了，需要更新： 1234mv /etc/chnroute.txt /etc/chnroute.txt.bakwget -O- 'http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest' | awk -F\\| '/CN\\|ipv4/ &#123; printf(\"%s/%d\\n\", $4, 32-log($5)/log(2)) &#125;' &gt; /etc/chnroute.txt# 如果没有问题rm -rf /etc/chnroute.txt.bak 然后我们需要对其进行启用。 shadowsocks需要启动ss-redir来实现透明代理和ss-tunnel来实现UDP转发保证国外DNS查询不被污染。下面是具体需要注意的配置。 SS-tunnel1234&#123; \"UDP Local Port\": 1153, \"Forwarding Tunnel\": 8.8.8.8:53&#125; ChinaDNS123456&#123; \"Enable DNS compression pointer\": true, \"Local Port\": 1053, //不能与ss-tunnel冲突 \"CHNRoute File\": \"/etc/chnroute.txt\", \"Upstream Servers\": \"223.5.5.5,127.0.0.1:1153\" //第一个是国内阿里DNS服务器，第二个是进过ss-tunnel转发后的Google DNS服务器&#125; DHCP/DNS最后需要在网络-&gt;DHCP/DNS-&gt;服务器设置修改默认的DNS配置 1234&#123; \"本地服务器\": \"127.0.0.1#1053\", //ChinaDNS处理后的DNS服务器，可以根据ip分流。 \"忽略解析文件\": true&#125; 总的来说，GoogleDNS(8.8.8.8:53)首先进过ss-tunnel转发到本地的127.0.0.1:1153上，然后通过ChinaDNS与国内DNS服务器融合成新的127.0.0.1:1053 实现了国内外分流。 Update由于实用过程中还是经常不稳定，决定采用DNS-Forwarder方案。然而，官方并没有我的小米Mini路由架构的二进制包，只能自己动手丰衣足食了。 OpenWrt SDK首先明确小米路由器Mini的架构是ramips/mt7620a而现在运行的Pandorabox 16.10基于Openwrt Barrier Breaker。 依赖1sudo apt-get install git-core build-essential libssl-dev libncurses5-dev unzip gawk zlib1g-dev subversion mercurial 下载&amp;编译12345curl https://downloads.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/OpenWrt-SDK-ramips-for-linux-x86_64-gcc-4.8-linaro_uClibc-0.9.33.2.tar.bz2 | tar -xjf cd OpenWrt-SDK-*git clone https://github.com/aa65535/openwrt-dns-forwarder.git package/dns-forwarder # 获取Makefilemake menuconfig # 选择要编译的包： Network -&gt; dns-forwardermake package/dns-forwarder/compile V=99 然而，愿景很好，但是在我的Deepin上make menuconfig这步就出错，想想barrier_breaker也是很久之前的版本了，出错大概是ldxxxx，感觉应该是GCC版本不兼容的缘故，然而Deepin上GCC只有6.2.0没有官方要求的4.8，怎么办呢？当时暂时想到下面几条解决方案 在自己电脑上重新编译一份GCC4.8： 太麻烦，而且还不能保证一定能成功。 用虚拟机装老版本的Ubuntu： 太浪费时间了，本身电脑BIOS就没有开启虚拟化支持。 docker? 不错可以试一下。 docker运行老版本ubuntu镜像不用太简单，一条命令搞定：1sudo docker run -t -i ubuntu:12.04.5 /bin/bash 然而docker版本的ubuntu太过于精简了,需要配置一下：123456# 安装缺失依赖apt-get install ccache curl# openwrt-sdk 编译不能以root用户进行，需要新建一个普通用户useradd kevinsu kevin# 继续之前的编译步骤 好了，终于编译成功了，然而还是高兴的太早，仍然报错：1* pkg_hash_fetch_best_installation_candidate: Packages for helloworld found, but incompatible with the architectures configured 还是求助于Google，然后发现了这篇博客：小米路由器mini折腾之配置opkg篇，于是我的路由器就成砖了。hhhhhhhhh 未完待续。。。。。。。。。。。。。。 2017-8-15 update拿去店里救砖成功。刷了不死breed，但是现在反而没有什么折腾劲了。"},{"title":"Tech Daily@1-20","permalink":"http://lishangying.github.io/2017/01/20/Xiaomi-Openwrt-&&-Git/","text":"小米路由器mini（Xiaomi mini R1CM）刷Openwrt 12scp /path/to/PandoraBox-xxxx.bin root@192.168.1.1:/tmp/PandoraBox.binmtd -r write /tmp/PandoraBox.bin firmware 從爬文中得知，小米路由器Mini 官方韌體是雙系統，由於 ROM 有16MB，官方韌體都小於8MB，所以會有一份備援系統（8MB+8MB），因此如果刷了大於 8MB 的第三方韌體的話，會覆蓋掉第二個分區的系統，導致未來刷回官方韌體時會有掉 SN 的問題，而且再也無法刷入 SSH，從此以後就只能乖乖用官方韌體，再也不能玩刷機，目前新版的 PandoraBox 韌體大約都在 10MB 左右，所以刷機還真要有點決心，除非完整備份小米路由器Mini 中所有分區的資料，才能在日後完整刷回官方韌體，當然，如果已經完全放棄官方韌體的話，這些問題都是不用考慮的。from - http://blog.icece.tw/MiWiFi-Mini-Flash-uboot Disable middle button of mouseExecute those commands: 12345678910xinput list⎡ Virtual core pointer id=2 [master pointer (3)]⎜ ↳ Virtual core XTEST pointer id=4 [slave pointer (2)]⎜ ↳ MI Dongle MI Wireless Mouse id=11 [slave pointer (2)]⎜ ↳ MI Dongle MI Wireless Mouse id=12 [slave pointer (2)]⎜ ↳ DLL0704:01 06CB:76AE Touchpad id=14 [slave pointer (2)]⎜ ↳ PS/2 Synaptics TouchPad id=17 [slave pointer (2)]⎜ ↳ MiMouse id=21 [slave pointer (2)]xinput set-button-map 21 1 0 3 ExplainationThe first number is the id of the pointer (you’ll often only have one, in this case there were two, 9 and 10). The next numbers are what you do with the first, second, and third (ie, left, middle, right) mouse buttons. The “1 0 3” tells it that the left button should do a left click (action 1), the middle button should do nothing, and the right button should do a right click (action 3). If you want to make the middle button also do a left click you could use “1 1 3”. If you wanted to switch the right and left actions you could use “3 0 1”. See https://wiki.ubuntu.com/X/Config/Input for more info. git merge1git merge &lt;特性分支&gt; # 将特性分支合并到当前分支中，形成一个新的提交 git rebase12git rebase &lt;主分支&gt; [&lt;特性分支&gt;] # 在主分支的基础上重演特性分支的修改，修改特性分支的历史（变基）git rebase --onto master server client # 取出client分支，将client和server的共同祖先之后的变化在master上重演一遍 git-scm reference Vscode Go设置GOPATH（为~/go-workspace） 123456cat &gt; ~/.zshrc &lt;&lt;\"EOF\"# Set Go Pathexport GOPATH=$HOME/go-workspace# Customize to your needs...export PATH=$PATH:$GOPATHEOF 在vscode中设置：打开用户设置，设置go.gopath 安装插件：Go 安装依赖：(事先设置好http_proxy和https_proxy)1234567go get -u -v github.com/nsf/gocodego get -u -v github.com/rogpeppe/godefgo get -u -v github.com/golang/lint/golintgo get -u -v github.com/lukehoban/go-find-referencesgo get -u -v github.com/lukehoban/go-outlinego get -u -v sourcegraph.com/sqs/goreturnsgo get -u -v golang.org/x/tools/cmd/gorename"},{"title":"Deepin初始化","permalink":"http://lishangying.github.io/2017/01/12/Kubernetes-&-Deepin-Settings@1-12/","text":"Infinality and Harfbuzz会发生冲突，这是今天Archlinux无法启动输入法界面的元凶。重新安装freetype2\\fontconfig\\cairo以替换infinality-bundle。 添加PPA出现GPG问题问题：123456gpg: keybox '/tmp/tmpyiw6jvck/pubring.gpg' createdgpg: /tmp/tmpyiw6jvck/trustdb.gpg：建立了信任度数据库gpg: 密钥 531EE72F4C9D234C：公钥“Launchpad webupd8”已导入gpg: 合计被处理的数量：1gpg: 已导入：1gpg: 找不到有效的 OpenPGP 数据。 可能原因：keyserver.ubuntu.com使用非标准的11371端口，而一般公司的防火墙都屏蔽掉了该端口，而允许标准的80端口。 解决方法：123sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 531EE72F4C9D234C# 或者sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E985B27B Telnet需要安装server的 1234567# ubuntusudo apt install telnetdsudo systemctl start inetdsudo systemctl enable inetd# archsudo systemctl start telnet.socketsudo systemctl enable telnet.socket 使用telnet测试端口是否打开： 1telnet localhost 33171 Github Online File Tree View PluginOctotree"},{"title":"Basic Algorithms in Go","permalink":"http://lishangying.github.io/2017/01/10/Basic Algorithms in Go/","text":"最近学Go，感觉挺不错的。闲来无事用它写了几种常用的基础算法。 快排思想很简单，实现起来为了方便每次以left作为基准，也可以使用BFS来节省递归栈：123456789101112131415161718// QuickSort returns a sorted slicefunc QuickSort(arr []int) &#123; if len(arr) &lt;= 1 &#123; return &#125; left, right := 0, len(arr)-1 for left &lt; right &#123; if arr[left+1] &gt; arr[left] &#123; arr[left+1], arr[right] = arr[right], arr[left+1] right-- &#125; else &#123; arr[left+1], arr[left] = arr[left], arr[left+1] left++ &#125; &#125; QuickSort(arr[:left]) QuickSort(arr[left+1:])&#125; 最短路最短路核心思想就是Relax操作。效率高的单源最短路有下面两种算法： Dijikstra，不能处理负权路,但是时间复杂度比较稳定. SPFA是我比较喜欢的一种算法，可以判断负权路。正常情况的时间复杂度为O(kE) 其中k&lt;&lt;V；最好的情况即一次BFS，时间复杂度为 O(E)，然而对于某些精心构造的图，复杂度可以达到Bellman-ford级别：O(VE)。下面构图使用的是邻接表（适用于稀疏图），也可以用邻接矩阵（适用于稠密图）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// adjacency list definitiontype edge struct &#123; v, w int next *edge&#125;type Graph struct &#123; head []*edge n, m int&#125;func (G *Graph) init(n, m int) &#123; G.n, G.m = n, m G.head = make([]*edge, n)&#125;func (G *Graph) add(u, v, w int) &#123; G.head[u] = &amp;edge&#123; v: v, w: w, next: G.head[u], &#125;&#125;// SPFA returns the shortest path from begin to end// begin: the begin node number// end: the end node numberfunc (G *Graph) SPFA(begin, end int) int &#123; visit := make([]bool, G.n) dist := make([]int, G.n) Q := make([]int, 0) for i := 0; i &lt; G.n; i++ &#123; dist[i] = -1 &#125; dist[begin] = 0 Q = append(Q, begin) visit[begin] = true for len(Q) != 0 &#123; u := Q[0] for e := G.head[u]; e != nil; e = e.next &#123; if dist[e.v] == -1 || dist[e.v] &gt; dist[u]+e.w &#123; dist[e.v] = dist[u] + e.w if !visit[e.v] &#123; Q = append(Q, e.v) visit[e.v] = true &#125; &#125; &#125; // pop the front node Q = Q[1:] visit[u] = false &#125; return dist[end]&#125; KMP字符串匹配经典算法。关键在于维护一个这样的关系：x[i-next[i]...i-1]=x[0...next[i]-1]123456789101112131415161718192021222324252627282930313233343536373839404142type Kmp struct &#123; pattern string next []int&#125;// x[i-p...i-1]=x[0...p-1]func (K *Kmp) getNext() &#123; K.next = make([]int, len(K.pattern)+1) K.next[0] = -1 i := 0 p := -1 for i &lt; len(K.pattern) &#123; for p != -1 &amp;&amp; K.pattern[i] != K.pattern[p] &#123; p = K.next[p] &#125; p++ i++ if i &lt; len(K.pattern) &amp;&amp; K.pattern[i] == K.pattern[p] &#123; K.next[i] = K.next[p] &#125; else &#123; K.next[i] = p &#125; &#125;&#125;func (K *Kmp) match(matcher string) int &#123; ret := 0 p := 0 i := 0 for i &lt; len(matcher) &#123; for p != -1 &amp;&amp; matcher[i] != K.pattern[p] &#123; p = K.next[p] &#125; i++ p++ if p &gt;= len(K.pattern) &#123; ret++ p = K.next[p] &#125; &#125; return ret&#125; To Be Continue…"},{"title":"Kubernetes部署","permalink":"http://lishangying.github.io/2017/01/04/Kubernetes部署@1-5/","text":"MEOW安装 12curl -L git.io/meowproxy | bash# 建议安装目录 /usr/bin/ 复制自己的配置文件 12345# in local computerxclip -sel clipboard &lt; ~/.meow/rc# in CentOS servermv ~/.meow/rc ~/.meow/rc.bakxclip -o -sel clipboard &gt; ~/.meow/rc 运行 1MEOW Hostname执行下面脚本。不要执行多次 如果出错则手动修改 123456sed -i s/localhost\\.localdomain/NAME/g /etc/hosts /etc/hostname hostname=\"10-10-103-144.node\"rm -rf /etc/hostnameecho $hostname &gt; /etc/hostname sed -i \"s/\\slocalhost\\s/ localhost $hostname /g\" /etc/hostssysctl kernel.hostname=$hostname Screenfetch1curl -L https://raw.githubusercontent.com/KittyKatt/screenFetch/master/screenfetch-dev -o /usr/bin/screenfetch AWK简述123456awk -v var1=xxx BEGIN&#123;[something]&#125; [ifstatments or regex]&#123;something match the condition&#125;&#123;[always run]&#125;END&#123;[something]&#125;# 支持if else,for,i++# 支持数组（支持for in遍历，但是顺序会打乱）# 最好的批量初始化的方式： arr[\"\"]=0 # 批量设为0str=\"a b c\"; split(str,arr[,\" \"]);# [\"a\",\"b\",\"c\"] 加Kubernetes源12345678cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=http://yum.kubernetes.io/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0EOF 安装Kubernetes1yum install docker kubelet kubeadm kubectl kubernetes-cni 启动进程&amp;关闭防火墙123456systemctl start dockersystemctl start kubeletsystemctl enable docker systemctl enable kubelet systemctl stop firewalldsystemctl disable firewalld Tear Down(当kubeadm init失败时执行)1kubeadm reset &amp;&amp; systemctl start kubelet Pull Docker Images此方式十分艰难。后面可以通过代理直接安装。见Tech Log@1-12 12345678910111213141516171819202122#! /bin/bashdeclare -a images=( 'dnsmasq-metrics-amd64:1.0' 'etcd-amd64:3.0.14-kubeadm' 'exechealthz-amd64:v1.2.0' 'kube-apiserver-amd64:v1.5.1' 'kube-controller-manager-amd64:v1.5.1' 'kube-discovery-amd64:1.0' 'kube-dnsmasq-amd64:1.4' 'kube-proxy-amd64:v1.5.1' 'kube-scheduler-amd64:v1.5.1' 'kubedns-amd64:1.9' 'kubernetes-dashboard-amd64:v1.5.0' 'pause-amd64:3.0'# 'weave-kube:1.8.1'# 'weave-npc:1.8.1')for imageName in $&#123;images[@]&#125;; do docker pull stkevintan/$imageName docker tag stkevintan/$imageName gcr.io/google_containers/$imageName docker rmi stkevintan/$imageNamedone 123xclip -o -sel clipboard &gt; pull_dockerchmod +x pull_docker./pull_docker 初始化（Master）12345678910111213141516171819202122232425262728293031323334353637# 首先需要使用@17-1-3的脚本设置代理。# Del environment# Set curl# Set kube env# Set docker# 在/etc/default/docker的DOCKER_OPTS中加入:--insecure-registry gcr.ioroot@10-10-103-144 ~ $ kubeadm init[kubeadm] WARNING: kubeadm is in alpha, please do not use it for production clusters.[preflight] Running pre-flight checks[init] Using Kubernetes version: v1.5.2[tokens] Generated token: \"c30875.954dc1dda4d0184b\"[certificates] Generated Certificate Authority key and certificate.[certificates] Generated API Server key and certificate[certificates] Generated Service Account signing keys[certificates] Created keys and certificates in \"/etc/kubernetes/pki\"[kubeconfig] Wrote KubeConfig file to disk: \"/etc/kubernetes/kubelet.conf\"[kubeconfig] Wrote KubeConfig file to disk: \"/etc/kubernetes/admin.conf\"[apiclient] Created API client, waiting for the control plane to become ready[apiclient] All control plane components are healthy after 16.391731 seconds[apiclient] Waiting for at least one node to register and become ready[apiclient] First node is ready after 0.509209 seconds[apiclient] Creating a test deployment[apiclient] Test deployment succeeded[token-discovery] Created the kube-discovery deployment, waiting for it to become ready[token-discovery] kube-discovery is ready after 3.505676 seconds[addons] Created essential addon: kube-proxy[addons] Created essential addon: kube-dnsYour Kubernetes master has initialized successfully!You should now deploy a pod network to the cluster.Run \"kubectl apply -f [podnetwork].yaml\" with one of the options listed at: http://kubernetes.io/docs/admin/addons/You can now join any number of machines by running the following on each node:kubeadm join --token=c30875.954dc1dda4d0184b 10.10.103.144 初始化（Node）1234567891011# 需要在子节点上安装kubelet kubectl kubernetes-cni kubeadm# 需要使用@17-1-3的脚本设置代理。# Del environment# Set curl# Set kube env# Set docker# 在/etc/default/docker的DOCKER_OPTS中加入:--insecure-registry gcr.iosystemctl enable kubeletsystemctl start kubeletkubeadm join --token=ace10c.73fcdec44f7a4045 10.10.103.146 可以在master节点上看到该子节点： 1234root@master ~ $ kubectl get nodeNAME STATUS AGEmaster Ready,master 5dnode1 Ready 1m Weave Network12345678910# download config filecurl -L https://git.io/weave-kube -o weave-kube.yaml# pull docker imagedocker pull stkevintan/weave-kube:1.8.1docker tag stkevintan/weave-kube:1.8.1 weaveworks/weave-kube:1.8.1docker rmi stkevintan/weave-kube:1.8.1# createkubectl create -f weave-kube.yaml# 或者kubectl create -f https://git.io/weave-kube 可以看到结果： 12345678910111213root@master ~ $ kubectl get pod --namespace=kube-systemNAME READY STATUS RESTARTS AGEdummy-2088944543-bv5gj 1/1 Running 0 5detcd-master 1/1 Running 0 5dkube-apiserver-master 1/1 Running 27 5dkube-controller-manager-master 1/1 Running 0 5dkube-discovery-1769846148-xbm2h 1/1 Running 0 5dkube-dns-2924299975-phn03 0/4 ContainerCreating 0 5dkube-proxy-081gt 1/1 Running 0 5dkube-proxy-qc40l 1/1 Running 0 1hkube-scheduler-master 1/1 Running 1 5dweave-net-4wvkm 0/2 ContainerCreating 0 30sweave-net-l7dh0 0/2 ContainerCreating 0 30s Dashboard12345678curl -L https://rawgit.com/kubernetes/dashboard/master/src/deploy/kubernetes-dashboard.yaml -o kubernetes-dashboard.yamlsed -i 's/v1.5.1/v1.5.0/g' kubernetes-dashboard.yaml # 注意此时gcr上面并没有v1.5.1sed -i 's/Alaways/IfNotPresent/g' kubernetes-dashboard.yamlkubectl create -f kubernetes-dashboard.yamlkubectl create -f https://rawgit.com/kubernetes/dashboard/master/src/deploy/kubernetes-dashboard.yaml Delete Pod1kubectl delete -f xxx.yaml"},{"title":"Centos初始化2","permalink":"http://lishangying.github.io/2017/01/04/CentOS2@1-4/","text":"proxychains-ng1234567git clone https://github.com/rofl0r/proxychains-ngcd proxychains-ng ./configure --prefix=/usr --sysconfdir=/etc makemake installmake install-config # 生成配置文件echo 'http 10.100.100.136 4411' &gt;&gt; /etc/proxychains.conf # 输入代理设置 TMUXCentOS的版本太老，手动编译最新版本 123456yum install ncurses-devel libevent-develcurl -L https://github.com/tmux/tmux/releases/download/2.3/tmux-2.3.tar.gz | tar xzcd tmux-2.3./configuremakemake install 如果出现protocol version mismatch错误，说明现在tmux正在运行，手动结束掉即可。 1kill -9 `pidof tmux` theme123456git clone https://github.com/gpakosz/.tmux.gitln -s -f .tmux/.tmux.confcp .tmux/.tmux.conf.local .vim .tmux.conf.local #编辑配置文件# 去掉status left/right sections separators后面几行的注释（终端字体需要支持Powerline）# 启用 force vi mode shortcuts1234567891011121314151617181920212223242526272829303132333435363738394041424344# Session:new[-s name] # new session:kill-session[-t name] # kill session:ls # list sessionsC-c # new sessions # list and select sessions$ # name session==============================================# Windowc # create windoww # list windowsn # next windowp # previous windowf # find window, # name window&amp; # kill window===============================================# Panes% #vertical split\" # horizontal splito # swap panesq # show pane numbersx # kill pane+ # 最大化pane，再按一次还原- # restore pane from window⍽ # space - toggle between layoutsq # (Show pane numbers, when the numbers show up type the key to goto that pane)&#123; # (Move the current pane left)&#125; # (Move the current pane right)z # toggle pane zoom方向键 # select the sibling paneC-方向键 # resize current pane================================================# Miscd # detacht # big clock? # list shortcuts: # prompt Tmux Plugin Manager &amp;&amp; tmux-yanktmux-yank可以将tmux的paste-buffer中的文字拷贝到系统剪贴板 123yumi xclip # 安装依赖git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm vim .tmux.conf # 在最后添加下面几行，注意不是 .tmux.conf.local!!! 123456# List of pluginsset -g @plugin 'tmux-plugins/tpm'set -g @plugin 'tmux-plugins/tmux-yank'# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)run '~/.tmux/plugins/tpm/tpm' 然后，重新加载tmux，按 + I 安装tmux-yank插件 然后，并不能奏效，因为xclip需要有X服务。然而ssh客户端Centos只是纯命令行。需要开启X11Forwarding X11Forwarding 在远程Centos中的/etc/ssh/ssh_config文件中，添加X11Forwarding yes 在远程Centos中安装认证软件：yumi xorg-x11-xauth 在本地ssh连接命令添加-Y参数 启用x11转发之后就可以在Centos中启动x11程序了，可以安装轻量级的xfce4-terminal方便操作。 Prezto123456789101112131415161718 git clone --recursive https://github.com/sorin-ionescu/prezto.git \"$&#123;ZDOTDIR:-$HOME&#125;/.zprezto\"rm -rf .zshrc .zpreztorc .zlogin .zlogout .zprofile .zshenv .zhistory .zcompdumpsetopt EXTENDED_GLOBfor rcfile in \"$&#123;ZDOTDIR:-$HOME&#125;\"/.zprezto/runcoms/^README.md(.N); do ln -s \"$rcfile\" \"$&#123;ZDOTDIR:-$HOME&#125;/.$&#123;rcfile:t&#125;\"done# 主题列表prompt -l# 预览主题prompt -p NAME# 做个备份mv .zpreztorc .zpreztorc.tmp# 添加常用插件(不要第二次运行，而是手动修改.zpreztorc文件)awk -v s=\"syntax-highlighting git command-not-found yum history-substring-search autosuggestions\" \\'BEGIN&#123;n=split(s,m)&#125;/'\\''utility'\\''\\s+\\\\/&#123;for(i=1;i&lt;=n;i++)printf(\" '\\''%s'\\'' \\\\\\n\",m[i])&#125;&#123;print&#125;' .zpreztorc.tmp &gt; .zpreztorc# 修改默认主题（推荐 skwp）sed -i \"s/\\(zstyle.*theme\\s\\).*/\\1'skwp'/\" .zpreztorc Yum Aliases yumc removes package(s) and leaves. yumi installs package(s). yumh displays history. yuml lists packages. yumL lists installed packages. yumq displays package information. yumr removes package(s). yums searches for a package. yumu updates packages. yumU upgrades packages. spf13 Vim1curl https://j.mp/spf13-vim3 -L &gt; spf13-vim.sh &amp;&amp; sh spf13-vim.sh"},{"title":"Centos初始化","permalink":"http://lishangying.github.io/2017/01/03/CentOS1@1-3/","text":"换源备份1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 写入国内源(centos 7)ustc： https://lug.ustc.edu.cn/wiki/mirrors/help/centos 163： 1234567891011121314151617181920212223242526272829303132333435363738394041# CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client. You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead.##[base]name=CentOS-$releasever - Base - 163.com#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=osbaseurl=http://mirrors.163.com/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7#released updates[updates]name=CentOS-$releasever - Updates - 163.com#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updatesbaseurl=http://mirrors.163.com/centos/$releasever/updates/$basearch/gpgcheck=1gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7#additional packages that may be useful[extras]name=CentOS-$releasever - Extras - 163.com#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extrasbaseurl=http://mirrors.163.com/centos/$releasever/extras/$basearch/gpgcheck=1gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus - 163.combaseurl=http://mirrors.163.com/centos/$releasever/centosplus/$basearch/gpgcheck=1enabled=0gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7 更新12yum clean allyum makecache 设置代理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#! /bin/bash# Author: Kevin Tan# Update-Date: 2017-1-14URL=$1ACTION=('\\nSet' '\\nDel')mode=1if [ -z $URL ]; then echo '[Warning]: URL parameter is empty, default action change to remove' mode=2fiset_proxy()&#123; file=$1;prefix=$2;value=\"$2=$3\"; echo \"Set \\\"$value\\\" to \\\"$file\\\"\" if [ -e \"$file\" ]; then if grep -q \"^\\s*$prefix\" \"$file\"; then sed -i \"s#^\\s*$prefix=.*#$value#g\" $file else echo $value &gt;&gt; $file fi fi&#125;del_proxy()&#123; file=$1;prefix=$2 echo \"Del \\\"$prefix\\\" from \\\"$file\\\"\" if [ -e \"$file\" ]; then sed -i \"/^\\s*$prefix=.*/d\" $file fi eval $prefix=\"\"&#125;SHELL_NAME=`ps -p $$ | awk 'NR==2 &#123;print $4&#125;'`echo 'Current shell is '$SHELL_NAMEsource_file()&#123; ## bash if [ \"$SHELL_NAME\" = \"bash\" ]; then source $HOME'/.bashrc' fi ## zsh if [ \"$SHELL_NAME\" = \"zsh\" ]; then source $HOME'/.zshrc' fi&#125;# yumecho -n $&#123;ACTION[$mode]&#125;' the yum? (y/n/r) ';read Fif [ $F = 'y' ] &amp;&amp; [ $mode -eq 1 ]; then set_proxy '/etc/yum.conf' 'proxy' $URLelif [ $F = 'r' ] || ([ $F = 'y' ] &amp;&amp; [ $mode -eq 2 ]); then del_proxy '/etc/yum.conf' 'proxy'fi# environmentecho -n $&#123;ACTION[$mode]&#125;' the environment var?(y/n/r) ';read Fshell_names=(zsh bash)if [ $F = 'y' ] &amp;&amp; [ $mode -eq 1 ]; then for name in $&#123;shell_names[@]&#125;; do set_proxy \"$HOME/.$&#123;name&#125;rc\" \"export http_proxy\" $URL set_proxy \"$HOME/.$&#123;name&#125;rc\" \"export https_proxy\" $URL done source_fileelif [ $F = 'r' ] || ([ $F = 'y' ] &amp;&amp; [ $mode -eq 2 ]); then for name in $&#123;shell_names[@]&#125;; do del_proxy \"$HOME/.$&#123;name&#125;rc\" \"export http_proxy\" del_proxy \"$HOME/.$&#123;name&#125;rc\" \"export https_proxy\" donefi#curlecho -n $&#123;ACTION[$mode]&#125;' the curl proxy alias?(y/n/r) ';read Fshell_names=(zsh bash)if [ $F = 'y' ] &amp;&amp; [ $mode -eq 1 ]; then for name in $&#123;shell_names[@]&#125;; do set_proxy \"$HOME/.$&#123;name&#125;rc\" \"alias curl\" \"\\\"curl -x $URL\\\"\" done source_fileelif [ $F = 'r' ] || ([ $F = 'y' ] &amp;&amp; [ $mode -eq 2 ]); then for name in $&#123;shell_names[@]&#125;; do del_proxy \"$HOME/.$&#123;name&#125;rc\" \"alias curl\" unalias curl donefi# kubernetesecho -n $&#123;ACTION[$mode]&#125;' kube environment var?(y/n/r) ';read Fif [ $F = 'y' ] &amp;&amp; [ $mode -eq 1 ]; then for name in $&#123;shell_names[@]&#125;; do set_proxy \"$HOME/.$&#123;name&#125;rc\" \"export KUBERNETES_HTTP_PROXY\" $URL set_proxy \"$HOME/.$&#123;name&#125;rc\" \"export KUBERNETES_HTTPS_PROXY\" $URL set_proxy \"$HOME/.$&#123;name&#125;rc\" \"export KUBE_BUILD_HTTPS_PROXY\" $URL set_proxy \"$HOME/.$&#123;name&#125;rc\" \"export KUBE_BUILD_HTTP_PROXY\" $URL done source_fileelif [ $F = 'r' ] || ([ $F = 'y' ] &amp;&amp; [ $mode -eq 2 ]); then for name in $&#123;shell_names[@]&#125;; do del_proxy \"$HOME/.$&#123;name&#125;rc\" \"export KUBERNETES_HTTP_PROXY\" del_proxy \"$HOME/.$&#123;name&#125;rc\" \"export KUBERNETES_HTTPS_PROXY\" del_proxy \"$HOME/.$&#123;name&#125;rc\" \"export KUBE_BUILD_HTTPS_PROXY\" del_proxy \"$HOME/.$&#123;name&#125;rc\" \"export KUBE_BUILD_HTTP_PROXY\" donefi# dockerecho -n $&#123;ACTION[$mode]&#125;' the docker?(y/n/r) ';read Fif type \"docker\" &amp;&gt;/dev/null &amp;&amp; ([ $F = 'y' ] || [ $F = 'r' ]); then DOCKER_CONF_DIR='/etc/systemd/system/docker.service.d' DOCKER_CONF=$DOCKER_CONF_DIR'/http-proxy.conf' REGISTRY=\"87129800.m.daodocker.io\" sudo mkdir -p \"$DOCKER_CONF_DIR\" sudo rm -rf $DOCKER_CONF if [ $F = 'y' ] &amp;&amp; [ $mode -eq 1 ]; then printf \"[Service]\\nEnvironment=\" | sudo tee $DOCKER_CONF &gt; /dev/null printf \"\\\"HTTP_PROXY=%s\\\" \" $URL | sudo tee -a $DOCKER_CONF &gt; /dev/null printf \"\\\"HTTPS_PROXY=%s\\\" \" $URL | sudo tee -a $DOCKER_CONF &gt; /dev/null printf \"\\\"NO_PROXY=localhost,%s\\\"\" $REGISTRY | sudo tee -a $DOCKER_CONF &gt; /dev/null fi sudo systemctl daemon-reload sudo systemctl restart docker echo \"Daemon reloaded\" systemctl show --property=Environment docker fi 将上面脚本保持为setproxy，然后执行,注意，如果当前环境下已经有了http_proxy等变量。则需要我们手动reset 12chmod u+x setproxysource setproxy http://10.100.100.136:4411 基础建设git &amp;&amp; gcc1yum install git gcc pip1curl \"https://bootstrap.pypa.io/get-pip.py\" | python EPEL 1rpm -ivh http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ZSH安装 &amp; 激活12yum install zshchsh -s /bin/zsh"},{"title":"pygobject-tutorial-1","permalink":"http://lishangying.github.io/2016/11/08/pygobject-tutorial-1/","text":"基础这章将会介绍GTK+比较重要的几个方面 主循环和信号就像大部分GUI库一样，GTK+使用了一种事件驱动的编程模型。当用户什么都没做，GTK+让主循环处于就绪状态并等待用户的输入。如果用户做了一些动作，比如鼠标事件，主循环就会被唤醒，然后将这个事件传递给GTK+程序。当部件收到一个事件，它们将会频繁的发出一个或者更多的信号，这些信号将会调用与之相绑定的函数。这样的函数通常被称作回调函数。当回调函数被调用时，你就可以进行一些操作了。比如说，你可能要弹出一个文件选择对话框当一个“打开”按钮被点击的之后。当回调函数执行完毕之后，GTK+将会返回到主循环然后等待用户再一次输入。 一个典型的例子：1handler_id = widget.connect('event',callback,data) 首先，widget是一个之前以及创建好的widget实例。接着，我们来看看事件，每个部件都有它自己的事件。举个例子，如果你有一个按钮，那么你往往希望绑定它的点击事件。这样只要按钮被点击，你就能收到它所触发的信号。然后，参数callback代表者需要调用的回调函数的名字，它包含者将要运行的代码，当特定的信号产生之后。最后，data参数包含着任意你想要传递的数据，这个参数是一个可选参数，如果不需要可以省略。该方法返回一个数值，标志着这个signal-callback对。当这个函数再也不会"},{"title":"JS DOM API分析","permalink":"http://lishangying.github.io/2016/11/02/dom-compatibility-note/","text":"Element.classList返回DOMTokenList,IE version&gt;=10不完全支持。 不支持classList.contains的第二个参数(force) add和remove方法不支持多参数 SVG,MathML结点没有classList属性 Node种类Node.nodeName Interface nodeName Comment #comment Document #document DocumentFragment #document-fragment Node的树遍历Node树遍历普遍要考虑空白文字结点。(whitespace textNode)。 Node.childNodes返回一个NodeList，表示该结点的所有子结点，包括文字结点和注释，该NodeList里面全部是object，并没有string。可以使用ParentNode.children来获得所有纯Element结点集合。 Node.firstChild返回结点的第一个子结点。可能是whitespace textNode。可以使用Element.firstElementChild来获得Element结点。 Node.lastChild返回结点的最后一个子结点。可能是whitespace textNode。可以使用Element.lastElementChild来获得Element结点。 Node.nextSibling返回下一个兄弟结点，可能是whitespace textNode。可以使用Element.nextElementSibling获得Element结点。 Node.previousSibling返回前一个兄弟结点，可能whitespace textNode。可以使用Element.previousElementSibling获得Element结点。 Node.innerText是一个非标准的属性，返回当前结点包括其子结点的所有文字。可以使用标准方法Node.textContent代替。 Node.textContentNode.parentElement返回当前Node的父Element元素，如果没有父Element元素，返回null。 Node.parentNode一个元素的parentNode可能是另一个元素、Document或者DocumentFragment。Document和DocumentFragment的parentNode是null，同样，一个刚刚创建的node，如果还没有加到dom树里面，它的parentNode同样是null。12//移除某element：ele.parentNode.removeChild(ele);"},{"title":"neutron源码分析","permalink":"http://lishangying.github.io/2016/10/28/neutron-code/","text":"消息总线Openstack各项目之间通过RESTful API进行通信；而项目内部不同服务进程则需要通过消息总线通信。关于消息总线的实现，包含在Openstack.oslo.messaging库中。 RPC远程过程调用，一个服务进程可以调用其他远程服务进程的方法，有两种方式： call 远程方法会被同步执行，调用者会阻塞直到取得返回结果。 cast 远程方法会被异步执行，调用者需要通过其他方式查询这次远程调用的结果。 事件通知(Event Notification)服务可以把事件通知发到消息总线上，该消息总线上所有对此类事件感兴趣的服务进程，都可以获得次事件通知并进行处理。处理结果不会返回事件发送者。 AMQPAMQP是一个异步消息传递所使用的开放的应用层协议规范。包括导向、队列、路由、可靠性和安全性。不同的AMQP实现可以进行相互操作。所有消息都有一个routing key,所有Queue都有一个binding key。生产者将消息发送给Exchange,然后Exchange根据这两个key把消息送到相匹配的Queue中。不同类型的Exchange有不同的匹配算法。 类型 说明 Direct binding key和routing key必须完全一样，不支持通配符 Topic 同Direct类型，但是支持通配符，”*”匹配单字，“#”匹配零个或多个单字，单字之间由“.”来分割 Fanout 忽略binding key和routing key，广播式路由 WSGIWSGI 是一个连接服务端和应用端的接口。WSGI把Web组件分为三部分： WSGI Server WSGI Middleware WSGI Application An Application must return an iterable object.123def application(environ,start_response): start_response('200 Ok',[('Content-Type','text/plain')]) yield 'Hello World\\n' environ:一个dict，包括CGI中定义的环境变量以及7个WSGI所定义的环境变量：wsgi.version,wsgi_input… start_response: 回调函数，要返回一个write(data)对象，用作兼容现有的特殊框架，一般返回None Paste.DeployPaste Deploy通过api-paste.ini配置Paste配置文件分为多个section，每个section以type:name的格式命名。（书上P99） WebOb对WSGI的封装，包含： webob.Request 对WSGI的environ的封装 webob.Response 对WSGI响应的封装 webob.exc 对HTTP错误代码的封装 Webob提供了webob.dec.wsgify的decorator，可以快速开发application12345678910111213# 继承自webob.Requestclass MyRequest(webob.Request): @property def is_local(self): return self.remote_addr == '127.0.0.1'@wsgify(RequestClass=MyRequest) def myfunc(req): if req.is_local: return Response('hi!') else: raise webob.exc.HTTPForbidden EventletOpenstack的协程模块 协程与线程类似，拥有独立的栈和局部变量，但是无法同时执行，(Compare To: Javascript callback) GreenThread123456import eventletdef my_func(param): # do something in coroutine return paramgt = eventlet.spawn(my_func,param)result = gt.wait() eventlet.spawn只是创建一个协程并不立即执行，直到主线程运行到gt.wait()时才开始进入调度序列。 Monkey Path实现协程需要使用Patch的方式对Python的网络相关的标准库进行改写，这个patch就叫monkey_patch。Monkey Patch是大部分使用Eventlet函数库之前需要进行的初始化工作1234# ceilometer/cmd/__init__.pyimport eventlet# patch socket,select,thread三个模块eventlet.monkey_patch(socket=True,select=True,thread=True) OsloOpenstack 通用库 Cliff构建命令行程序DEMO: https://github.com/openstack/cliff/tree/master/demoapp oslo.config解析命令行和配置文件中的配置选项（书上P111）1234567891011121314151617from oslo.config import cfgconf(sys.argv[1:],project=`xyz`) # 初始化，使得oslo.config能够正常解析配置文件和命令行选项rabbit_group = cfg.OptGroup(name='rabbit', title='RabbitMQ options')rabbit_host_opt = cfg.StrOpt('host', default='localhost', help='IP/hostname to listen on.'),rabbit_port_opt = cfg.PortOpt('port', default=5672, help='Port number to listen on.')def register_rabbit_opts(conf): conf.register_group(rabbit_group) # options can be registered under a group in either of these ways: conf.register_opt(rabbit_host_opt, group=rabbit_group) conf.register_opt(rabbit_port_opt, group='rabbit') 如果没有指定group，则选项默认放在[DEFAULT]组下123456789101112# glance-api.conf: [DEFAULT] bind_port = 9292 # ... [rabbit] host = localhost port = 5672 use_ssl = False userid = guest password = guest virtual_host = / 从命令行中设置conf，需要使用使用‘-’连接groupname和optionname1--rabbit-host localhost --rabbit-port 9999 oslo.dbSQLAlchemy数据库模型的抽象 oslo.i18n是对Python gettext的封装，主要用于字符串翻译和国际化 oslo.messagingOpenstack各项目使用RPC和事件通知的统一的接口。其中包括下面4个对象。 Transport传输层，主要实现RPC底层的通信，支持rabbit、qpid、zmq三种协议。可以通过URL来指定不同的transport的实现。1transport://user:pass@host1:port[,hostN:portN]/virtual_host Target封装了指定某一消息最终目的地的所有信息 Server即服务端，创建一个Server对象需要指定Transport、Target、endpoints(包含多组可被远程调用的方法，比如某一资源包含CUID四个操作） RPC Client即客户端，一个RPC Client可以调用RPC Server上的方法。 NotifierNotifier是一个用来发送通知消息的对象。格式如下：12345678&#123; message_id:six_text_type(uuid.uuid4()), #消息id号 publisher_id:&apos;computer.host1&apos;,#发送者id timestamp:timeutils.utcnow(),#时间戳 priority:&apos;WARN&apos;, # 通知优先级 event_type:&apos;compute.create_instance&apos;,#通知类型 payload:&#123;&apos;instance_id&apos;:12,...&#125; #通知内容&#125; Notifier Listener消息监听者，跟Server类似，可以暴露多个endpoint，每个endpoint中也可以包含多种方法，但是它们只是对应者不同的消息优先级。（P118）"},{"title":"张小龙效应","permalink":"http://lishangying.github.io/2016/01/11/zhangxiaolong/","text":"今天的互联网头条是当仁不让的小龙哥。从昨晚风靡朋友圈的情怀回忆图开始：你的第一个微信好友，第xx位微信用户，2015发了多少红包…，（不知是否如小龙哥所说，是出乎公关意料之外的流出产品）加上首次公开演讲的小龙哥，瞬间让今日的微信公开课门庭若市，虽说微信产品的魅力就在于无需推广，但如此用户蝴蝶效应般的蜂拥而至，此种”微信力量“令人叹服。 此次微信公开课以公众号直播方式，指明微信2016年的生态风向标，以及开发者最为关心的开放平台发展指南。先不说具体聊了啥，作为一个直播平台提供商的产品负责人，深感惭愧，竞争对手微谷在把握新媒体热点上甩我们好几条街。而微信公开课自身也提供了直播观看入口，以公众号文章形式发布直播，聊天平台需跳转，不知道为何做这个设定，让边看直播边聊天不好吗？ 而张小龙说了啥，相信大家印象最深的一句话就是：能让用户用了就走的产品才是好产品。任何产品都是一个工具，如何能让用户高效完成自己想做的事，是我们需要实时思索的，嗯，只有达到一定境界的产品才有勇气这么说，而我们才实现温饱，哪谈得上情怀。一切以用户价值体验为中心，这句话相信是个产品经理都会说，但是真正做到的不会有几个，因为各方面因素会影响我们的产品发展形态，包括用户群使用的不同，特别是我们这种作为面向商业用户的产品。 另外一个重磅消息则是小龙哥提出了应用号的概念。手机app需要商店下载，安装，占用内存，相比微信公众号扫一扫添加的形式，推广门槛高了不是一点两点。未来将会把我们必需的而不经常用的产品，如购买车票，查询信息等需求从app中转移到微信中来。嗯，下了好大一盘棋。从15年开始，大家就已经从这个方向开始发展，包括近期携程线上线下大力推广的汽车票购买服务，各大银行卡信用卡提醒都摈弃了原有的app理念，往轻量级概念发展。而我们的直播，从一开始就没考虑过手机app，直接搭建在微信中，用户即扫即看，边看边聊。这是未来的趋势，至于真正的应用号应该长什么样，我们拭目以待。 正好今天开了个会议，感触良多。我们的产品道路还处于迷茫之中，何为重点方向？提供怎样的直播方案？优势在哪里？如何协调直播与点播？如何丰富产品展现形态？暂时无法回答，但希望自己能尽快清晰道路，更好的带领团队。 思索之后，暂时确定近期规划：数据，反馈，细节展现。 数据：增加平台使用数据汇总，以更形象展现更多观众数据给平台用户 反馈：增加工单机制，让用户有地方提问与收到解答；构建qq群，更open的接触用户；第三方论坛，构建沟通平台 细节展现：增加用户体验的细节，打磨直播页面。"},{"title":"Hexo折腾笔记（二）博客优化与定制","permalink":"http://lishangying.github.io/2015/02/25/hexo-lightum-enhance/","text":"首先我使用的是由zippera基于官方Light主题改进而来的Lightum主题,其他主题可能稍有出入。 ##速度优化参考之前的文章：静态页面优化。然后使用了hexo-qiniu-sync这个项目，将静态的图片以及css、js同步到了七牛云。（PS：主题模板中包含了两个不同版本的jquery，分别在head.ejs与after-footer.ejs中，随便删除一个。） 对于处于body区域的script、style的引用尽可能的加入data-no-instant属性，避免InstantClick重复加载。 ##给instantclick加载进度条加上阴影效果1234#instantclick-bar&#123;-webkit-box-shadow: 0 0 8px rgba(0, 0, 0, 0.56);box-shadow: 0 0 8px rgba(0, 0, 0, 0.56);&#125; ##加入Swiftype搜索去Swiftype官网申请代码，然后修改search.ejs文件为：12345&lt;div class=\"search\"&gt;&lt;form&gt;&lt;input type=\"search\" id=\"st-search-input\" placeholder=\"&lt;%= __('search') %&gt;\"&gt;&lt;/form&gt;&lt;/div&gt; 更具体的指导具体可以参考这篇文章：click here。 ##改进多说评论框 ###添加data-thread-key等属性123&lt;!-- 多说评论框 start --&gt;&lt;div class=\"ds-thread\" data-thread-key=\"&lt;%= page.path %&gt;\" data-title=\"&lt;%= page.title %&gt;\" data-url=\"&lt;%= page.permalink %&gt;\"&gt;&lt;/div&gt;&lt;!-- 多说评论框 end --&gt; ###美化多说评论框进入多说评论的管理后台，将下面代码粘贴到‘设置-&gt;自定义CSS’中。123456789101112#ds-reset .ds-avatar img&#123;width:54px;height:54px;border-radius:27px;-webkit-border-radius:27px;-moz-border-radius:27px;box-shadow:inset 0 -1px 0 #3333sf;-webkit-box-shadow:inset 0 -1px 0 #3333sf;-webkit-transition:0.4s;-webkit-transition:-webkit-transform 0.4s ease-out;transition:transform 0.4s ease-out;-moz-transition:-moz-transform 0.4s ease-out;&#125;#ds-reset .ds-avatar img:hover&#123;box-shadow:0 0 10px #fff;rgba(255,255,255,.6),inset 0 0 20px rgba(255,255,255,1);-webkit-box-shadow:0 0 10px #fff;rgba(255,255,255,.6),inset 0 0 20px rgba(255,255,255,1);transform:rotateZ(360deg);-webkit-transform:rotateZ(360deg);-moz-transform:rotateZ(360deg);&#125;p.ds-powered-by,#ds-sync-checkbox,.ds-sync label&#123;display:none!important;&#125;#ds-reset .ds-rounded-top&#123;-webkit-border-top-right-radius:0px;-webkit-border-top-left-radius:0px;border-top-right-radius:0px;border-top-left-radius:0px;&#125;#ds-thread #ds-reset .ds-textarea-wrapper&#123;background:#fff;border:0;margin-bottom:20px;padding-right:0px;&#125;#ds-thread #ds-reset .ds-textarea-wrapper textarea&#123;min-height:80px;border:1px solid #ccc;padding:10px;-webkit-appearance:none;border-radius:0;background-color:#FFFFFF;border-color:#cccccc;box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);color:rgba(0,0,0,0.75);-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-transition:border-color 0.15s linear,background 0.15s linear;-moz-transition:border-color 0.15s linear,background 0.15s linear;-ms-transition:border-color 0.15s linear,background 0.15s linear;-o-transition:border-color 0.15s linear,background 0.15s linear;transition:border-color 0.15s linear,background 0.15s linear;&#125;#ds-thread #ds-reset .ds-textarea-wrapper textarea:focus&#123;border-color:#999999;background:#fafafa;outline:none;&#125;#ds-thread #ds-reset .ds-post-options&#123;border-bottom-left-radius:0px;-webkit-border-bottom-left-radius:0px;border:none;background:none!important;&#125;#ds-thread #ds-reset .ds-post-button&#123;border-bottom-right-radius:0px;-webkit-border-bottom-right-radius:0px;&#125;#ds-reset .ds-textarea-wrapper textarea:focus&#123;border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);&#125;#ds-thread #ds-reset .ds-post-button&#123;background-image:none;text-shadow:none;border:none;font-weight:normal;line-height:normal;position:absolute;-webkit-appearance:button;-moz-appearance:button;background-color:#008CBA;border-color:#007095;color:#FFFFFF;transition:background-color 300ms ease-out;&#125;#ds-thread #ds-reset .ds-post-button:hover,#ds-thread #ds-reset .ds-post-button:focus&#123;background-color:#007095;color:#FFFFFF;&#125; ##加入多说最新评论修改’theme/lightum/_config.yml’文件，在widgets下面添加- recent_comments项。在主题文件的’theme/lightum/layout/_widget’目录中新建recent_comments.ejs文件，并放入如下代码：1234567891011&lt;div class=&quot;widget tag&quot;&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;%= __(&apos;recent_comments&apos;)&lt;/h3&gt;&lt;div class=&quot;entry&quot;&gt;&lt;!-- 多说最新评论 start --&gt; &lt;div class=&quot;ds-recent-comments&quot; data-num-items=&quot;5&quot; data-show-avatars=&quot;1&quot; data-show-time=&quot;1&quot; data-show-title=&quot;1&quot; data-show-admin=&quot;1&quot; data-excerpt-length=&quot;70&quot;&gt;&lt;/div&gt;&lt;!-- 多说最新评论 end --&gt;&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;..........&lt;!-- 多说公共JS代码 end --&gt;&lt;/div&gt;&lt;/div&gt; 然后在’/languages/zh-CN.yml’文件添加翻译：recent_comments: 最新评论 最后，原来的评论样式不太符合lightum主题，可以在’/source/css/_partial’里建立一个recent_comment.styl文件：1234.ds-recent-comments li.ds-comment &amp;:first-child border-top none !important 然后在/theme/lightum/source/css/style中将之包括进来：@import &#39;_partial/recent_comments&#39; 多说的这个插件同样不兼容于instantclick。我们可以在这篇文章的基础上解决：click here: 将多说的公共JS放入head或加入’data-no-instant’属性放入body中，并删除recent.ejs与comment.ejs中重复的JS。 修改change事件中的代码为：123456if(typeof DUOSHUO !== &apos;undefined&apos;)&#123; //support 多说评论框if($(&quot;.ds-thread&quot;).length)&#123; DUOSHUO.EmbedThread($(&apos;.ds-thread&apos;)[0]);&#125;DUOSHUO.RecentComments($(&apos;.ds-recent-comments&apos;)[0]);&#125; 这样虽然能够解决问题，但是会显示方面又会出现点小问题。可以加入下面css修复：123span.caption&#123;display: none;&#125; 加入文章导航修改’/layout/_partical/article.ejs’文件1234567891011121314&lt;article class=\"&lt;%= item.layout %&gt;\"&gt; // ... &lt;div class=\"entry\"&gt; &lt;% if (item.excerpt &amp;&amp; index)&#123; %&gt; &lt;%- item.excerpt %&gt; &lt;% &#125; else &#123; %&gt; &lt;% if (!index)&#123; %&gt; // 插入文章导航 &lt;%- partial('toc') %&gt; &lt;% &#125; %&gt; &lt;%- item.content %&gt; &lt;% &#125; %&gt; &lt;/div&gt;&lt;/article&gt; 在’\\source\\css_partial\\article.styl’文件后添加：1234567891011121314151617181920.toc-article float right #toc background #eee margin 0 0 10px 20px padding 12px line-height 18px font-size 10px strong font-size 15px ol margin-top 5px margin-left 0 .toc padding 0 li list-style-type none .toc-child padding-left 20px 这样，我们就能在写文章的时候添加toc: true来启动文章导航功能。 ###扩展：浮动式导航实现当页面滑动到下方时将文章导航浮动到屏幕右侧。 在’\\layout_partial\\’里新建文件：float_nav.ejs1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;div id=\"menu-nav\"&gt; &lt;div id=\"title-nav\"&gt;&lt;%= __('navigation') %&gt;&lt;div&gt;→&lt;/div&gt; &lt;/div&gt; &lt;div id=\"content-nav\"&gt; &lt;%- toc(item.content) %&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;(function($, scrollSpeed, hiddenSpeed, fadeSpeed) &#123; var T = $('#toc'); var M = $('#menu-nav'); var C = $('#content-nav'); var Tx = T.position().top; $(window).scroll(function() &#123; var top = $(this).scrollTop(); if (top &gt;= Tx + 300) &#123; M.stop().fadeIn(fadeSpeed); T.stop().fadeTo(fadeSpeed, 0); &#125; else &#123; M.stop().fadeOut(fadeSpeed); T.stop().fadeTo(fadeSpeed, 1); &#125; &#125;); $('.toc-link').click(function(e) &#123; //阻止默认跳转 e.preventDefault(); //定义滚动动画 var scrollTarget = $('#' + $(this).children('.toc-text').first().text()); $(\"html,body\").animate(&#123; scrollTop: scrollTarget.prev().offset().top &#125;, scrollSpeed); &#125;); C.click(function(e) &#123; e.stopPropagation(); &#125;); M.click(function() &#123; C.toggle(hiddenSpeed, 'linear', function() &#123; var T = $('#title-nav div'); T.text() == '←' ? T.text('→') : T.text('←'); &#125;); &#125;);&#125;)(jQuery, 500, 200, 100);&lt;/script&gt; 在’layout/_partial/article.ejs’中添加对其的引用：123&lt;% if(!index &amp;&amp; item.toc)&#123; %&gt; &lt;%- partial('float_nav') %&gt;&lt;% &#125; %&gt; 添加css样式：123456789101112131415161718192021222324252627282930313233343536373839navbcolor=rgba(100, 100, 100, 0.74)#menu-nav position fixed; display none; cursor pointer; z-index 150; right 0; top 20%; box-shadow 0 0 5px rgba(0, 0, 0, 0.15); color white; background navbcolor; #title-nav display inline-block; vertical-align middle; width: 30px; height: 100%; font-size: 16px; text-align: center; padding: 10px 0; #content-nav display inline-block; vertical-align middle; white-space:nowrap; border-left: 1px dashed #ccc; box-sizing border-box; padding 15px; line-height 18px; font-size 10px; li list-style-type none; width 100%; a display block; box-sizing border-box; color #FFFFFF; &amp;:hover background rgba(100, 100, 100, 1); .toc-child a padding-left 20px; ###添加”返回顶部”与上一节相似，在’layout/_widget/‘中添加totop.ejs文件：12345678910111213141516171819&lt;div id=\"to-top\"&gt;↑&lt;/div&gt;&lt;script&gt;(function($, scrollSpeed, fadeSpeed) &#123; var T = $('#to-top'); $(window).scroll(function() &#123; var top = $(this).scrollTop(); if (top &gt;= 300) &#123; T.stop().fadeIn(fadeSpeed); &#125; else &#123; T.stop().fadeOut(fadeSpeed); &#125; &#125;); T.click(function() &#123; $(\"html,body\").animate(&#123; scrollTop: 0 &#125;, scrollSpeed); &#125;);&#125;)(jQuery, 500, 200);&lt;/script&gt; 在’lightum/_config.yml’中启用该挂件：12widgets:- totop 添加css样式：12345678910111213141516#to-top background navbcolor; position fixed; display none; z-index 200; right 40px; bottom 10%; box-shadow 0 0 5px rgba(0, 0, 0, 0.15); font-size 14px; color white; padding 5px 15px; cursor pointer; font-size 12px; text-align center; &amp;:hover background rgba(100,100,100,1); ##参考 Hexo 主题修改:为博客实现更多功能 多说评论也玩圆角头像动画「自定义CSS:无压力小白级教程」 Hexo 优化与定制(二)"},{"title":"Hexo折腾笔记（一）博客加速以及instantclick的兼容","permalink":"http://lishangying.github.io/2015/02/25/hexo-speedup-instantclick/","text":"首先，Gitcafe的国内速度已经够快了，加不加速其实没多大区别,只不过是闲的蛋疼而已。Gitcafe无故page不更新，所以又换回了github。 Hexo加速Hexo加速可以有以下几个方面： 使用BootCDN并将图片等资源储存至七牛云。可以使用此项目click here。 使用hexo optimize压缩优化HTML、CSS、JS、Image资源。 使用InstantClick。 InstantClick是一款类似于Turbolinks的js库，利用pjax（pushState and Ajax)技术对网站进行优化，能够极大的提高访问速度。 解决InstantClick的兼容问题InstantClick效果明显，但是副作用也大。加入它之后，原来相处无碍的Fancybox、百度分享、百度统计、 mathJax、多说评论都挂了。下面是我的解决方法： ###FancyboxFancybox的修复首先要避面页面切换时jquery.fancybox.min.js文件的重复加载。可以将该js文件的引用放入head中或者加入data-no-instant属性。然后，因为instantclick在预加载时默认只替换body元素，所以在绑定fancybox的时候需要设置parent属性为body：123(function($)&#123; $('.fancybox').fancybox(&#123;parent:'body'&#125;);&#125;)(jQuery); 这样就应该可以了。 ###多说评论（以及最新评论、热评文章等）首先，多说的公共JS是不能放在加入data-no-instant属性的。因为不是网站所有页面都包含评论部分的。因此，我们需要将其裹入一层判断中来阻止其多次加载，提高网页的访问速度：123456789101112131415&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;&lt;script type=\"text/javascript\"&gt;if(typeof duoshuoQuery === 'undefined')&#123; var duoshuoQuery = &#123;short_name:\"你的域名\"&#125;; (function() &#123; var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)();&#125;&lt;/script&gt;&lt;!-- 多说公共JS代码 end --&gt; 然后，我们需要在页面预加载的change事件里对其进行重载：12345678910&lt;script data-no-instant&gt;InstantClick.on('change', function(isInitialLoad) &#123; if (isInitialLoad === false) &#123; if($(\".ds-thread\").length &amp;&amp; typeof DUOSHUO !== 'undefined')&#123; //support 多说评论框 DUOSHUO.EmbedThread($('.ds-thread')[0]); &#125; &#125;&#125;);InstantClick.init();&lt;/script&gt; 可以用同样的方式解决多说的热门文章、最新评论等插件的问题。DUOSHUO全部的重载函数有：&quot;EmbedThread&quot;, &quot;RecentComments&quot;, &quot;RecentVisitors&quot;, &quot;TopUsers&quot;, &quot;TopThreads&quot;, &quot;LoginWidget&quot;, &quot;ThreadCount&quot; ###百度统计、google统计、MathJax这三个可以参考这篇文章：click here。同样是在change事件里对他们进行重新加载。123456789101112InstantClick.on('change', function(isInitialLoad) &#123; if (isInitialLoad === false) &#123; if (typeof MathJax !== 'undefined') // support MathJax MathJax.Hub.Queue([\"Typeset\",MathJax.Hub]); if (typeof prettyPrint !== 'undefined') // support google code prettify prettyPrint(); if (typeof _hmt !== 'undefined') // support 百度统计 _hmt.push(['_trackPageview', location.pathname + location.search]); if (typeof ga !== 'undefined') // support google analytics ga('send', 'pageview', location.pathname + location.search); &#125;&#125;); ###百度分享百度分享可以用jiathis代替，其实国内的分享工具都差不多。 ##关于data-no-instant属性data-no-instant属性是用来避免instantclick在页面切换时对该元素重复加载。可以用在script、style标签中，也能放在a标签中，表示该链接将使用正常方式打开而不用instantclick加速。 data-no-intant无法阻止对div等元素的重新加载，因此无法实现像网易云音乐那样在切换页面的时候无间断的播放音乐等功能。不过曾有人contribute过类似的功能，但是作者没有接受：click here。 至此全部问题解决了，其他的问题可以参考下面几个链接： 整合 InstantClick 與 AddThis Hexo 静态博客加速 fancybox文档 InstantClick文档"},{"title":"Shadowsocks免费账号网址集","permalink":"http://lishangying.github.io/2015/02/24/shadowsocks-account/","text":"G+圈子很多这样的网站，大部分是由ss-panel这个开源项目建成。不知道他们是乐于分享还是另有目的。下面是列表： Shadow X(ss-panel作者) kuaishangSS pepsishadowsocks ChangZ ssserver 另外推荐Linux下ss GUI客户端：shadowsocks-qt5"},{"title":"ASP.NET MVC 4笔记（二）","permalink":"http://lishangying.github.io/2015/02/24/ASP-NET-MVC4note2/","text":"有Timestamp修饰的表在修改已有的记录是一定要将该字段复制，也就是说一定要在Edit网页里面添加一行：@Html.HiddenFor(model =&gt; model.RowVersion) WebSecurity.CreateAccount必须在Userprofile里面先创建账户。System.Diagnostics.Debug.WriteLine(&quot;OnAction:&quot; + controller + &quot;/&quot; + action); 转换string数组到int数组int[] HostsList = Array.ConvertAll&lt;string, int&gt;(Request[&quot;HostsId&quot;].Split(&apos;,&apos;), u =&gt; int.Parse(u));"},{"title":"ASP.NET MVC4笔记（一） 扩展Simplemembership","permalink":"http://lishangying.github.io/2015/02/24/ASP-NET-MVC4-note1-Simplemembership/","text":"1234567891011121314151617181920using System.Web.Mvc;namespace MvcClassManageSystem.ActionFilters&#123; public class LogStateFilterAttribute : ActionFilterAttribute &#123; public override void OnActionExecuting(ActionExecutingContext filterContext) &#123; base.OnActionExecuting(filterContext); //string controller = filterContext.RouteData.Values[&quot;controller&quot;].ToString(); //string action = filterContext.RouteData.Values[&quot;action&quot;].ToString(); //System.Diagnostics.Debug.WriteLine(&quot;OnAction:&quot; + controller + &quot;/&quot; + action); if (WebMatrix.WebData.WebSecurity.IsAuthenticated == true) &#123; filterContext.Result = new RedirectToRouteResult(new System.Web.Routing.RouteValueDictionary(new &#123; Controller = &quot;Home&quot;, action = &quot;Index&quot; &#125;)); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526public static class WebUtility &#123; private static SimpleMembershipProvider membership = (SimpleMembershipProvider)Membership.Provider; public static void CreateUserAndAccount(UserProfile userProfile, string Password) &#123; WebSecurity.CreateUserAndAccount(userProfile.UserName, Password, new &#123; //TO DO 数据库/模型更改之后别忘记修改此处！！！ ClassId = userProfile.ClassId, UserExtraInfo_Phone = userProfile.UserExtraInfo.Phone, UserExtraInfo_Gender = userProfile.UserExtraInfo.Gender, UserExtraInfo_BirthDay = userProfile.UserExtraInfo.BirthDay, UserExtraInfo_UserDesc = userProfile.UserExtraInfo.UserDesc &#125;); &#125; public static void DeleteUserAndAccount(string UserName) &#123; membership.DeleteAccount(UserName); Roles.RemoveUserFromRoles(UserName, Roles.GetRolesForUser(UserName)); membership.DeleteUser(UserName, true); &#125; public static void ResetPassword(string UserName, string NewPassword) &#123; WebSecurity.ResetPassword(WebSecurity.GeneratePasswordResetToken(UserName, 1), NewPassword); &#125; &#125; 123456789101112131415using System.Web.Mvc;namespace MvcClassManageSystem.Filters&#123; public class MyAuthorizeAttribute : AuthorizeAttribute &#123; protected override void HandleUnauthorizedRequest(AuthorizationContext filterContext) &#123; base.HandleUnauthorizedRequest(filterContext); if (filterContext.HttpContext.User.Identity.IsAuthenticated) &#123; filterContext.Result = new RedirectResult(&quot;/Account/AccessError&quot;); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using System.Data.Entity;using System.Linq;using System.Web.Security;using WebMatrix.WebData;namespace MvcClassManageSystem.Models&#123; public class InitSecurityDb : DropCreateDatabaseAlways&lt;DBManager&gt; &#123; protected override void Seed(DBManager context) &#123; WebSecurity.InitializeDatabaseConnection(&quot;DefaultConnection&quot;, &quot;UserProfile&quot;, &quot;UserId&quot;, &quot;UserName&quot;, autoCreateTables: true); var roles = (SimpleRoleProvider)Roles.Provider; string[] RolesList = new string[] &#123; &quot;Admin&quot;, &quot;Teacher&quot;, &quot;Student&quot; &#125;; foreach (var item in RolesList) &#123; if (!roles.RoleExists(item)) &#123; roles.CreateRole(item); &#125; &#125; //设置初始班级 int ClassIndex = 0; using (var db = new DBManager()) &#123; var ret = db.ClassProfiles.SingleOrDefault(m =&gt; m.ClassName.CompareTo(&quot;未知班级&quot;) == 0); if (ret == null) &#123; ret = db.ClassProfiles.Add(new ClassProfile &#123; ClassName = &quot;未知班级&quot;, Desc = &quot;班级未知或无意义&quot; &#125;); db.SaveChanges(); &#125; ClassIndex = ret.ClassId; &#125; if (!WebSecurity.UserExists(&quot;管理员&quot;)) &#123; WebUtility.CreateUserAndAccount(new UserProfile() &#123; UserName = &quot;管理员&quot;, ClassId = ClassIndex, UserExtraInfo = new UserExtraInfo() &#123; Phone = &quot;18267912632&quot;, Gender = MvcClassManageSystem.Models.Gender.男, BirthDay = new System.DateTime(1993, 9, 28), UserDesc = &quot;本站的管理员！&quot; &#125; &#125;, &quot;admin&quot;); System.Web.Security.Roles.AddUserToRole(&quot;管理员&quot;, &quot;Admin&quot;); &#125; &#125; &#125;&#125; 1234567891011121314151617 protected void Application_Start() &#123; Database.SetInitializer&lt;DBManager&gt;(new InitSecurityDb()); DBManager db = new DBManager(); db.Database.Initialize(true); if (!WebSecurity.Initialized) &#123; WebSecurity.InitializeDatabaseConnection(&quot;DefaultConnection&quot;, &quot;UserProfile&quot;, &quot;UserId&quot;, &quot;UserName&quot;, autoCreateTables: true); &#125; AreaRegistration.RegisterAllAreas(); WebApiConfig.Register(GlobalConfiguration.Configuration); FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); AuthConfig.RegisterAuth(); &#125;"},{"title":"KDE的Mac向折腾指南","permalink":"http://lishangying.github.io/2014/12/07/kde-to-mac/","text":"惯例，先上图： [ logo9](http://sforkw-wp.qiniudn.com/jae/uploads/2014/12/logo9-1024x575.png) [ logo5](http://sforkw-wp.qiniudn.com/jae/uploads/2014/12/logo5-1024x575.png)](http://sforkw-wp.qiniudn.com/jae/uploads/2014/12/logo5.png) [![logo6](http://sforkw-wp.qiniudn.com/jae/uploads/2014/12/logo6-1024x575.png)](http://sforkw-wp.qiniudn.com/jae/uploads/2014/12/logo6.png) [![logo7](http://sforkw-wp.qiniudn.com/jae/uploads/2014/12/logo7-1024x575.png)](http://sforkw-wp.qiniudn.com/jae/uploads/2014/12/logo7.png) [![logo8](http://sforkw-wp.qiniudn.com/jae/uploads/2014/12/logo8-1024x575.png) 首先，KDE的全局菜单可以参考我以前的文章《KDE4的配置参考》。 然后，Plasma的主题是AG-plasma，aurorae主题是Yoxydaze-light。这些可以去kde-look里找。 底部的dock是plank，主题是ArHU，在deviantART中找到的。另外，plank上的图标是受gtk主题控制的，所以装numix-circle是最好不过的。 我的apps文件可以在这里下载：click here ~/.config/plank/dock1/settings文件：12345678910111213141516171819202122232425262728293031323334#This file auto-generated by Plank.#2014-12-06T09:47:52+0000[PlankDockPreferences]#Whether to show only windows of the current workspace.CurrentWorkspaceOnly=false#The size of dock icons (in pixels).IconSize=42#If 0, the dock won&apos;t hide. If 1, the dock intelligently hides. If 2, the dock auto-hides. If 3, the dock dodges active maximized windows.HideMode=0#Time (in ms) to wait before unhiding the dock.UnhideDelay=0#The monitor number for the dock. Use -1 to keep on the primary monitor.Monitor=-1#List of *.dockitem files on this dock. DO NOT MODIFYDockItems=plank.dockitem;;google-chrome.dockitem;;dolphin.dockitem;;juk.dockitem;;eclipse.dockitem;;chrome-pjkebmlmkppdjcdcilfcjdkifljollfd-Default.dockitem;;kate.dockitem;;gwenview.dockitem;;wps-office-wps.dockitem;;konsole.dockitem;;sublime_text_3.dockitem;;love-wallpaper.dockitem;;ksysguard.dockitem;;virtualbox.dockitem#The position for the dock on the monitor. If 0, left. If 1, right. If 2, top. If 3, bottom.Position=3#The dock&apos;s position offset from center (in percent).Offset=0#The name of the dock&apos;s theme to use.Theme=ArHU#The alignment for the dock on the monitor&apos;s edge. If 0, panel-mode. If 1, left-aligned. If 2, right-aligned. If 3, centered.Alignment=3#The alignment of the items in this dock if panel-mode is used. If 1, left-aligned. If 2, right-aligned. If 3, centered.ItemsAlignment=3#Whether to prevent drag&apos;n&apos;drop actions and lock items on the dock.LockItems=false#Whether to use pressure-based revealing of the dock if the support is available.PressureReveal=false#Whether to show only pinned applications. Useful for running more then one dock.PinnedOnly=true#Whether to automatically pin an application if it seems useful to do.AutoPinning=true ~/.local/share/plank/themes/ArHU/中的dock.theme和hover.theme文件分别是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#This file auto-generated by Plank.#2014-12-06T06:22:37+0000[PlankDrawingTheme]#The roundness of the top corners.TopRoundness=6#The roundness of the bottom corners.BottomRoundness=0#The thickness (in pixels) of lines drawn.LineWidth=0#The color (RGBA) of the outer stroke.OuterStrokeColor=0;;0;;0;;0#The starting color (RGBA) of the fill gradient.FillStartColor=255;;255;;255;;150#The ending color (RGBA) of the fill gradient.FillEndColor=255;;255;;255;;150#The color (RGBA) of the inner stroke.InnerStrokeColor=255;;255;;255;;255[PlankDrawingDockTheme]#The padding on the left/right dock edges, in tenths of a percent of IconSize.HorizPadding=0#The padding on the top dock edge, in tenths of a percent of IconSize.TopPadding=1#The padding on the bottom dock edge, in tenths of a percent of IconSize.BottomPadding=1#The padding between items on the dock, in tenths of a percent of IconSize.ItemPadding=4#The size of item indicators, in tenths of a percent of IconSize.IndicatorSize=0#The size of the icon-shadow behind every item, in tenths of a percent of IconSize.IconShadowSize=0#The height (in percent of IconSize) to bounce an icon when the application sets urgent.UrgentBounceHeight=0.10000000000000001#The height (in percent of IconSize) to bounce an icon when launching an application.LaunchBounceHeight=0.10000000000000001#The opacity value (0 to 1) to fade the dock to when hiding it.FadeOpacity=0#The amount of time (in ms) for click animations.ClickTime=150#The amount of time (in ms) to bounce an urgent icon.UrgentBounceTime=300#The amount of time (in ms) to bounce an icon when launching an application.LaunchBounceTime=300#The amount of time (in ms) for active window indicator animations.ActiveTime=150#The amount of time (in ms) to slide icons into/out of the dock.SlideTime=150#The time (in ms) to fade the dock in/out on a hide (if FadeOpacity is &amp;lt; 1).FadeTime=100#The time (in ms) to slide the dock in/out on a hide (if FadeOpacity is 1).HideTime=100#The size of the urgent glow (shown when dock is hidden), in tenths of a percent of IconSize.GlowSize=30#The total time (in ms) to show the hidden-dock urgent glow.GlowTime=10000#The time (in ms) of each pulse of the hidden-dock urgent glow.GlowPulseTime=2000#The hue-shift (-180 to 180) of the urgent indicator color.UrgentHueShift=150#The time (in ms) to move an item to its new position.ItemMoveTime=150 123456789#This theme written by Perian. thexperian.deviantart.com[PlankDrawingTheme]TopRoundness=3LineWidth=0OuterStrokeColor=0;;0;;0;;0FillStartColor=0;;0;;0;;150FillEndColor=0;;0;;0;;150InnerStrokeColor=0;;0;;0;;0 以上是我折腾的结果，找主题也找了半天。大家如果有更好的主题与壁纸也拿来分享一下吧。"},{"title":"(转)慢慢的，就没有了，就像从未存在过","permalink":"http://lishangying.github.io/2014/11/28/man-man-de/","text":"几年以前，我曾经嘲笑过某科技界大佬。当时他说：也许90后、95后会慢慢不知道谷歌是什么网站。 那一年，这对于我来说简直就是世界上最好笑的笑话。谷歌，全世界最卓越的互联网公司，活在互联网的一代中国人，会不知道他们的网站？ 今天，我收回这句嘲笑。因为这件不可能的事，它慢慢变成了现实。 没有人再关注什么谷歌不谷歌。对他们来说，百度也蛮好用的，反正他们几乎没用过谷歌。没有谷歌又怎样？大家还是开心的刷微博，看微信，听歌，看娱乐节目。对于从来就不知道谷歌的人来说，少了谷歌又有什么影响？ 慢慢的，就没有了，就像从未存在过 多年前，我们也是可以登陆Facebook的。其实这个网站和校内一样，也挺蠢的。可在上面你能看到老外们的生活，可以轻易的跟一万公里以外的人互相拜访，可以看到很多根本不会开到校内上的主页。你用汉语回复，下面给你聊起来的可能是香港仔，可能是台湾人。你用英语回复，说不定有比你英语用的更蹩脚的寂寞的北欧人来跟你搭讪。你感觉地球真的变成了地球村，你还没拉门走出去，别人就推门走了进来。 然后，它就没有了。起初，它的失踪激起了很大的声音，后来，声音就消失了。 多年前，我们也是可以登陆Twitter的。其实这个网站和微博一样，也不过是些信息流，刷上一整天，也不见得有什么用处。但至少，你可以以最快速度获取你想知道的任何新事，你会真正了解什么事情在全世界是流行的，而不是经过各种截图、翻译、转发，甚至曲解、断章取义、黑白颠倒的东西。你知道的是真相，赤裸裸的，也许有点太短的真相。但至少中间不会有无数人的加工与再加工，偏激、片面，就在这个过程中产生了，不管后来者有意还是无意。 然后，它就没有了。首先是它的本体没有了，然后它的模仿者也没有了，模仿者的模仿者也没有了。只剩一个模仿者的模仿者的模仿者，现在你每天能在上面看到无数广告。 多年前，我们也是可以登陆YouTube的。对于有的人来说，这个网站就是个大型优酷，当年有人信誓旦旦的说，没有YouTube，我们中国人会很快让优酷超过YouTube。可这么多年过去了，视频还是那么卡，内容还是那么垃圾，原创还是那么容易被盗窃，视频丰富度还是那么的可怜。在YouTube上，你能看到全世界最棒的手艺人，最逗乐的笑话，最天马行空的创意，最激荡人心的音乐，最美好的完美瞬间，可在优酷上，你想看一分钟视频，请先看半分钟广告。 哦，对了。Instagram，有些人可能感觉它和QQ空间也差不多。可我在上面关注了六百多个摄影师，它们都是顶好顶好的影像记录者，每天看他们的作品，我感觉到很幸福，那种即使没有到那里去，也身临其境的幸福。我还在上面认识了一个日本的爱自拍的帅小伙，一个爱喝酒的韩国大叔，一个十年前到过中国今天会在每张我发的紫禁城照片下点赞的美国大爷，一个美丽无比的俄罗斯妹子，我和他们基本上都难以交流，语言是很大的障碍，但几个简单的单词，心意也就到了，这种感觉，有时候比多年老友相聚还兴奋。因为这是人类不同族群自由交流互相沟通的过程，这种过程很神奇，真的很神奇。 可现在，它没有了，它之所以没有就因为在某个特定的时间你在搜索特定的词汇时，会搜出来特定的照片。虽然这么搜的人并不多，虽然看到的人也不会大惊小怪，也不会觉得天黑了，天亮了，天要塌了，天要变了。可它就是没了，Instagram，就这么没了。谷歌也是这么没的，Twitter也是这么没的，Facebook也是这么没的。不知道是什么人，在什么场合，说了什么话，下了什么决定。就要有超过十亿人像陷于哥谭市的孤岛里一样，看着一座又一座桥梁被炸掉，又被炸掉，又被炸掉，然后，就什么都没了。 我时常觉得悲哀，真的好悲哀，一个我根本不认识也不知道是谁的人，也许是一个群体，在不断抢走我身边的东西，而我却无能为力。我抱怨一声，他听不到，任何人都听不到。我怒吼一句，身边的大多数人却像看疯子一样的看着我。我哀嚎一声，这声音被阻碍在黑黑的幕墙以里。我发出尖锐的嘶吼，这声音传不了多远，就和我那被抢走的东西一样，消失了，不见了，就像从来没存在过一样。 对于本来就没存在过的东西，有谁又会觉得在意呢？那些本来拥有又被掠夺的人的哀愁，后来的人又怎么懂呢？我曾经是拥有一切的，我曾经是拥有世界的，我站在这片土地上，呼吸的是自由的空气，饮下的是自由的琼浆玉液。就在长的无法计数的时间里，我自由生命的一部分又一部分就这么被杀死了，突然就杀死了。可我还始终觉得，它们还奄奄一息的活着，就像它们是慢慢的死去的一样。 可它们终归是死了，而且随着它们的死，愈来愈多的事情慢慢的发生了，很慢很慢，几乎不被人察觉，可还是发生了。 没有谷歌，我可以用百度呀。可某些结果被越挪越后，越挪越后，最后就不见了。就像本来就不该搜出这个结果一样。 没有Facebook，我可以用校内呀。可你想发只有在Facebook上能发的文章，很快在校内上就失踪了。接着，校内变成了人人，话题变成了人人都关心的话题。大家都在抢着看星座、明星、八卦、娱乐。没有人会关心什么消失了，反正它们本来也没多少存在感。 没有YouTube，我可以用优酷呀。可你却经常只能在优酷上看到抄袭别人的作品，而且还不署名，而且还洋洋得意，而且还自我陶醉，就好像那个idea本来属于他自己一样。你看了还要惊呼，他是如此的有创意！好一个抄袭的创意，可你却不知道，因为你不知道这个世界上有个网站叫YouTube。 没有Twitter，我还可以用微博呀。可你想知道最近发生了什么，你搜的越勤快，越能看到越明显的“根据相关法律法规，相关搜索结果不予显示”。时间长了，你想，反正知道了也没什么用，不如不看了。 慢慢的，一扇又一扇的门关上了。今天你打开世界上最大的博客网站，发现它没了。明天你一看，世界上最好的设计师分享网站没了，一开始是刷新的很慢很慢，后来它就没了。过两天再一看，平常每天都会读两篇文章的媒体网站没了，那里的文章缤纷多彩，最后都变成了该页无法显示几个字。再过几个月，大学的网站不让上了，摄影师的网站不让上了，就连百度日本这种自家网站，也没了。 接着，漫画看不了了，接着，动画看不成了。接着，美剧英剧失踪了。下载美剧英剧的网站又又又失踪了。尊重正版，保护权益，行吧，然后字幕网站也没了。 游戏没了，你习惯性登陆的游戏网站，发现下载栏正在整治中。论坛关了，天天都在看的论坛，突然接到相关部门的电话，因为“报备问题”不让办了。个人网站，私人博客，对不起，说没就没有，你在上面存了多少多年辛勤耕耘的东西都没用。 你关注的人，有一天你登陆微博，发现他怎么好久都没说话了，然后你搜索了一下，发现他的账号不存在了，而且你搜他的名字，他的名字未予显示。 一盏一盏的灯，灭了。四面八方的光源，消失了。我们生活的五光十色的世界，变成了一片黑色。 天黑了，那么睡觉吧，但愿长醉不复醒。 最后，我们变成了一群做梦的人，这个梦的名字，叫根据相关法律法规，相关搜索结果不予显示梦。 作者：小海，来源：豆瓣网，原文已被和谐"},{"title":"ZOJ month contest D.Determinant and Matrix","permalink":"http://lishangying.github.io/2014/11/07/zoj-month-contest-d-determinant-and-matrix/","text":"Time Limit: 2 Seconds Memory Limit: 65536 KB ##DescriptionRecently, LBH is learning the curse linear algebra. Thus he is very interested in matrix and determinant now. In order to practice his ability of solving the problem of linear algebra, he just invent some problems by himself. Once the problems was create, he would solve it immediately. However, he meet a problem that was so hard that he couldn’t work out even though racked his brains. The problem was described as follow: To a integer martix Mnn(aij), we define two function add(Mnn(aij))=Mnn(aij + 1) and sub(Mnn(aij))=Mnn(aij - 1) which were exactly like this: DeterminantAndMatrixFig1 DeterminantAndMatrixFig2 According to the martix Mnn(aij), we can permutate it and get a full permutation set Perm(Mnn(aij)) = {Mnn(aIiJj)| I and J is a permutation of 1..n }, (Perm(M) is a set, each matrix in Perm(M) is unique). For example: DeterminantAndMatrixFig3 The problem is to get the result of a fomula about an integer matrix Mnn: DeterminantAndMatrixFig4 in which the det(M) meaned to cacluate the determinant of M. InputThere are several test cases. The first line contains an integer T(T ≤ 100) . Then T test cases follow. In each test case, the first line contains one integer n(0&lt; n≤ 10). The number means the giving matrix’s size is n×n Then there are n lines followed, each line contains n integers aij(-10≤ aij≤ 10), in the position row i, colum j, it represents the number aij. OutputFor each test case, since the result may be very large, output one line with the result modulo 230. Sample Input1234121 11 2 Sample Output12 Author: LIN, BinghuiSource: ZOJ Monthly, August 2014 这道题全场现场只A了一个人。今天我们比赛的时候我A了，挺爽的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import java.util.Scanner;import java.math.*;public class Main &#123; static long fact[]=new long[15]; static long kind; static int A[][]=new int[10][10]; static final BigInteger MOD=BigInteger.valueOf(1&amp;lt;&amp;lt;30); static void getKind(int n)&#123; boolean mark[]=new boolean[10]; for(int i,j,k,r=0;r&amp;lt;2;r++)&#123; for (i = 0; i &amp;lt; n; ++ i) mark[i] = false; for (i = 0; i &amp;lt; n; ++ i) &#123; if (mark[i]) continue; int cnt = 0; for (j = i; j &amp;lt; n; ++ j) &#123; for (k = 0; k &amp;lt; n; ++ k) &#123; if (r==1&amp;amp;&amp;amp;A[k][i] != A[k][j])break; if(r==0&amp;amp;&amp;amp;A[i][k] != A[j][k])break; &#125; if (k == n) &#123; ++ cnt; mark[j] = true; &#125; &#125; kind /= fact[cnt]; &#125; &#125; &#125; public static void main(String[] args)&#123; Scanner cin=new Scanner(System.in); int n,T=cin.nextInt(); fact[0]=1; for(int i=1;i&amp;lt;=10;i++)fact[i]=fact[i-1]*i; while(T--&amp;gt;0)&#123; n=cin.nextInt(); for(int i=0;i&amp;lt;n;i++)&#123; for(int j=0;j&amp;lt;n;j++)&#123; A[i][j]=cin.nextInt(); &#125; &#125; long res=0; Matrix matrix=new Matrix(n); kind=fact[n]*fact[n]; getKind(n); if(kind%2==1)&#123; matrix.valueOf(A, 0); res=res ^(matrix.Det().mod(MOD).longValue()); &#125; matrix.valueOf(A, 1); res=res^(matrix.Det().mod(MOD).longValue()); matrix.valueOf(A, -1); res=res^(matrix.Det().mod(MOD).longValue()); System.out.println(res); &#125; cin.close(); &#125;&#125;class Matrix&#123; BigInteger M[][]=new BigInteger[10][10]; BigInteger ZERO,ONE; int n; Matrix(int n)&#123; this.n=n; ZERO=BigInteger.ZERO; ONE=BigInteger.ONE; &#125; void valueOf(int A[][],int d)&#123; for(int i=0;i&amp;lt;n;i++)&#123; for(int j=0;j&amp;lt;n;j++)&#123; M[i][j]=BigInteger.valueOf(A[i][j]+d); &#125; &#125; &#125; BigInteger Det()&#123; BigInteger tmp, res = ONE, div = ONE; int i, j, k; for (i = 0; i &amp;lt; n; ++ i) &#123; for (j = i; j &amp;lt; n; ++ j) &#123; if (!M[j][i].equals(ZERO)) break; &#125; if (j == n) return ZERO; if (j != i) &#123; //res = res.negate(); for (k = 0; k &amp;lt; n; ++ k) &#123; tmp = M[j][k]; M[j][k] = M[i][k]; M[i][k] = tmp; &#125; &#125; res = res.multiply(M[i][i]); for (j = i + 1; j &amp;lt; n; ++ j) &#123; if (M[j][i].equals(ZERO)) continue; div = div.multiply(M[i][i]); for (k = i + 1; k &amp;lt; n; ++ k) &#123; M[j][k] = M[j][k].multiply(M[i][i]).subtract(M[i][k].multiply(M[j][i])); &#125; &#125; &#125; res = res.divide(div); if (res.compareTo(ZERO) &amp;lt; 0) res = res.negate(); return res; &#125;&#125;"},{"title":"FFT求快速卷积的思考","permalink":"http://lishangying.github.io/2014/11/06/fft-thoughts/","text":"离散型卷积的定义是：$$y(n)=\\sum_{m=0}^{n} x(m)h(n-m)$$ 注意，h函数是反转的。 在Chipher Messages一题中，b串需要反转再与a串匹配。 比如说： a串： 110110110，则： b`串：1011&lt;——这里才是原来b串的头。但是向上对应到a串时，已经是m-1这个位置了。所以说，小于m-1的卷积是没有意义的。 于是，base=m。整体匹配。 同样的，比如杭电1402用FFT求A×B那一题。 可以把A串看成卷积中的x函数，而把B串的每一个字符看成h函数。那么卷积就可以看成是一个模拟乘法的过程。 因为h函数是要求逆序的，但是此时的h函数只有一个字符所以反转操作无意义。这时候的base=1。单个匹配。 估计FFT就这两种情况了。因为如果1&lt;base&lt;m，那么就应该直接将b串分解成若干base长度的串了。"},{"title":"baylor 6622 Absurdistan Roads（ NWERC Contest）","permalink":"http://lishangying.github.io/2014/11/06/baylor6622-absurdistan-roads/","text":"原题pdf：click here ##DescriptionThe people of Absurdistan discovered how to build roads only last year. After the discovery, every citydecided to build their own road connecting their city with another city. Each newly built road can beused in both directions. Absurdistan is full of surprising coincidences. It took all N cities precisely one year to build theirroads. And even more surprisingly, in the end it was possible to travel from every city to every othercity using the newly built roads. You bought a tourist guide which does not have a map of the country with the new roads. It onlycontains a huge table with the shortest distances between all pairs of cities using the newly built roads. You would like to know between which pairs of cities there are roads and how long they are, becauseyou want to reconstruct the map of the N newly built roads from the table of shortest distances. You get a table of shortest distances between all pairs of cities in Absurdistan using the N roadsbuilt last year. From this table, you must reconstruct the road network of Absurdistan. There mightbe multiple road networks with N roads with that same table of shortest distances, but you are happywith any one of those networks. ##InputFor each test case: • A line containing an integer N (2 ≤ N ≤ 2000) — the number of cities and roads. • N lines with N numbers each. The j-th number of the i-th line is the shortest distance from city i to city j. • All distances between two distinct cities will be positive and at most 1 000 000. Thedistance from i to i will always be 0 and the distance from i to j will be the same as the distancefrom j to i. ##OutputFor each test case: • Print N lines with three integers ‘a b c’ denoting that there is a road between cities 1 ≤ a ≤ Nand 1 ≤ b ≤ N of length 1 ≤ c ≤ 1000000, where a ̸= b. If there are multiple solutions, you canprint any one and you can print the roads in any order. At least one solution is guaranteed toexist. • Print a blank line between every two test cases. ##Sample Input40 1 2 11 0 2 12 2 0 11 1 1 040 1 1 11 0 2 21 2 0 21 2 2 030 4 14 0 31 3 0 ##Sample Output2 1 14 1 14 2 14 3 12 1 13 1 14 1 12 1 13 1 12 1 43 2 3 NWERC 题目还挺简单的。题意就是一个N个顶点，N条边的无向图。告诉你两两点之间的最短路。让你重构这个图。(随意输出任意一张满足以上条件的图）这题的突破口就是N条边。要想想如果只有N-1条边，那么这个图就是一个树了。所以，我们可以先构造最小生成树，再来考虑最后一条边。可以先将构造好的树求一遍floyd，然后再跟题目的最短路相比较，如果两点u,v求出的最短路w`与题目给的最短路w不一致（可以断言：w`&gt;w），那么就将w作为最后一条边的边长加在u，v之间即可。这样的边可能会找到很多，事实上只需要加上任意一条就使所有的w`都等于w了。需要注意的是，可能整个树就已经满足题目了。这样的话，最后一条边只需要重复任意一条树边就好了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2010;const int inf = 1 &lt;&lt; 25;int p[N];int ufind(int x) &#123; return x == p[x] ? x : p[x] = ufind(p[x]);&#125;bool Union(int x, int y) &#123; int fx = ufind(x); int fy = ufind(y); if (fx == fy) return false; p[fx] = fy; return true;&#125;int n;struct Edge &#123; int u, v, w; Edge(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) &#123; &#125; bool operator&lt;(const Edge&amp; othr) const &#123; return w &lt; othr.w; &#125;&#125;;vector&lt;Edge&gt; vt;vector&lt;Edge&gt; res;int f[N][N];int main() &#123; bool first = true; while (~scanf(\"%d\", &amp;n)) &#123; vt.clear(); res.clear(); if (!first) printf(\"\\n\"); else first = false; for (int i = 1; i &lt;= n; i++) &#123; for (int x, j = 1; j &lt;= n; j++) &#123; scanf(\"%d\", &amp;x); if (j &gt; i) vt.push_back(Edge(i, j, x)); &#125; &#125; for (int i = 0; i &lt;= n; i++) p[i] = i; sort(vt.begin(), vt.end()); for(int i=1;i&lt;=n;i++) fill(f[i]+1,f[i]+1+n,inf); for (int cnt = 0, i = 0; i &lt; (int) vt.size(); i++) &#123; if (Union(vt[i].u, vt[i].v)) &#123; f[vt[i].u][vt[i].v] = vt[i].w; f[vt[i].v][vt[i].u] = vt[i].w; cnt++; res.push_back(Edge(vt[i].u, vt[i].v, vt[i].w)); if (cnt &gt;= n - 1) break; &#125; &#125; for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (f[i][k] == inf) break; if (f[i][j] &gt; f[i][k] + f[k][j]) &#123; f[i][j] = f[i][k] + f[k][j]; &#125; &#125; &#125; &#125; int flag = true; for (int i = 0; i &lt; (int) vt.size(); i++) &#123; Edge now = vt[i]; if (f[now.u][now.v] != now.w) &#123; res.push_back(Edge(now.u, now.v, now.w)); flag = false; break; &#125; &#125; if (flag) res.push_back(res.back()); for (int i = 0; i &lt; (int) res.size(); i++) &#123; printf(\"%d %d %d\\n\", res[i].u, res[i].v, res[i].w); &#125; &#125;&#125;"},{"title":"Timus 1996 Cipher Message 3 KMP+FFT求卷积","permalink":"http://lishangying.github.io/2014/11/05/timus-1996-cipher-message-3-kmpfft/","text":"题目链接：click here ##descriptionEmperor Palpatine has been ruling the Empire for 25 years and Darth Vader has been the head of the Empire Armed Forces. However, the Rebel movement is strong like it never used to be. One of the rebel leaders, Princess Leia from Alderaan, managed to get hold of secret blueprints of the Death Star, the imperial war station. The Princess was going to deliver the station plan to the secret base for further analysis and searching for vulnerable spots. But her ship was attacked by the space destroyer “Devastator” headed by Darth Vader. At the last moment Princess Leia managed to send her findings to one of the closest planet called Tatooine with her droid R2-D2. Quite conveniently, an old friend of her father Obi-Wan Kenobi lives on that planet. R2-D2 realizes the importance of his mission. He is going to encrypt the information so that the wrong people won’t get it.The memory of R2-D2 has many files with images. First he wanted to use a well-known encrypting algorithm. The point of the method is to replace the least significant bits of the image with the encrypted message bits. The difference is practically unnoticeable on the picture, so one won’t suspect that it contains a hidden message. But then R2-D2 decided that this method is quite well-known and the information won’t be protected enough. He decided to change the least significant bits of the image so that the secret information was a continuous sequence of the bytes of the image file. Help the droid determine if it is possible. And if it is, find the minimum number of bits to alter. InputThe first line of the input contains integers n and m (1 ≤ n, m ≤ 250 000) — the sizes of the image file and of the file with the secret information in bytes. On the second line the content of the file with an image is given and the third line contains the secret information. The files are given as a sequence of space-separated bytes. Each byte is written as a sequence of eight bits in the order from the most to the least significant bit. OutputPrint “No”, if it is impossible to encrypt information in this image. Otherwise, print in the first line “Yes”, and in the second line — the number of bits to alter and the number of the byte in the file with the image, starting from which the secret information will be recorded. If there are multiple possible variants, print the one where the secret information is written closer to the beginning of the image file. Samples input output 3 2 11110001 11110001 1111000011110000 11110000 Yes1 2 input output 3 111110000 11110001 1111000011110000 Yes0 1 Problem Author: Denis Dublennykh (prepared by Oleg Dolgorukov) 题目老长难懂，其实就是给你一个n byte的01A串，m byte的01B串.其中A串中每一byte的最后一个bit是可以修改的，问至少修改多少次A串能使B使A的子串。输出修改次数与最小的起始匹配位置。 首先将A串每byte取前7位（代码中的a数组）与B串每byte取前7位（代码中的b数组）用KMP匹配，因为前7位不能改，所以如果没有一处匹配就直接输出No了。 然后将A串每byte取后1位（代码中的ax数组）与B串每byte取后一位（代码中的bx数组）求hamming距离。 如何求ax与bx的hamming距离呢？ 可以巧妙的ax作为卷积中的f函数，bx的逆向数组bx`作为卷积中的g函数。两者求卷积。这样就成了：$$c[i + m - 1] = ax[i + 0] bx`[m - 0 - 1] + ax[i + 1] bx`[m - 1 - 1] + …… ax[i + j] bx`[m - j - 1] + …… ax[i + m - 1] bx`[m - (m - 1) - 1]$$ 可以看出，如果ax , bx中同为1,乘积为1,否则为0,这样就能统计出了有多少位同为1了。 如果将ax,bx数组中的01取反，再进行上述操作，那么救能统计出有多少位同为0了。两者相加就是全部相同的有多少，用总字符数m减去它，就能求出hamming距离了！ 卷积复杂度为O(nlg(n))而暴力算法的复杂度为O(n×m)，真是太神奇了！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161using namespace std;const int N = 250005;int n, m;const double pi = acos(-1.0);// Complex z = a + b * istruct Complex &#123; double x, y; Complex(double x = 0.0, double y = 0.0) : x(x), y(y) &#123; &#125; Complex operator +(const Complex &amp;amp;c) const &#123; return Complex(x + c.x, y + c.y); &#125; Complex operator -(const Complex &amp;amp;c) const &#123; return Complex(x - c.x, y - c.y); &#125; Complex operator *(const Complex &amp;amp;c) const &#123; return Complex(x * c.x - y * c.y, x * c.y + y * c.x); &#125;&#125;;int a[N], b[N], ax[N], bx[N];char buf[8];/* * kmpNext[]的意思:next'[i]=next[next[...[next[i]]]] (直到next'[i]&amp;lt;0或者 x[next'[i]]!=x[i]) * 这样的预处理可以快一些 */void preKMP(int x[], int m, int kmpNext[]) &#123; int i, j; j = kmpNext[0] = -1; i = 0; while (i &amp;lt; m) &#123; while (-1 != j &amp;amp;&amp;amp; x[i] != x[j]) j = kmpNext[j]; if (x[++i] == x[++j]) kmpNext[i] = kmpNext[j]; else kmpNext[i] = j; &#125;&#125;/* * 返回x在y中出现的次数,可以重叠 */int next[N];vector pos;void KMP_Count(int x[], int m, int y[], int n) &#123; //x是模式串,y是主串 int i, j; pos.clear(); preKMP(x, m, next); i = j = 0; while (i &amp;lt; n) &#123; while (-1 != j &amp;amp;&amp;amp; y[i] != x[j]) j = next[j]; i++; j++; if (j &amp;gt;= m) &#123; pos.push_back(i - m); j = next[j]; &#125; &#125;&#125;//len = 2 ^ kinline void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &amp;lt; len - 1; i++) &#123; if (i &amp;lt; j) swap(y[i], y[j]); int k = len / 2; while (j &amp;gt;= k) &#123; j -= k; k /= 2; &#125; if (j &amp;lt; k) j += k; &#125;&#125;// FFT// len = 2 ^ k// on = 1 DFT on = -1 IDFTinline void FFT(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &amp;lt;= len; h &amp;lt;&amp;lt;= 1) &#123; Complex wn(cos(-on * 2 * pi / h), sin(-on * 2 * pi / h)); for (int j = 0; j &amp;lt; len; j += h) &#123; Complex w(1, 0); for (int k = j; k &amp;lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t; y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) &#123; for (int i = 0; i &amp;lt; len; i++) &#123; y[i].x /= len; &#125; &#125;&#125;//FFT求卷积,a数组长度n，b数组长度mint res[N];Complex x1[N &amp;lt;&amp;lt; 2], x2[N &amp;lt;&amp;lt; 2]; //FFT开4倍void Convolution(int a[], int b[]) &#123; int len = max(n, m); int l = 1; while (l &amp;lt; len * 2) l &amp;lt;&amp;lt;= 1; for (int i = 0; i &amp;lt; l; i++) x1[i] = Complex(i &amp;lt; n ? a[i] : 0, 0); for (int i = 0; i &amp;lt; l; i++) x2[i] = Complex(i &amp;lt; m ? b[i] : 0, 0); //DFT FFT(x1, l, 1); FFT(x2, l, 1); for (int i = 0; i &amp;lt; l; i++) x1[i] = x1[i] * x2[i]; //IDFT FFT(x1, l, -1); //based on m int base = m ; for (int i = 0; i &amp;lt;= n - base; i++) &#123; res[i] += (int) (x1[i + base - 1].x + 0.5); &#125;&#125;int main() &#123; while (~scanf(\"%d%d\", &amp;amp;n, &amp;amp;m)) &#123; for (int i = 0; i &amp;lt; n; i++) &#123; a[i] = 0; scanf(\"%s\", buf); for (int j = 0; j &amp;lt; 7; j++) &#123; a[i] = a[i] &amp;lt;&amp;lt; 1 | (buf[j] - '0'); &#125; ax[i] = buf[7] - '0'; &#125; for (int i = 0; i &amp;lt; m; i++) &#123; b[i] = 0; scanf(\"%s\", buf); for (int j = 0; j &amp;lt; 7; j++) &#123; b[i] = b[i] &amp;lt;&amp;lt; 1 | (buf[j] - '0'); &#125; bx[i] = buf[7] - '0'; &#125; KMP_Count(b, m, a, n); if (pos.size() == 0) puts(\"No\"); else &#123; reverse(bx, bx + m); memset(res, 0, sizeof(res)); puts(\"Yes\"); Convolution(ax, bx); for (int i = 0; i &amp;lt; n; i++) ax[i] ^= 1; for (int i = 0; i &amp;lt; m; i++) bx[i] ^= 1; Convolution(ax, bx); int ans = m, idx = 0; for (int i = 0; i &amp;lt; (int) pos.size(); i++) &#123; if (m - res[pos[i]] &amp;lt; ans) &#123; ans = m - res[pos[i]]; idx = pos[i] + 1; &#125; &#125; printf(\"%d %d\\n\", ans, idx); &#125; &#125;&#125;"},{"title":"（转）关于卷积的一个血腥的讲解，看完给跪了","permalink":"http://lishangying.github.io/2014/11/05/intro-of-fft/","text":"比如说你的老板命令你干活，你却到楼下打台球去了，后来被老板发现，他非常气愤，扇了你一巴掌（注意，这就是输入信号，脉冲），于是你的脸上会渐渐地（贱贱地）鼓起来一个包，你的脸就是一个系统，而鼓起来的包就是你的脸对巴掌的响应，好，这样就和信号系统建立起来意义对应的联系。下面还需要一些假设来保证论证的严谨：假定你的脸是线性时不变系统，也就是说，无论什么时候老板打你一巴掌，打在你脸的同一位置（这似乎要求你的脸足够光滑，如果你说你长了很多青春痘，甚至整个脸皮处处连续处处不可导，那难度太大了，我就无话可说了哈哈），你的脸上总是会在相同的时间间隔内鼓起来一个相同高度的包来，并且假定以鼓起来的包的大小作为系统输出。好了，那么，下面可以进入核心内容——卷积了！如果你每天都到地下去打台球，那么老板每天都要扇你一巴掌，不过当老板打你一巴掌后，你5分钟就消肿了，所以时间长了，你甚至就适应这种生活了……如果有一天，老板忍无可忍，以0.5秒的间隔开始不间断的扇你的过程，这样问题就来了，第一次扇你鼓起来的包还没消肿，第二个巴掌就来了，你脸上的包就可能鼓起来两倍高，老板不断扇你，脉冲不断作用在你脸上，效果不断叠加了，这样这些效果就可以求和了，结果就是你脸上的包的高度随时间变化的一个函数了（注意理解）；如果老板再狠一点，频率越来越高，以至于你都辨别不清时间间隔了，那么，求和就变成积分了。可以这样理解，在这个过程中的某一固定的时刻，你的脸上的包的鼓起程度和什么有关呢？和之前每次打你都有关！但是各次的贡献是不一样的，越早打的巴掌，贡献越小，所以这就是说，某一时刻的输出是之前很多次输入乘以各自的衰减系数之后的叠加而形成某一点的输出，然后再把不同时刻的输出点放在一起，形成一个函数，这就是卷积，卷积之后的函数就是你脸上的包的大小随时间变化的函数。本来你的包几分钟就可以消肿，可是如果连续打，几个小时也消不了肿了，这难道不是一种平滑过程么？反映到剑桥大学的公式上，f(a)就是第a个巴掌，g(x-a)就是第a个巴掌在x时刻的作用程度，乘起来再叠加就ok了，大家说是不是这个道理呢？我想这个例子已经非常形象了，你对卷积有了更加具体深刻的了解了吗？ 转自GSDzone论坛"},{"title":"KDE4的配置参考","permalink":"http://lishangying.github.io/2014/10/31/kde4-config/","text":"西北工大回来后,时间又充裕了,所以又开始了折腾KDE。 话说KDE的渲染阴影等效果非常接近MacBook。先放几张图： [ 抓图14](http://sforkw-wp.qiniudn.com/jae/uploads/2014/10/抓图14-1024x575.png) [ 抓图15](http://sforkw-wp.qiniudn.com/jae/uploads/2014/10/抓图15-1024x575.png)](http://sforkw-wp.qiniudn.com/jae/uploads/2014/10/抓图15.png) [![抓图18](http://sforkw-wp.qiniudn.com/jae/uploads/2014/10/抓图18-1024x575.png) 下面说一下，我的配置过程： 发行版： 我的发行版是Arch，没有Arch强大的AUR，很多桌面的配件很难装上。 主题： 我的plasma主题是Helium与dynamo主题混合而成。标题栏主题是Qtcurve，图标主题是dynamo与flattr混合而成，鼠标主题是Breeze。应用程序主题是Qtcurve，配色是Breeze。这些都可以到这里下载。先安装qtcurve再将下载下来的文件解压并覆盖～/.kde4/share/即可。注意，Qtcurve的配置方案是Breeze，并且在窗口管理器中设置边框大小是无侧边框。 全局菜单： 全局菜单可以先加archlinuxcn源，然后依次用yaourt安装appmenu-qt,appmenu-qt5,appmenu-gtk,kdeplasma-applets-menubar。完成之后在面板上添加刚安装的部件再打开“系统设置&gt;应用程序外观&gt;风格”然后选择微调标签，修改“菜单栏风格”为“仅导出”就能有全局菜单了。 最大化隐藏菜单栏： 最大化隐藏菜单栏可以直接在qtCurve中配置，依然在“窗口管理器”中，勾选“最大化窗口无边框”复选框即可。 最大化上面板显示窗口控制按钮：（最后一张图鼠标所指的地方） 在AUR中安装kdeplasma-applets-kwin-button-improved，然后在面板上重复三次添加这个部件，分别设置为最小化（iconify），最大化/回复（maximize/restore）和关闭（close）就行了。"},{"title":"ACM International Collegiate Programming Contest Asia Regional Contest, Tokyo Problem D Space Golf","permalink":"http://lishangying.github.io/2014/10/19/acm-international-collegiate-programming-contest-asia-regional-contest-tokyo-problem-d-space-golf/","text":"原题pdf：click here 日本的亚洲区域赛真心简单啊。两个小时就刷了5题有余了。排名第一的队伍才做出7道。 题目真心长的可以了，看了半个小时才明白。。 题意其实也就是太空中向前方抛小球，问小球能够穿过N个障碍物后到达制定地点的最小初始速度是多少。非常暴力的模拟题。离散化后直接枚举弹跳的次数再取最小值即可。注意45°方向能成功的话，那还是45°最优。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define PR pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set::iterator#define VI(x) vector::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set::reverse_iterator#define VRI(x) vector::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;#define eps 1e-8/*start*/int d, n, b;PR ob[20];vector&amp;lt;pair&amp;lt;double, double&amp;gt; &amp;gt; vt;pair&amp;lt;double, double&amp;gt; dpr;double a[2][2], e[2];pair&amp;lt;double, double&amp;gt; Cramer(pair&amp;lt;double, double&amp;gt; dpr) &#123; pair&amp;lt;double, double&amp;gt; res; a[1][0] = dpr.F * dpr.F; a[1][1] = dpr.F; e[1] = dpr.S; double div = a[0][0] * a[1][1] - a[1][0] * a[0][1]; res.F = (e[0] * a[1][1] - e[1] * a[0][1]) / div; res.S = (e[1] * a[0][0] - e[0] * a[1][0]) / div; return res;&#125;int main(int argc, char **argv) &#123; while (~scanf(\"%d%d%d\", &amp;amp;d, &amp;amp;n, &amp;amp;b)) &#123; for (int i = 0; i &amp;lt; n; i++) &#123; scanf(\"%d%d\", &amp;amp;ob[i].F, &amp;amp;ob[i].S); &#125; double ans = inf; for (int c = 0; c &amp;lt;= b; c++) &#123;//enumerate the times bullet bounces the surface double dist = 1.0 * d / (c + 1); int f = 1; a[0][0] = dist * dist; a[0][1] = dist; e[0] = 0; vt.clear(); for (int i = 0; i &amp;lt; n; i++) &#123; dpr = ob[i]; while (dpr.F + eps &amp;gt;= dist) &#123; dpr.F -= dist; &#125; if (dpr.F &amp;lt;= eps) &#123; f = 0; break; &#125; vt.push_back(dpr); &#125; if (f == 0) continue; pair&amp;lt;double, double&amp;gt; res; for (int i = 0; i &amp;lt; Sz(vt); i++) &#123; dpr = vt[i]; if (i == 0) &#123; res = Cramer(dpr); &#125; else &#123; double tmph = dpr.F * dpr.F * res.F + dpr.F * res.S; if (tmph + eps &amp;lt; dpr.S) &#123; res = Cramer(dpr); &#125; &#125; &#125; res.F = -1.0 / (2 * res.F); res.S = res.F * res.S * res.S; ans = min(ans, sqrt(res.F + res.S)); //if the vector's angle is less than 45 if (res.S + eps &amp;lt; res.F) ans = min(ans, sqrt(dist)); &#125; printf(\"%.5f\\n\", ans); &#125;&#125;"},{"title":"优化Wine程序的字体显示","permalink":"http://lishangying.github.io/2014/10/13/wine-font-config/","text":"默认Wine的字体太难看，而且有时候还会显示不出来。开启Wine字体的反锯齿及平滑功能以及将字体映射成文泉驿微米黑的方法是： 1.新建文本文件a.reg，放入如下内容：12345678910111213141516171819202122232425262728293031323334353637REGEDIT4[HKEY_CURRENT_USER\\Software\\Wine\\X11 Driver]&quot;ClientSideAntiAliasWithCore&quot;=&quot;Y&quot;&quot;ClientSideAntiAliasWithRender&quot;=&quot;Y&quot;&quot;ClientSideWithRender&quot;=&quot;Y&quot;[HKEY_CURRENT_USER\\Control Panel\\Desktop]&quot;FontSmoothing&quot;=&quot;2&quot;&quot;FontSmoothingType&quot;=dword:00000002&quot;FontSmoothingGamma&quot;=dword:00000578&quot;FontSmoothingOrientation&quot;=dword:00000001[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes]&quot;Arial Baltic,186&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Arial CE,238&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Arial CYR,204&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Arial Greek,161&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Arial TUR,162&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Courier New Baltic,186&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Courier New CE,238&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Courier New CYR,204&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Courier New Greek,161&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Courier New TUR,162&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Helv&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Helvetica&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;MS Shell Dlg&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;MS Shell Dlg 2&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Tahoma&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Times&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Times New Roman Baltic,186&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Times New Roman CE,238&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Times New Roman CYR,204&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Times New Roman Greek,161&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Times New Roman TUR,162&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Tms Rmn&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Simsun&quot;=&quot;WenQuanYi Micro Hei&quot; 2.如果是普通的wine直接终端输入wine regedit打开注册表编辑器。然后点击“注册表—&gt;导入注册表文件”导入该文件。 3.如果是longene等封装好的wine（比如tm2013）可以使用tm2013 -reg命令打开注册表。"},{"title":"用Sublime Text 3 dev 做网页开发的配置","permalink":"http://lishangying.github.io/2014/09/16/sublime-config-web/","text":"文件：click here"},{"title":"我的xfce4配置","permalink":"http://lishangying.github.io/2014/09/16/xfce4-config/","text":"1.字体：infinally 渲染 2.英文字体：courier prime 3.窗口最大化隐藏标题栏：xfwm4-titleless-dev 4.窗口最大化标题栏隐藏后，在任务栏上显示控制按钮的插件：xfce4-windowck-plugin"},{"title":"HDU 4965 Fast Matrix Calculation","permalink":"http://lishangying.github.io/2014/08/19/hdu-4965-fast-matrix-calculation/","text":"Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others)Total Submission(s): 206 Accepted Submission(s): 116 Problem Description One day, Alice and Bob felt bored again, Bob knows Alice is a girl who loves math and is just learning something about matrix, so he decided to make a crazy problem for her. Bob has a six-faced dice which has numbers 0, 1, 2, 3, 4 and 5 on each face. At first, he will choose a number N (4 &lt;= N &lt;= 1000), and for N times, he keeps throwing his dice for K times (2 &lt;=K &lt;= 6) and writes down its number on the top face to make an NK matrix A, in which each element is not less than 0 and not greater than 5. Then he does similar thing again with a bit difference: he keeps throwing his dice for N times and each time repeat it for K times to write down a KN matrix B, in which each element is not less than 0 and not greater than 5. With the two matrix A and B formed, Alice’s task is to perform the following 4-step calculation.Step 1: Calculate a new NN matrix C = AB.Step 2: Calculate M = C^(N*N).Step 3: For each element x in M, calculate x % 6. All the remainders form a new matrix M’.Step 4: Calculate the sum of all the elements in M’. Bob just made this problem for kidding but he sees Alice taking it serious, so he also wonders what the answer is. And then Bob turn to you for help because he is not good at math. &nbsp; Input The input contains several test cases. Each test case starts with two integer N and K, indicating the numbers N and K described above. Then N lines follow, and each line has K integers between 0 and 5, representing matrix A. Then K lines follow, and each line has N integers between 0 and 5, representing matrix B. The end of input is indicated by N = K = 0. &nbsp; Output For each case, output the sum of all the elements in M’ in a line. &nbsp; Sample Input 4 2 5 5 4 4 5 4 0 0 4 2 5 5 1 3 1 5 6 3 1 2 3 0 3 0 2 3 4 4 3 2 2 5 5 0 5 0 3 4 5 1 1 0 5 3 2 3 3 2 3 1 5 4 5 2 0 0 &nbsp; Sample Output 14 56 &nbsp; Source 2014 Multi-University Training Contest 9 这题让我注意了矩阵模板的开销问题。1000X1000多次调用就会爆内存了。下面是用动态数组写的。效率非常慢，难以接受。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define PR pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;/*start*/#define MOD 6int n, k;struct Matrix &#123; int n, m; int** M; Matrix(int n, int m) :n(n), m(m) &#123; M = new int*[n]; for (int i = 0; i &amp;lt; n; i++) M[i] = new int[m]; &#125; Matrix(int n, int m, int k) : n(n), m(m) &#123; M = new int*[n]; for (int i = 0; i &amp;lt; n; i++) M[i] = new int[m]; Init(k); &#125; ~Matrix() &#123; if (M) &#123; for (int i = 0; i &amp;lt; n; i++) &#123; if (M[i]) &#123; delete[] M[i]; M[i] = NULL; &#125; &#125; delete[] M; M = NULL; &#125; &#125; void Init(bool k) &#123; //k=1 返回单位矩阵，k=0 返回零矩阵 for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) M[i][j] = k * (i == j); &#125; void out() &#123; for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) printf(\"%d%c\", M[i][j], j == m - 1 ? '\\n' : ' '); &#125; Matrix &amp;amp; operator=(const Matrix&amp;amp; othr) &#123; this-&amp;gt;~Matrix(); n = othr.n; m = othr.m; M = new int*[n]; for (int i = 0; i &amp;lt; n; i++) M[i] = new int[m]; for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; m; j++) &#123; M[i][j] = othr.M[i][j]; &#125; &#125; return *this; &#125; Matrix(const Matrix &amp;amp; othr) &#123; n = othr.n; m = othr.m; M = new int*[n]; for (int i = 0; i &amp;lt; n; i++) M[i] = new int[m]; for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; m; j++) &#123; M[i][j] = othr.M[i][j]; &#125; &#125; &#125; bool operator==(const Matrix&amp;amp; othr) const &#123; if (n - othr.n || m - othr.m) return false; for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; m; j++) &#123; if (M[i][j] != othr.M[i][j]) return false; &#125; &#125; return true; &#125; Matrix operator *(const Matrix&amp;amp; othr) const &#123; if (m - othr.n) exit(1); //异常退出 Matrix ans(n, othr.m, 0); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; othr.m; j++) for (int k = 0; k &amp;lt; m; k++) &#123; ans.M[i][j] += M[i][k] * othr.M[k][j] % MOD; if (ans.M[i][j] &amp;gt;= MOD) ans.M[i][j] -= MOD; if (ans.M[i][j] &amp;lt; 0) ans.M[i][j] += MOD; &#125; return ans; &#125; Matrix operator *(const int&amp;amp; x) const &#123; Matrix ans(n, m); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) ans.M[i][j] = M[i][j] * x % MOD; return ans; &#125; Matrix operator +(const Matrix &amp;amp; othr) const &#123; if (n - othr.n || m - othr.m) exit(1); Matrix ans(n, m); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) &#123; ans.M[i][j] = M[i][j] + othr.M[i][j]; if (ans.M[i][j] &amp;gt;= MOD) ans.M[i][j] -= MOD; if (ans.M[i][j] &amp;lt; 0) ans.M[i][j] += MOD; &#125; return ans; &#125; Matrix operator -(const Matrix&amp;amp; othr) const &#123; if (n - othr.n || m - othr.m) exit(1); Matrix ans(n, m); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) &#123; ans.M[i][j] = M[i][j] - othr.M[i][j]; if (ans.M[i][j] &amp;gt;= MOD) ans.M[i][j] -= MOD; if (ans.M[i][j] &amp;lt; 0) ans.M[i][j] += MOD; &#125; return ans; &#125; Matrix operator ^(int x) const &#123; if (n - m) exit(1); Matrix ans(n, m, 1), base = *this; while (x &amp;gt; 0) &#123; if (x &amp;amp; 1) ans = ans * base; base = base * base; x &amp;gt;&amp;gt;= 1; &#125; return ans; &#125;&#125;;int main(int argc, char **argv) &#123; while (~scanf(\"%d%d\", &amp;amp;n, &amp;amp;k)) &#123; if (n == 0 &amp;amp;&amp;amp; k == 0) break; Matrix A(n, k, 0), B(k, n, 0); for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; k; j++) &#123; scanf(\"%d\", &amp;amp;A.M[i][j]); &#125; &#125; for (int i = 0; i &amp;lt; k; i++) &#123; for (int j = 0; j &amp;lt; n; j++) &#123; scanf(\"%d\", &amp;amp;B.M[i][j]); &#125; &#125; Matrix mat = B * A; int r = n * n - 1; Matrix res = A * (mat ^ r) * B; int ans = 0; for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; n; j++) &#123; ans += res.M[i][j]; &#125; &#125; printf(\"%d\\n\", ans); &#125;&#125; 然后又试了试vector，虽然简单不少，但是仍然很慢：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define PR pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;/*start*/#define MOD 6int n, k;struct Matrix &#123; int n, m; vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;M; Matrix(int n, int m) :n(n), m(m) &#123; alloc(); &#125; Matrix(int n, int m, int k) : n(n), m(m) &#123; alloc(); Init(k); &#125; void alloc()&#123; M.resize(n); for (int i = 0; i &amp;lt; n; i++) M[i].resize(m); &#125; void Init(bool k) &#123; //k=1 返回单位矩阵，k=0 返回零矩阵 for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) M[i][j] = k * (i == j); &#125; void out() &#123; for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) printf(\"%d%c\", M[i][j], j == m - 1 ? '\\n' : ' '); &#125; bool operator==(const Matrix&amp;amp; othr) const &#123; if (n - othr.n || m - othr.m) return false; for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; m; j++) &#123; if (M[i][j] != othr.M[i][j]) return false; &#125; &#125; return true; &#125; Matrix operator *(const Matrix&amp;amp; othr) const &#123; if (m - othr.n) exit(1); //异常退出 Matrix ans(n, othr.m, 0); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; othr.m; j++) for (int k = 0; k &amp;lt; m; k++) &#123; ans.M[i][j] += M[i][k] * othr.M[k][j] % MOD; if (ans.M[i][j] &amp;gt;= MOD) ans.M[i][j] -= MOD; if (ans.M[i][j] &amp;lt; 0) ans.M[i][j] += MOD; &#125; return ans; &#125; Matrix operator *(const int&amp;amp; x) const &#123; Matrix ans(n, m); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) ans.M[i][j] = M[i][j] * x % MOD; return ans; &#125; Matrix operator +(const Matrix &amp;amp; othr) const &#123; if (n - othr.n || m - othr.m) exit(1); Matrix ans(n, m); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) &#123; ans.M[i][j] = M[i][j] + othr.M[i][j]; if (ans.M[i][j] &amp;gt;= MOD) ans.M[i][j] -= MOD; if (ans.M[i][j] &amp;lt; 0) ans.M[i][j] += MOD; &#125; return ans; &#125; Matrix operator -(const Matrix&amp;amp; othr) const &#123; if (n - othr.n || m - othr.m) exit(1); Matrix ans(n, m); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) &#123; ans.M[i][j] = M[i][j] - othr.M[i][j]; if (ans.M[i][j] &amp;gt;= MOD) ans.M[i][j] -= MOD; if (ans.M[i][j] &amp;lt; 0) ans.M[i][j] += MOD; &#125; return ans; &#125; Matrix operator ^(int x) const &#123; if (n - m) exit(1); Matrix ans(n, m, 1), base = *this; while (x &amp;gt; 0) &#123; if (x &amp;amp; 1) ans = ans * base; base = base * base; x &amp;gt;&amp;gt;= 1; &#125; return ans; &#125;&#125;;int main(int argc, char **argv) &#123; while (~scanf(\"%d%d\", &amp;amp;n, &amp;amp;k)) &#123; if (n == 0 &amp;amp;&amp;amp; k == 0) break; Matrix A(n, k, 0), B(k, n, 0); for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; k; j++) &#123; scanf(\"%d\", &amp;amp;A.M[i][j]); &#125; &#125; for (int i = 0; i &amp;lt; k; i++) &#123; for (int j = 0; j &amp;lt; n; j++) &#123; scanf(\"%d\", &amp;amp;B.M[i][j]); &#125; &#125; Matrix mat = B * A; int r = n * n - 1; Matrix res = A * (mat ^ r) * B; int ans = 0; for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; n; j++) &#123; ans += res.M[i][j]; &#125; &#125; printf(\"%d\\n\", ans); &#125;&#125; 感觉其他方法还比较麻烦。算了就这样吧~ &nbsp;"},{"title":"HDU 4952 Number Transformation","permalink":"http://lishangying.github.io/2014/08/15/hdu-4952-number-transformation/","text":"Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 612 Accepted Submission(s): 310 Problem Description Teacher Mai has an integer x. He does the following operations k times. In the i-th operation, x becomes the least integer no less than x, which is the multiple of i. He wants to know what is the number x now. &nbsp; Input There are multiple test cases, terminated by a line “0 0”. For each test case, the only one line contains two integers x,k(1&lt;=x&lt;=10^10, 1&lt;=k&lt;=10^10). &nbsp; Output For each test case, output one line “Case #k: x”, where k is the case number counting from 1. &nbsp; Sample Input 2520 10 2520 20 0 0 &nbsp; Sample Output Case #1: 2520 Case #2: 2600 &nbsp; Source 2014 Multi-University Training Contest 8 &nbsp; Recommend hujie | We have carefully selected several similar problems for you: 4955 4954 4953 4951 4950 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define PR pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;/*start*/int __;#define type LLinline type getint() &#123; type ret=0;bool ok=0; for(;;) &#123; int c=getchar(); if(c&amp;gt;='0'&amp;amp;&amp;amp;c&amp;lt;='9')ret=(ret&amp;lt;&amp;lt;3)+ret+ret+c-'0',ok=1; else if(ok)return ret; &#125;&#125;#undef typeint main(int argc, char **argv) &#123; LL x, k; while (1) &#123; x=getint(); k=getint(); if (x == 0 &amp;amp;&amp;amp; k == 0) break; for(int i=1;i&amp;lt;k;i++)&#123; if(x&amp;lt;i+1)break; x-=x/(i+1); &#125; printf(\"Case #%d: \"LLS\"\\n\",++__,x*k); &#125;&#125;"},{"title":"HDU 4945 2048","permalink":"http://lishangying.github.io/2014/08/15/hdu-4945-2048/","text":"Time Limit: 3000/1500 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 590 Accepted Submission(s): 136 Problem Description Teacher Mai is addicted to game 2048. But finally he finds it’s too hard to get 2048. So he wants to change the rule: You are given some numbers. Every time you can choose two numbers of the same value from them and merge these two numbers into their sum. And these two numbers disappear meanwhile. If we can get 2048 from a set of numbers with this operation, Teacher Mai think this multiset is good. You have n numbers, A1,…,An. Teacher Mai ask you how many subsequences of A are good. The number can be very large, just output the number modulo 998244353. &nbsp; Input There are multiple test cases, terminated by a line “0”. For each test case, the first line contains an integer n (1&lt;=n&lt;=10^5), the next line contains n integers ai (0&lt;=ai&lt;=2048). &nbsp; Output For each test case, output one line “Case #k: ans”, where k is the case number counting from 1, ans is the number module 998244353. &nbsp; Sample Input 4 1024 512 256 256 4 1024 1024 1024 1024 5 1024 512 512 512 1 0 &nbsp; Sample Output Case #1: 1 Case #2: 11 Case #3: 8 HintIn the first case, we should choose all the numbers. In the second case, all the subsequences which contain more than one number are good. &nbsp; &nbsp; Source 2014 Multi-University Training Contest 8 &nbsp; Recommend hujie | We have carefully selected several similar problems for you: 4955 4954 4953 4952 4951 貌似这几天第一次做的DP题啊。想象一下二进制就能明白——当子序列的2次幂数字之和大于等于2048时这个序列就是good序列了。正面dp要dp出2048~100000肯定要超时，而反面dp只需要dp出0~2047就够了。复杂度大大降低O（11＊2048*2048）。 标程写的很厉害！尤其是逆元的处理！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define PR pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;/*start*/#define MOD 998244353int cnt[3010];LL f[101000], g[101000];int pn, n, __;int dp[13][1025]; //表示取了2^0、2^1、2^2、……、2^i种元素，总和加起来等于j*2^(i+1)的所有情况inline int getint() &#123; int ret = 0; bool ok = 0; for (;;) &#123; int c = getchar(); if (c &amp;gt;= '0' &amp;amp;&amp;amp; c &amp;lt;= '9') ret = (ret &amp;lt;&amp;lt; 3) + ret + ret + c - '0', ok = 1; else if (ok) return ret; &#125;&#125;inline LL powmod(LL b, int x) &#123; LL res = 1; for (b %= MOD; x; x &amp;gt;&amp;gt;= 1) &#123; if (x &amp;amp; 1) res = res * b % MOD; b = b * b % MOD; &#125; return res;&#125;int main(int argc, char **argv) &#123; f[0] = 1; for (int i = 1; i &amp;lt;= 100000; i++) f[i] = f[i - 1] * i % MOD; g[100000] = powmod(f[100000], MOD - 2); for (int i = 99999; i &amp;gt;= 0; i--) g[i] = g[i + 1] * (i + 1) % MOD; while (1) &#123; n = getint(); if (n == 0) break; for (int k = 1; k &amp;lt;= 2048; k &amp;lt;&amp;lt;= 1) cnt[k] = 0; for (int i = 0; i &amp;lt; n; i++) &#123; cnt[getint()]++; &#125; pn = 0; for (int k = 1; k &amp;lt;= 2048; k &amp;lt;&amp;lt;= 1) pn += cnt[k]; for (int i = 0, m = 1024; i &amp;lt;= 11; i++, m &amp;gt;&amp;gt;= 1) &#123; for (int j = 0; j &amp;lt;= m; j++) &#123; dp[i][j] = 0; &#125; &#125; int ct = cnt[1]; LL cof = f[ct]; for (int i = 0; i &amp;lt;= ct &amp;amp;&amp;amp; i &amp;lt; 2048; i++) &#123; dp[0][i &amp;gt;&amp;gt; 1] += g[ct - i] * g[i] % MOD; if (dp[0][i &amp;gt;&amp;gt; 1] &amp;gt; MOD) dp[0][i &amp;gt;&amp;gt; 1] -= MOD; &#125; for (int i = 1, m = 1024; i &amp;lt;= 11; i++, m &amp;gt;&amp;gt;= 1) &#123; ct = cnt[1 &amp;lt;&amp;lt; i]; cof = cof * f[ct] % MOD; for (int j = 0; j &amp;lt; m; j++) &#123; if (dp[i - 1][j]) &#123; for (int k = 0; k &amp;lt;= ct &amp;amp;&amp;amp; j + k &amp;lt; m; k++) &#123;//不要把满足good的序列转移上去。 dp[i][(j + k) &amp;gt;&amp;gt; 1] += dp[i - 1][j] * g[k] % MOD * g[ct - k] % MOD; if (dp[i][(j + k) &amp;gt;&amp;gt; 1] &amp;gt; MOD) dp[i][(j + k) &amp;gt;&amp;gt; 1] -= MOD; &#125; &#125; &#125; &#125; int ans = (powmod(2, pn) - dp[11][0] * cof) % MOD * powmod(2, n - pn)%MOD; if (ans &amp;lt; 0) ans += MOD; printf(\"Case #%d: %d\\n\", ++__, ans); &#125;&#125;"},{"title":"我的HerbstluftWM","permalink":"http://lishangying.github.io/2014/08/14/herbustluftwm-config/","text":"一直以来想折腾一下WM，但是又感觉麻烦。前天把笔记本带到机房就借此机会在虚拟机中玩了一下。发现事实上比我想像的要简单的多。少量配置了一下两个配置文件就能用了。然后使用compton做透明特效。看起来也挺简洁美观的。 WM最大的特点就是轻便，herbstluftWM也不例外。安装只有几百兆，附加依赖少，几乎一个命令的事情。启动、响应速度都是普通DE无法比拟的快。加上compton的透明效果，稍加修饰整个系统的界面就非常美观了。 两个配置文件与更详细的说明我已经push到了github：click here"},{"title":"HDU 2874 Connections between cities","permalink":"http://lishangying.github.io/2014/08/13/hdu-2874-connections-between-cities/","text":"Connections between citiesTime Limit: 10000/5000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 4759 Accepted Submission(s): 1341 Problem Description After World War X, a lot of cities have been seriously damaged, and we need to rebuild those cities. However, some materials needed can only be produced in certain places. So we need to transport these materials from city to city. For most of roads had been totally destroyed during the war, there might be no path between two cities, no circle exists as well.Now, your task comes. After giving you the condition of the roads, we want to know if there exists a path between any two cities. If the answer is yes, output the shortest path between them. &nbsp; Input Input consists of multiple problem instances.For each instance, first line contains three integers n, m and c, 2&lt;=n&lt;=10000, 0&lt;=m&lt;10000, 1&lt;=c&lt;=1000000. n represents the number of cities numbered from 1 to n. Following m lines, each line has three integers i, j and k, represent a road between city i and city j, with length k. Last c lines, two integers i, j each line, indicates a query of city i and city j. &nbsp; Output For each problem instance, one line for each query. If no path between two cities, output “Not connected”, otherwise output the length of the shortest path between them. &nbsp; Sample Input 5 3 2 1 3 2 2 4 3 5 2 3 1 4 4 5 &nbsp; Sample Output Not connected 6 HintHint Huge input, scanf recommended. &nbsp; Source 2009 Multi-University Training Contest 8 - Host by BJNU 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define PR pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;/*start*/#define N 10004#define M 10005int n, m, c;struct Edge &#123; int v, w, nxt;&#125; e[M &amp;lt;&amp;lt; 1];int head[N], ecnt;void initEdge() &#123; memset(head, -1, sizeof(head)); ecnt = 0;&#125;void add(int u, int v, int w) &#123; e[ecnt].v = v; e[ecnt].w = w; e[ecnt].nxt = head[u]; head[u] = ecnt++;&#125;//RMQint dpM[20][N &amp;lt;&amp;lt; 1];int lg2[N &amp;lt;&amp;lt; 1];#define getL(R,L) (R-(L)+1)void initRMQ(int n) &#123; lg2[0] = -1; int m; for (int i = 1; i &amp;lt;= n; i++) lg2[i] = i &amp;amp; (i - 1) ? lg2[i - 1] : lg2[i - 1] + 1; for (int i = 1; i &amp;lt;= lg2[n]; i++) &#123; m = getL(n, 1 &amp;lt;&amp;lt; i); for (int j = 1; j &amp;lt;= m; j++) &#123; dpM[i][j] = min(dpM[i - 1][j], dpM[i - 1][j + (1 &amp;lt;&amp;lt; (i - 1))]); &#125; &#125;&#125;int getRMQ(int a, int b) &#123; if (a &amp;gt; b) swap(a, b); int s = lg2[b - a + 1]; return min(dpM[s][a], dpM[s][getL(b, 1 &amp;lt;&amp;lt; s)]);&#125;//LCAint E[N];int T[N];int H[N];int depth, cnt;int belong[N], bcnt;int findRoot() &#123; for (int i = 1; i &amp;lt;= n; i++) &#123; if (belong[i] == 0) return i; &#125; return -1;&#125;void getEuler(int u, int fa = -1) &#123; int tmp = dpM[0][H[u] = ++cnt] = ++depth; E[tmp] = u; belong[u] = bcnt; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; if (v == fa) continue; T[v] = T[u] + e[i].w; getEuler(v, u); dpM[0][++cnt] = tmp; &#125;&#125;void initLCA() &#123; memset(T, 0, sizeof(T)); memset(belong, 0, sizeof(belong)); bcnt = cnt = depth = 0; int root; while ((root = findRoot()) != -1) &#123; ++bcnt; getEuler(root); &#125; initRMQ(cnt);&#125;int getLCA(int u, int v) &#123; if (belong[u] != belong[v]) return -1; if (H[u] &amp;gt; H[v]) swap(u, v); return E[getRMQ(H[u], H[v])];&#125;int main(int argc, char **argv) &#123; while (~scanf(\"%d%d%d\", &amp;amp;n, &amp;amp;m, &amp;amp;c)) &#123; initEdge(); int u, v, w; for (int i = 1; i &amp;lt;= m; i++) &#123; scanf(\"%d%d%d\", &amp;amp;u, &amp;amp;v, &amp;amp;w); add(u, v, w); add(v, u, w); &#125; initLCA(); while (c--) &#123; scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); int r = getLCA(u, v); if (r == -1) puts(\"Not connected\"); else &#123; printf(\"%d\\n\", T[u] + T[v] - 2 * T[r]); &#125; &#125; &#125;&#125;"},{"title":"内网 2085马农","permalink":"http://lishangying.github.io/2014/08/13/zjnu2085/","text":"##Description 在观看完战马检阅之后，来自大草原的两兄弟决心成为超级“马农”，专门饲养战马。 兄弟两回到草原，将可以养马的区域，分为N*N的单位面积的正方形，并实地进行考察，归纳出了每个单位面积可以养马所获得的收益。接下来就要开始规划他们各自的马场了。 首先，两人的马场都必须是矩形区域。同时，为了方便两人互相照应，也为了防止马匹互相走散，规定两个马场的矩形区域相邻，且只有一个交点。最后，互不认输的两人希望两个马场的收益相当，这样才不会影响他们兄弟的感情。 现在，兄弟两找到你这位设计师，希望你给他们设计马场，问共有多少种设计方案。 ##Input 第一行一个整数N，表示整个草原的大小为N*N。 接下来N行，每行N个整数A(i,j)，表示第i行第j列的单位草地的收成。（注意：收益可能是负数，养马也不是包赚的，马匹也可能出现生病死亡等意外。） 1&lt;=N&lt;=50-1000&lt;A(i,j)&lt;1000 ##Output 输出符合两人要求的草原分配方案数。 ##Sample Input 3 1 2 3 4 5 6 7 8 9 ##Sample Output 2 ##Hint ##Source 2014宁波初中 T2 宁波镇海中学的罗方炜给我们组的一场比赛。 此题主要靠技巧。枚举中心点，然后用数组hash。注意数组清空复杂度很大，每次清空必定超时。应该用一个栈来记录更改的地方，直接赋0. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define PR pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;/*start*/#define N 55#define M 2500000int f[N][N],a[N][N];int h[M&amp;lt;&amp;lt;1|1];int st[N*N],top;int n,m;int main(int argc, char **argv) &#123; while(~scanf(\"%d\",&amp;amp;n))&#123; for (int i = 1; i &amp;lt;= n; ++i) &#123; for (int j = 1; j &amp;lt;= n; ++j) &#123; scanf(\"%d\",&amp;amp;a[i][j]); f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+a[i][j]; &#125; &#125; int res=top=0; for (int x = 1; x &amp;lt;= n; ++x) &#123; for (int y = 1; y &amp;lt;= n; ++y) &#123; for (int i = 1; i &amp;lt;= x; ++i) &#123; for (int j = 1; j &amp;lt;= y; ++j) &#123; st[top++]=f[x][y]-f[x][j-1]-f[i-1][y]+f[i-1][j-1]+M; h[st[top-1]]++; &#125; &#125; for (int i = x+1; i &amp;lt;= n; ++i) &#123; for (int j = y+1; j &amp;lt;= n; ++j) &#123; res+=h[f[i][j]-f[i][y]-f[x][j]+f[x][y]+M]; &#125; &#125; while(top)&#123; h[st[--top]]=0; &#125; for (int i = x; i &amp;lt;= n; ++i) &#123; for (int j = 1; j &amp;lt;= y; ++j) &#123; st[top++]=f[i][y]-f[x-1][y]-f[i][j-1]+f[x-1][j-1]+M; h[st[top-1]]++; &#125; &#125; for (int i = 1; i &amp;lt; x; ++i) &#123; for (int j = y+1; j &amp;lt;= n; ++j) &#123; res+=h[f[x-1][j]-f[x-1][y]-f[i-1][j]+f[i-1][y]+M]; &#125; &#125; while(top)&#123; h[st[--top]]=0; &#125; &#125; &#125; printf(\"%d\\n\",res); &#125;&#125;"},{"title":"内网2082 字母","permalink":"http://lishangying.github.io/2014/08/12/zjnu2082/","text":"##Description 乐乐开始学习英文字母了，小C为他准备了很多字母牌，每张牌有一个英文字母。有天乐乐把所有的牌排成一行，这些字母竟然形成了一个回文串。小C想知道，乐乐在排字母的时候，有多少种情况，最后的字母形成回文串。 ##Input 输入一行，表示乐乐有哪些字母，均大写。 ##Output 输出有多少种情况，排列的字母是一个回文串。 ##Sample InputAAAAB AABB CD ##Sample Output 1 2 0 ##Hint100%的数据，字母的个数不超过1000。 A(m,m)/(A(cnt1,cnt1)*A(cnt2,cnt2)…….) 主要是排列组合数的计算技巧。将n!分解质因数，然后上面的因子减去下面相同的因子，这样就不会因为计算阶乘而爆数组了。n!中质因数m的个数：n/m+n/m^2+n/m^3+n/m^4………123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include \"iostream\"#include \"cstdio\"#include \"cstring\"#include \"string\"#include \"vector\"using namespace std;#define sz(x) (int)x.size()#define DSIZE 10000#define clr(x,y) memset(x,y,sizeof(x));class BigInteger &#123;private: int a[1001]; bool sign; //true-p , false-n int len;public: BigInteger() &#123; len = 1; sign = true; clr(a, 0); a[0] = 1; &#125; void operator *=(int); friend ostream &amp;amp;operator&amp;lt;&amp;lt;(ostream &amp;amp;, const BigInteger &amp;amp;);&#125;;void BigInteger::operator*=(int x) &#123; if (x &amp;lt; 0) x = -x, sign ^= 1; for (int i = 0; i &amp;lt; len; i++) &#123; a[i] *= x; &#125; for (int i = 0; i &amp;lt; len; i++) &#123; if (a[i] &amp;gt;= DSIZE) &#123; a[i + 1] += a[i] / DSIZE; a[i] %= DSIZE; &#125; &#125; if (a[len]) len++;&#125;ostream &amp;amp;operator&amp;lt;&amp;lt;(ostream &amp;amp;out, const BigInteger &amp;amp;x) &#123; if (!x.sign &amp;amp;&amp;amp; x.len) putchar('-'); printf(\"%d\", x.a[x.len - 1]); for (int i = x.len - 2; i &amp;gt;= 0; i--) &#123; printf(\"%04d\", x.a[i]); &#125; return out;&#125;int n, m;int cnt[30];int prime[1001], tot;bool ok[1001];int faclist[1001];void getprime(int n) &#123; clr(ok, 0); tot = 0; for (int i = 2; i &amp;lt;= n; i++) &#123; if (!ok[i]) prime[tot++] = i; for (int j = 0; j &amp;lt; tot; j++) &#123; int now = i * prime[j]; if (now &amp;gt; n) break; ok[now] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;void getfact(int x) &#123; int s = x &amp;lt; 0 ? -x : x; for (int i = 0; prime[i] &amp;lt;= s; i++) &#123; for (int j = prime[i]; j &amp;lt;= s; j *= prime[i]) &#123; faclist[i] += x / j; &#125; &#125;&#125;char str[1001];int main() &#123; getprime(1000); while (~scanf(\"%s\",str)) &#123; n = strlen(str); clr(cnt, 0); for (int i = 0; i &amp;lt; n; i++) &#123; cnt[str[i] - 'A']++; &#125; int f = 0; m = 0; for (int i = 0; i &amp;lt; 26 &amp;amp;&amp;amp; f &amp;lt; 2; i++) &#123; if (cnt[i] &amp;amp; 1) f++; m += cnt[i] &amp;gt;&amp;gt;= 1; &#125; if (f &amp;gt; 1) &#123; printf(\"0\\n\"); continue; &#125; clr(faclist, 0); getfact(m); for (int i = 0; i &amp;lt; 26; i++) getfact(-cnt[i]); BigInteger res; for (int i = 0; prime[i] &amp;lt;= m; i++) &#123; for (int j = 0; j &amp;lt; faclist[i]; j++) &#123; res *= prime[i]; &#125; &#125; cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl; &#125;&#125;```language"},{"title":"HDU4944 FSF’s game","permalink":"http://lishangying.github.io/2014/08/12/hdu4944-fsfs-game/","text":"Time Limit: 9000/4500 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others)Total Submission(s): 166 Accepted Submission(s): 76 Problem Description FSF has programmed a game.In this game, players need to divide a rectangle into several same squares.The length and width of rectangles are integer, and of course the side length of squares are integer. After division, players can get some coins.If players successfully divide a AxB rectangle(length: A, width: B) into KxK squares(side length: K), they can get AB/ gcd(A/K,B/K) gold coins.In a level, you can’t get coins twice with same method.(For example, You can get 6 coins from 2x2(A=2,B=2) rectangle. When K=1, AB/gcd(A/K,B/K)=2; When K=2, AB/gcd(A/K,B/K)=4; 2+4=6; )There are N(N+1)/2 levels in this game, and every level is an unique rectangle. (1x1 , 2x1, 2x2, 3x1, …, Nx(N-1), NxN) FSF has played this game for a long time, and he finally gets all the coins in the game.Unfortunately ,he uses an UNSIGNED 32-BIT INTEGER variable to count the number of coins.This variable may overflow.We want to know what the variable will be.(In other words, the number of coins mod 2^32) &nbsp; Input There are multiply test cases. The first line contains an integer T(T&lt;=500000), the number of test cases Each of the next T lines contain an integer N(N&lt;=500000). &nbsp; Output Output a single line for each test case. For each test case, you should output “Case #C: “. first, where C indicates the case number and counts from 1. Then output the answer, the value of that UNSIGNED 32-BIT INTEGER variable. &nbsp; Sample Input 3 1 3 100 &nbsp; Sample Output Case #1: 1Case #2: 30Case #3: 15662489 HintIn the second test case, there are six levels(1x1,1x2,1x3,2x2,2x3,3x3) Here is the details for this game: 1x1: 1(K=1); 1x2: 2(K=1); 1x3: 3(K=1); 2x2: 2(K=1), 4(K=2); 2x3: 6(K=1); 3x3: 3(K=1), 9(K=3); 1+2+3+2+4+6+3+9=30 &nbsp; Author UESTC &nbsp; Source 2014 Multi-University Training Contest 7 &nbsp; Recommend We have carefully selected several similar problems for you: 4943 4942 4941 4940 4939 N(LogN)的复杂度。123456789101112131415161718192021222324#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;#define N 500001unsigned int f[N];unsigned int g[N];int n;int main() &#123; int T; for (int i = 1; i &amp;lt; N; i++) &#123; for (int j = 1; i * j &amp;lt; N; j++) &#123; g[i * j] += (1LL + j) * j / 2; &#125; &#125; f[1] = 1; for (int i = 2; i &amp;lt; N; i++) &#123; f[i] = f[i - 1] + i * g[i]; &#125; scanf(\"%d\", &amp;amp;T); for (int c = 1; c &amp;lt;= T; c++) &#123; scanf(\"%d\", &amp;amp;n); printf(\"Case #%d: %u\\n\", c, f[n]); &#125;&#125;"},{"title":"github使用札记","permalink":"http://lishangying.github.io/2014/08/10/github-tips/","text":"生成ssh key: ssh-keygen -t rsa -C &quot;stkevintan@foxmail.com&quot; 输入合适的密码。然后将生成的pub公钥粘贴到github上：click here 版本推送命令： ### Create a new repository on the command line touch README.md git init git add README.md git commit -m &quot;first commit&quot; git remote add origin &lt;span class=&quot;js-live-clone-url&quot;&gt;https://github.com/stkevintan/资源名.git&lt;/span&gt; &lt;span class=&quot;js-selectable-text&quot;&gt;git push -u origin master&lt;/span&gt;`&lt;/pre&gt; ### Push an existing repository from the command line &lt;pre&gt;`git remote add origin &lt;span class=&quot;js-live-clone-url&quot;&gt;https://github.com/stkevintan/资源名.git&lt;/span&gt; &lt;span class=&quot;js-selectable-text&quot;&gt;git push -u origin master&lt;/span&gt; 修改或删除passphrase。(Details)ssh-keygen -p"},{"title":"内网2073 城主GeassCode","permalink":"http://lishangying.github.io/2014/08/01/zjnu2073-geasscode/","text":"##Description GeassCode凭借自己在topcoder上的超凡表现，赢得了国王的喜爱，国王赏赐他一座城池。这座城池里有n个 村子，m条路连接这些村子。坐上城主的GeassCode决定要修路，他打算用最少的代价把所以的村子连在一起。据探子回报，有些村子之间虽然原来没有路 径，但是可以强行的去建一条路。GeassCode想知道，如果强行在某两个村子之间建一条路，最后的总花费是多少？ ##Input 输入一行三个整数n，m，表示有n个村子，m条可建路径。 2..m+1行，每行3个整数a,b,c（a≠b），表示可以在a和b村庄建一条花费为c的路径。 第m+2行一个整数q，表示有多少个询问。 接下来q个询问，每行3个整数a,b,c（a≠b），表示如果可以另外在a和b村庄建一条花费为c的路径，最终需要多少花费？ ##Output 对于每个询问输出，输出最少的花费。 ##Sample Input4 5 1 2 4 2 3 3 1 4 6 2 4 3 1 3 2 3 3 4 3 1 3 1 1 4 2 ##Sample Output8 7 7 ##Hintn的范围[2,50000],m的范围[2,100000],q的范围[1,50000]。 输入的m条边保证可以把所有村庄连在一起。输入的边权范围[1,106] ##Source 张超 解法是如果可以在(u,v)上再加条边，则将最小生成树上的(u,v)节点最短路径中的最大边权与要加上这条边的替换。如果新的花费比旧的花费少，则取新的花费。否则什么也不换，取旧的花费。 如何求树上两点之间的最短路径中的最大边权呢？ 可以按照这篇文章所述建一个类似于哈夫曼树，将点作为叶子，边的权值作为祖先构造一个N+N的树：click here 这样写的很容易错，尤其要区分两颗树的规模，我在这上面错了很久。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;#define N 50005#define M 100005int n, m ;struct Graph &#123; int u, v, w; bool mark; bool operator&amp;lt;(Graph othr) const &#123; return w &amp;lt; othr.w; &#125;&#125; g[M];//UnionSetint p[N + N];void initUset(int n) &#123; for (int i = 0; i &amp;lt;= n; i++) p[i] = i;&#125;int uFind(int x) &#123; return x == p[x] ? p[x] : p[x] = uFind(p[x]);&#125;void uMerge(int x, int y) &#123; //y合并到x int fx = uFind(x); int fy = uFind(y); if (fx != fy) p[fy] = fx;&#125;//Edge Graphint head[N + N], pos;struct Edge &#123; int v, nxt;&#125; e[N + N];void initEdge() &#123; memset(head, -1, sizeof(head)); pos = 0;&#125;void add(int u, int v) &#123; e[pos].v = v; e[pos].nxt = head[u]; head[u] = pos++;&#125;int size;vector&amp;lt;pr&amp;lt;int, int&amp;gt; &amp;gt; query[N];int qw[N];bool vis[N];int lca[N];int val[N + N];int dfs(int u) &#123; int solved = 0; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; solved += dfs(v); if (size == solved) return solved; uMerge(u, v); &#125; if(~val[u])return solved; vis[u] = 1; for (int i = 0; i &amp;lt; (int) query[u].size(); i++) &#123; int v = query[u][i].F; if (vis[v]) &#123; solved++; lca[query[u][i].S] = uFind(v); &#125; &#125; return solved;&#125;void tarjan() &#123; initUset(n); clrA(vis, 0); dfs(n);&#125;void rebuild() &#123; clrA(val, -1); initUset(n + n); initEdge(); for (int i = 1; i &amp;lt;= m; i++) &#123; if (g[i].mark == false) continue; val[++n] = g[i].w; int fu = uFind(g[i].u); int fv = uFind(g[i].v); p[fu] = n; p[fv] = n; add(n, fu); add(n, fv); &#125;&#125;int main() &#123; while (~scanf(\"%d%d\", &amp;amp;n, &amp;amp;m)) &#123; for (int i = 1; i &amp;lt;= m; i++) &#123; scanf(\"%d%d%d\", &amp;amp;g[i].u, &amp;amp;g[i].v, &amp;amp;g[i].w); g[i].mark = false; &#125; sort(g + 1, g + 1 + m); initUset(n); LL sum = 0; for (int i = 1; i &amp;lt;= m; i++) &#123; int fx = uFind(g[i].u); int fy = uFind(g[i].v); if (fx != fy) &#123; sum += g[i].w; g[i].mark = true; p[fy] = fx; &#125; &#125; for (int i = 1; i &amp;lt;= n; i++) query[i].clear(); scanf(\"%d\", &amp;amp;size); int u, v, w; for (int i = 1; i &amp;lt;= size; i++) &#123; scanf(\"%d%d%d\", &amp;amp;u, &amp;amp;v, &amp;amp;w); qw[i] = w; query[u].push_back(MP(v, i)); query[v].push_back(MP(u, i)); &#125; rebuild(); tarjan(); for (int i = 1; i &amp;lt;= size; i++) &#123; LL ans = sum - val[lca[i]] + qw[i]; printf(LLS\"\\n\", min(ans, sum)); &#125; &#125;&#125; 其实，可以直接在dfs的回溯过程中将子节点的max求出来。这样简单多了。感叹一句：并查集真神奇！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set&amp;lt;x &amp;gt;::iterator#define VI(x) vector&amp;lt;x &amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y &amp;gt;::iterator#define SRI(x) set&amp;lt;x &amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x &amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y &amp;gt;::reverse_iterator#define F first#define S second#define clrQ(x) while(!x.empty())x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;#define N 50005#define M 100005int n, m;struct Graph &#123; int u, v, w; bool operator&amp;lt;(Graph othr) const &#123; return w &amp;lt; othr.w; &#125;&#125; g[M];struct Pair &#123; int x, y; Pair(int x, int y) : x(x), y(y) &#123; &#125; ;&#125;;//Edge Graphint head[N], pos;struct Edge &#123; int v, w, nxt;&#125; e[N &amp;lt;&amp;lt; 1];void initEdge() &#123; memset(head, -1, sizeof(head)); pos = 0;&#125;void add(int u, int v, int w) &#123; e[pos].v = v; e[pos].w = w; e[pos].nxt = head[u]; head[u] = pos++;&#125;//UnionSetint p[N];int pmax[N];void initUset() &#123; for (int i = 0; i &amp;lt;= n; i++) p[i] = i;&#125;int uFind(int x) &#123; if (x != p[x]) &#123; int t = p[x]; p[x] = uFind(p[x]); pmax[x] = max(pmax[x], pmax[t]); return p[x]; &#125; return x;&#125;void uMerge(int x, int y) &#123; //y合并到x int fx = uFind(x); int fy = uFind(y); if (fx != fy) &#123; p[fy] = fx; pmax[fy] = max(pmax[fy], pmax[fx]); &#125;&#125;int size;vector&amp;lt;Pair&amp;gt; query[N];vector&amp;lt;Pair&amp;gt; mark[N];int qw[N];bool vis[N];int lca[N];void dfs(int u, int fa) &#123; if (size == 0) return; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; if (v == fa) continue; dfs(v, u); pmax[v] = max(pmax[v], e[i].w); uMerge(u, v); &#125; vis[u] = 1; for (int i = 0; i &amp;lt; (int) query[u].size(); i++) &#123; int v = query[u][i].x; if (vis[v]) &#123; mark[uFind(v)].push_back(Pair(u, i)); &#125; &#125; if (!mark[u].empty()) &#123; for (VI(Pair)it=mark[u].begin();it!=mark[u].end();++it) &#123; int uu = it-&amp;gt;x; int vv = query[it-&amp;gt;x][it-&amp;gt;y].x; int ss = query[it-&amp;gt;x][it-&amp;gt;y].y; uFind(uu); uFind(vv); lca[ss] = max(pmax[uu], pmax[vv]); size--; &#125; mark[u].clear(); &#125;&#125;int findRoot() &#123; for (int i = 1; i &amp;lt;= n; i++) &#123; if (!vis[i]) return i; &#125; return assert(false), -1;&#125;void tarjan() &#123; initUset(); clrA(vis, 0); clrA(pmax, 0); size = m; dfs(findRoot(), -1);&#125;int main() &#123; while (~scanf(\"%d%d\", &amp;amp;n, &amp;amp;m)) &#123; for (int i = 1; i &amp;lt;= m; i++) &#123; scanf(\"%d%d%d\", &amp;amp;g[i].u, &amp;amp;g[i].v, &amp;amp;g[i].w); &#125; sort(g + 1, g + 1 + m); initUset(); initEdge(); LL sum = 0; for (int i = 1; i &amp;lt;= m; i++) &#123; int fx = uFind(g[i].u); int fy = uFind(g[i].v); if (fx != fy) &#123; sum += g[i].w; add(g[i].u, g[i].v, g[i].w); add(g[i].v, g[i].u, g[i].w); p[fy] = fx; &#125; &#125; for (int i = 1; i &amp;lt;= n; i++) &#123; query[i].clear(); mark[i].clear(); &#125; scanf(\"%d\", &amp;amp;m); int u, v, w; for (int i = 1; i &amp;lt;= m; i++) &#123; scanf(\"%d%d%d\", &amp;amp;u, &amp;amp;v, &amp;amp;w); qw[i] = w; query[u].push_back(Pair(v, i)); query[v].push_back(Pair(u, i)); &#125; tarjan(); for (int i = 1; i &amp;lt;= m; i++) &#123; LL tmp = sum - lca[i] + qw[i]; printf(LLS\"\\n\", min(tmp, sum)); &#125; &#125;&#125;"},{"title":"POJ1989 Distance Queries","permalink":"http://lishangying.github.io/2014/08/01/poj1989-distance-queries/","text":"##Description Farmer John’s cows refused to run in his marathon since he chose a path much too long for their leisurely lifestyle. He therefore wants to find a path of a more reasonable length. The input to this problem consists of the same input as in “Navigation Nightmare”,followed by a line containing a single integer K, followed by K “distance queries”. Each distance query is a line of input containing two integers, giving the numbers of two farms between which FJ is interested in computing distance (measured in the length of the roads along the path between the two farms). Please answer FJ’s distance queries as quickly as possible! ##Input Lines 1..1+M: Same format as “Navigation Nightmare” Line 2+M: A single integer, K. 1 &lt;= K &lt;= 10,000 Lines 3+M..2+M+K: Each line corresponds to a distance query and contains the indices of two farms. ##Output Lines 1..K: For each distance query, output on a single line an integer giving the appropriate distance. ##Sample Input 7 61 6 13 E6 3 9 E3 5 7 S4 1 3 N2 4 20 W4 7 2 S31 61 42 6 ##Sample Output13336 ##HintFarms 2 and 6 are 20+3+13=36 apart. ##SourceUSACO 2004 February 无向树求节点距离：dist(u,v)=dist(root,u)+dist(root,v)-2*dist(root,lca(u,v)) tarjan+并查集求LCA。注意可能树不连通。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define MP make_pair#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SI(x) set&amp;lt;x&amp;gt;::iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;#define N 40005#define M 40005int n, m;//Edge Graphint head[N], pos;struct Edge &#123; int v, w, nxt;&#125; e[M &amp;lt;&amp;lt; 1];void initEdge() &#123; memset(head, -1, sizeof(head)); pos = 0;&#125;void add(int u, int v, int w) &#123; e[pos].v = v; e[pos].w = w; e[pos].nxt = head[u]; head[u] = pos++;&#125;//UnionSetint p[N];void initUset() &#123; for (int i = 0; i &amp;lt;= n; i++) p[i] = i;&#125;int uFind(int x) &#123; return x == p[x] ? p[x] : p[x] = uFind(p[x]);&#125;void uMerge(int x, int y) &#123; //y合并到x int fx = uFind(x); int fy = uFind(y); if (fx != fy) p[fy] = fx;&#125;//tarjan-LCAint size,bcnt;int lca[10005];int vis[N];int dis[N];int ans[10005];vector&amp;lt;pr&amp;lt;int, int&amp;gt; &amp;gt; query[N];int findRoot() &#123; for (int i = 1; i &amp;lt;= n; i++) &#123; if (!vis[i]) return i; &#125; return assert(false),-1;&#125;int dfs(int u, int fa) &#123; int solved = 0; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; if (v == fa) continue; dis[v] = dis[u] + e[i].w; solved += dfs(v, u); if (solved == size) return solved; uMerge(u, v); &#125; vis[u] = bcnt; for (int i = 0; i &amp;lt; (int) query[u].size(); i++) &#123; int v = query[u][i].F; if (vis[v]==bcnt) &#123; solved++; lca[query[u][i].S] = uFind(v); ans[query[u][i].S] = dis[u] + dis[v] - 2 * dis[lca[query[u][i].S]]; &#125; &#125; return solved;&#125;void tarjan() &#123; clrA(vis, 0); clrA(dis, 0); int tot = 0; bcnt=0; do &#123; bcnt++;//从1开始 tot += dfs(findRoot(), -1); &#125; while (tot &amp;lt; size);//图可能不连通&#125;int main() &#123; while (~scanf(\"%d%d\", &amp;amp;n, &amp;amp;m)) &#123; int u, v, w; char c; initEdge(); for (int i = 1; i &amp;lt;= m; i++) &#123; scanf(\"%d%d%d %c\", &amp;amp;u, &amp;amp;v, &amp;amp;w, &amp;amp;c); add(u, v, w); add(v, u, w); &#125; initUset(); scanf(\"%d\", &amp;amp;size); for (int i = 1; i &amp;lt;= n; i++) query[i].clear(); for (int i = 1; i &amp;lt;= size; i++) &#123; scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); query[u].push_back(MP(v, i)); query[v].push_back(MP(u, i)); &#125; tarjan(); for (int i = 1; i &amp;lt;= size; i++) &#123; printf(\"%d\\n\", ans[i]); &#125; &#125;&#125; 另外，还可以转化为RMQ问题求解：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;#define N 40005#define M 40005int n, m;//Edge Graphint head[N], pos;struct Edge &#123; int v, w, nxt;&#125; e[M &amp;lt;&amp;lt; 1];void initEdge() &#123; memset(head, -1, sizeof(head)); pos = 0;&#125;void add(int u, int v, int w) &#123; e[pos].v = v; e[pos].w = w; e[pos].nxt = head[u]; head[u] = pos++;&#125;//RMQint dpM[20][N&amp;lt;&amp;lt;1|1];//dpM[i][j] 从j开始的，连续2^i个数字的最值,j从1开始int lg2[N&amp;lt;&amp;lt;1|1];//等价于 (int)lg2(1.0*m)/lg2(2.0) 若空间不足可以这样写#define getLeft(R,L) (R-(L)+1) //输入右端点和长度，返回左端点void initRMQ(int n) &#123; lg2[0]=-1;int limit; for(int i=1;i&amp;lt;=n;i++) &#123; lg2[i]=(i&amp;amp;(i-1))?lg2[i-1]:lg2[i-1]+1; &#125; for(int i=1;i&amp;lt;=lg2[n];i++)&#123; limit=getLeft(n,1&amp;lt;&amp;lt;i); for(int j=1;j&amp;lt;=limit;j++)&#123; dpM[i][j]=min(dpM[i-1][j],dpM[i-1][j+(1&amp;lt;&amp;lt;i&amp;gt;&amp;gt;1)]); &#125; &#125;&#125;int getRMQ(int a,int b) &#123; int t=lg2[b-a+1]; int s1=a; int s2=getLeft(b,1&amp;lt;&amp;lt;t); //return max(Max[t][s1],Max[t][s2]); return min(dpM[t][s1],dpM[t][s2]);&#125;#undef getLeft//LCAint dist[N];int H[N];//节点第一次出现的位置int E[N&amp;lt;&amp;lt;1|1];//欧拉序列2n+1个int cnt,depth;int findRoot()&#123; for(int i=1;i&amp;lt;=n;i++)return i; return -1;&#125;void getEuler(int u=findRoot(),int fa=-1)&#123; int tmp=dpM[0][H[u]=++cnt]=++depth; E[tmp]=u; for(int i=head[u];~i;i=e[i].nxt)&#123; int v=e[i].v; if(v==fa)continue; dist[v]=dist[u]+e[i].w; getEuler(v,u); dpM[0][++cnt]=tmp; &#125;&#125;void initLCA()&#123; memset(dist,0,sizeof(dist)); cnt=depth=0; getEuler(); initRMQ(cnt);&#125;int getLCA(int u,int v)&#123; if(H[u]&amp;gt;H[v])swap(u,v); return E[getRMQ(H[u],H[v])];&#125;int main() &#123; while (~scanf(\"%d%d\", &amp;amp;n, &amp;amp;m)) &#123; int u, v, w; char c; initEdge(); for (int i = 1; i &amp;lt;= m; i++) &#123; scanf(\"%d%d%d %c\", &amp;amp;u, &amp;amp;v, &amp;amp;w, &amp;amp;c); add(u, v, w); add(v, u, w); &#125; initLCA(); scanf(\"%d\",&amp;amp;m); while(m--)&#123; scanf(\"%d%d\",&amp;amp;u,&amp;amp;v); printf(\"%d\\n\",dist[u]+dist[v]-2*dist[getLCA(u,v)]); &#125; &#125;&#125;"},{"title":"POJ1330 Nearest Common Ancestors","permalink":"http://lishangying.github.io/2014/08/01/poj1330-nearest-common-ancestors/","text":"Time Limit: 1000MS Memory Limit: 10000KTotal Submissions: 17734 Accepted: 9405 ##DescriptionA rooted tree is a well-known data structure in computer science and engineering. An example is shown below: In the figure, each node is labeled with an integer from {1, 2,…,16}. Node 8 is the root of the tree. Node x is an ancestor of node y if node x is in the path between the root and node y. For example, node 4 is an ancestor of node 16. Node 10 is also an ancestor of node 16. As a matter of fact, nodes 8, 4, 10, and 16 are the ancestors of node 16. Remember that a node is an ancestor of itself. Nodes 8, 4, 6, and 7 are the ancestors of node 7. A node x is called a common ancestor of two different nodes y and z if node x is an ancestor of node y and an ancestor of node z. Thus, nodes 8 and 4 are the common ancestors of nodes 16 and 7. A node x is called the nearest common ancestor of nodes y and z if x is a common ancestor of y and z and nearest to y and z among their common ancestors. Hence, the nearest common ancestor of nodes 16 and 7 is node 4. Node 4 is nearer to nodes 16 and 7 than node 8 is.For other examples, the nearest common ancestor of nodes 2 and 3 is node 10, the nearest common ancestor of nodes 6 and 13 is node 8, and the nearest common ancestor of nodes 4 and 12 is node 4. In the last example, if y is an ancestor of z, then the nearest common ancestor of y and z is y. Write a program that finds the nearest common ancestor of two distinct nodes in a tree. ##InputThe input consists of T test cases. The number of test cases (T) is given in the first line of the input file. Each test case starts with a line containing an integer N , the number of nodes in a tree, 2&lt;=N&lt;=10,000. The nodes are labeled with integers 1, 2,…, N. Each of the next N -1 lines contains a pair of integers that represent an edge –the first integer is the parent node of the second integer. Note that a tree with N nodes has exactly N - 1 edges. The last line of each test case contains two distinct integers whose nearest common ancestor is to be computed. ##OutputPrint exactly one line for each test case. The line should contain the integer that is the nearest common ancestor. ##Sample Input 2161 148 510 165 94 68 44 101 136 1510 116 710 216 38 116 1216 752 33 43 11 53 5 ##Sample Output 43 ##SourceTaejon 2002 tarjan+并查集求LCA模板。将u的子儿子v递归合并到u，若y在x的子树上，则根据并查集的性质，公共祖先即为x（father[y]）。若y和x不再同一子树上。则根据dfs回溯的性质，则搜完y之后一定是回溯到x,y的最近公共祖先才能搜到x的，而此时由并查集的性质，回溯的节点刚好就是father[y]。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define MP make_pair#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SI(x) set&amp;lt;x&amp;gt;::iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf=~0u&amp;gt;&amp;gt;1;const LL lnf=~0ull&amp;gt;&amp;gt;1;#define N 10005#define M 10005int n, m;//UnionSetint p[N];void initUset() &#123; for (int i = 0; i &amp;lt;= n; i++) p[i] = i;&#125;int uFind(int x) &#123; return x == p[x] ? p[x] : p[x] = uFind(p[x]);&#125;void uMerge(int x, int y) &#123; //y合并到x int fx = uFind(x); int fy = uFind(y); if (fx != fy) p[fy]=fx;&#125;//Edge Graphint head[N], pos;struct Edge &#123; int v, nxt;&#125; e[M];void initEdge() &#123; memset(head, -1, sizeof(head)); pos = 0;&#125;void add(int u, int v) &#123; e[pos].v = v; e[pos].nxt = head[u]; head[u] = pos++;&#125;int findRoot()&#123;//有向图选择入度为0的点，无向图不同节点做根，LCA结果将不同。 for (int i = 1; i &amp;lt; n; i++) if (indeg[i] == 0) return i; return assert(false),-1;&#125;//LCAint size, root;int vis[N];int ans[5];int indeg[N];vector&amp;lt;pr&amp;lt;int, int&amp;gt; &amp;gt; que[N];int dfs(int u) &#123; int solved=0; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; solved+=dfs(v); if(solved==size)return solved; uMerge(u, v); &#125; vis[u] = 1; for (int i = 0; i &amp;lt; (int) que[u].size(); i++) &#123; int v = que[u][i].F; if (vis[v]) &#123; ans[que[u][i].S] = uFind(v); solved++; &#125; &#125; return solved;&#125;void tarjan() &#123; clrA(vis,0); dfs(findRoot());&#125;int main() &#123; int T; scanf(\"%d\", &amp;amp;T); while (T--) &#123; scanf(\"%d\", &amp;amp;n); initEdge(); int u, v; clrA(indeg,0); for (int i = 1; i &amp;lt; n; i++) &#123; scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); add(u, v); indeg[v]++; &#125; initUset(); size = 1;//查询的次数 for(int i=1;i&amp;lt;=n;i++)que[i].clear(); for (int i = 1; i &amp;lt;= size; i++) &#123; scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); que[u].push_back(MP(v, i)); que[v].push_back(MP(u, i)); &#125; tarjan(); for (int i = 1; i &amp;lt;= size; i++) &#123; printf(\"%d\\n\", ans[i]); &#125; &#125;&#125; LCA还可以用倍增来求：（思想很普通，只是以2进制的步长向上走：dp[i][j]表示节点i向上走2^j步到达的节点。）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define qlr(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;#define N 10005#define M N-1int n;int head[N], pos;struct edge &#123; int v, nxt;&#125; e[M];void add(int u, int v) &#123; e[pos].v = v; e[pos].nxt = head[u]; head[u] = pos++;&#125;void initEdge() &#123; clr(head, -1); pos = 0;&#125;int deep[N];vector&amp;lt;int&amp;gt; dp[N];int size;int findRoot() &#123; for (int i = 1; i &amp;lt;= n; i++) &#123; if (dp[i].empty()) return i; &#125; return -1;&#125;void getDeep(int u = findRoot()) &#123; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; deep[v] = deep[u] + 1; getDeep(v); &#125; size = max(size, deep[u] + 1);//记录最大深度&#125;void initLCA() &#123; clr(deep, 0); size = 0; getDeep(); for (int len = 1,t=2;t&amp;lt;=size; len++,t&amp;lt;&amp;lt;=1) &#123;//跳出条件：(t=2^len)&amp;lt;=size for (int i = 1; i &amp;lt;= n; i++) &#123; if ((int)dp[i].size() &amp;gt;= len &amp;amp;&amp;amp; (int)dp[dp[i][len-1]].size() &amp;gt;= len) &#123; dp[i].push_back(dp[dp[i][len-1]][len-1]); &#125; &#125; &#125;&#125;int getLCA(int u, int v) &#123; if (deep[u] &amp;lt; deep[v]) swap(u, v); int d = deep[u] - deep[v]; for (int i = 0; d; i++, d &amp;gt;&amp;gt;= 1) &#123; u = d &amp;amp; 1 ? dp[u][i] : u; &#125;//以差值二进制形式将u往上走差值 if (u == v) return u; for (int i = min(dp[u].size(),dp[v].size())-1; i &amp;gt;= 0; i--) &#123; if (dp[u][i] != dp[v][i]) &#123; u = dp[u][i]; v = dp[v][i]; i=(int)min(dp[u].size(),dp[v].size());//注意每次都要更新i！！ &#125; &#125; u = dp[u][0]; return u;&#125;int main() &#123; int T; cin &amp;gt;&amp;gt; T; while (T--) &#123; scanf(\"%d\", &amp;amp;n); int u, v; initEdge(); for (int i = 1; i &amp;lt;= n; i++) dp[i].clear(); for (int i = 1; i &amp;lt; n; i++) &#123; scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); add(u, v); dp[v].push_back(u); &#125; initLCA(); scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); printf(\"%d\\n\", getLCA(u, v)); &#125;&#125; LCA还可以转化为RMQ问题（个人更喜欢此方法，在线，且效率高）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//============================================================================// Name : test3.cpp// Author : // Version :// Copyright : Your copyright notice// Description : Hello World in C++, Ansi-style//============================================================================#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;int n, m;#define N 10005#define M 10005int head[N], pos;struct Edge &#123; int v, nxt;&#125; e[M];void initEdge() &#123; memset(head, -1, sizeof(head)); pos = 0;&#125;void add(int u, int v) &#123; e[pos].v = v; e[pos].nxt = head[u]; head[u] = pos++;&#125;//RMQint dpM[20][N &amp;lt;&amp;lt; 1 | 1];int lg2[N &amp;lt;&amp;lt; 1 | 1];#define getLeft(R,L) (R-(L)+1)void initRMQ(int n) &#123; //dp[0][i]表示区间i的值。预先处理出来。 lg2[0] = -1; int limit; for (int i = 1; i &amp;lt;= n; i++) &#123; lg2[i] = i &amp;amp; (i - 1) ? lg2[i - 1] : lg2[i - 1] + 1; &#125; for (int i = 1; i &amp;lt;= lg2[n]; i++) &#123; limit = getLeft(n, 1 &amp;lt;&amp;lt; i); for (int j = 1; j &amp;lt;= limit; j++) &#123; dpM[i][j] = min(dpM[i - 1][j], dpM[i - 1][j + (1 &amp;lt;&amp;lt; (i - 1))]); &#125; &#125;&#125;int getRMQ(int x, int y) &#123; if (x &amp;gt; y) swap(x, y); int t = lg2[y - x + 1]; return min(dpM[t][x], dpM[t][getLeft(y, 1 &amp;lt;&amp;lt; t)]);&#125;//LCAint depth, cnt;int inde[N], H[N], E[N];//dp[0][N&amp;lt;&amp;lt;1|1]深度序列（dfs编号），E[N]每个dfs编号对应的节点，H[N]节点第一次出现在dfs编号序列中的位置int findRoot() &#123; for (int i = 1; i &amp;lt;= n; i++) if (!inde[i]) return i; return -1;&#125;void getEuler(int u = findRoot()) &#123; int dfn = dpM[0][H[u] = ++cnt] = ++depth; E[dfn] = u; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; getEuler(v); dpM[0][++cnt] = dfn; &#125;&#125;void initLCA() &#123; depth = cnt = 0; getEuler(); initRMQ(cnt);&#125;int getLCA(int u, int v) &#123; if (H[u] &amp;gt; H[v]) swap(u, v); return E[getRMQ(H[u], H[v])];&#125;int main() &#123; int T; scanf(\"%d\", &amp;amp;T); while (T--) &#123; scanf(\"%d\", &amp;amp;n);m=n-1; int u, v; initEdge(); memset(inde, 0, sizeof(inde)); for (int i = 1; i &amp;lt;= m; i++) &#123; scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); add(u, v); inde[v]++; &#125; initLCA(); scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); printf(\"%d\\n\", getLCA(u, v)); &#125;&#125; &nbsp;"},{"title":"2014 Multi-University Training Contest 4","permalink":"http://lishangying.github.io/2014/07/31/2014-multi-university-training-contest-4/","text":"心情就像倒数第二楼那样。 CLJ，我也保证不打死你…… PS:最后一楼朱大神还暴露了。"},{"title":"HDU4005 The war","permalink":"http://lishangying.github.io/2014/07/30/hdu4005-the-war/","text":"Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65768/65768 K (Java/Others)Total Submission(s): 1992 Accepted Submission(s): 440 Problem DescriptionIn the war, the intelligence about the enemy is very important. Now, our troop has mastered the situation of the enemy’s war zones, and known that these war zones can communicate to each other directly or indirectly through the network. We also know the enemy is going to build a new communication line to strengthen their communication network. Our task is to destroy their communication network, so that some of their war zones can’t communicate. Each line has its “cost of destroy”. If we want to destroy a line, we must spend the “cost of destroy” of this line. We want to finish this task using the least cost, but our enemy is very clever. Now, we know the network they have already built, but we know nothing about the new line which our enemy is going to build. In this condition, your task is to find the minimum cost that no matter where our enemy builds the new line, you can destroy it using the fixed money. Please give the minimum cost. For efficiency, we can only destroy one communication line.&nbsp;InputThe input contains several cases. For each cases, the first line contains two positive integers n, m (1&lt;=n&lt;=10000, 0&lt;=m&lt;=100000) standing for the number of the enemy’s war zones (numbered from 1 to n), and the number of lines that our enemy has already build. Then m lines follow. For each line there are three positive integer a, b, c (1&lt;=a, b&lt;=n, 1&lt;=c&lt;=100000), meaning between war zone A and war zone B there is a communication line with the “cost of destroy “ c.&nbsp;OutputFor each case, if the task can be finished output the minimum cost, or output ‐1.&nbsp;Sample Input3 2 1 2 1 2 3 2 4 3 1 2 1 1 3 2 1 4 3&nbsp;Sample Output-1 3HintFor the second sample input: our enemy may build line 2 to 3, 2 to 4, 3 to 4. If they build line 2 to 3, we will destroy line 1 to 4, cost 3. If they build line 2 to 4, we will destroy line 1 to 3, cost 2. If they build line 3 to 4, we will destroy line 1 to 2, cost 1. So, if we want to make sure that we can destroy successfully, the minimum cost is 3.&nbsp;&nbsp;Source The 36th ACM/ICPC Asia Regional Dalian Site —— Online Contest 求无向图边双连通分量缩点，然后DP求第二长边。//#pragma comment(linker, “/STACK:1024000000,1024000000”)//C++加栈#include#include#include#include#include#include#include#include#include#include#includeusing namespace std;#if defined (_WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32)#define LL int64#define LLS “%” “I” “6” “4” “d”#define LLU “%” “I” “6” “4” “u”#define LL_MAX _I64_MAX#else#define LL long long#define LLS “%” “l” “l” “d”#define LLU “%” “l” “l” “u”#define LL_MAX _I64_MAX#endif#define N 10005#define M 100005int n, m;const int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;struct edge { int v, w, nxt; bool mark;} e[M &lt;&lt; 1];struct bridge { int u, v, w; bridge(int u, int v, int w) { this-&gt;u = u; this-&gt;w = w; this-&gt;v = v; }};int pos, head[N];int top, stk[N];int pre[N], dfs_clock, belong[N], bcnt;vector brg;void InitEdge() { memset(head, -1, sizeof(head)); pos = 0;}void add(int u, int v, int w) { e[pos].v = v; e[pos].w = w; e[pos].nxt = head[u]; head[u] = pos++;}int dfs(int u,int fa) { int lowu = pre[u] = ++dfs_clock; stk[top++] = u; bool vis=true; for (int i = head[u]; ~i; i = e[i].nxt) { int v = e[i].v; if(v==fa &amp;&amp; vis){ vis=false;//重边 continue; } if (!pre[v]) { int lowv = dfs(v,u); lowu = min(lowu, lowv); if (lowv &gt; pre[u]) { //u-v为桥 brg.push_back(bridge(u, v, e[i].w)); } } else lowu = min(lowu, pre[v]); } if (pre[u] == lowu) { bcnt++; do { belong[stk[–top]] = bcnt; } while (stk[top] != u); } return lowu;}void tarjan() { top = bcnt = dfs_clock = 0; memset(pre, 0, sizeof(pre)); memset(belong, 0, sizeof(belong)); brg.clear(); for (int i = 1; i &lt;= n; i++) { if (!pre[i])dfs(i,-1); }}void rebuild() { //根据桥来缩点重构图 InitEdge(); for (int i = 0; i &lt; (int) brg.size(); i++) { int u = belong[brg[i].u]; int v = belong[brg[i].v]; int w = brg[i].w; add(u, v, w); add(v, u, w); }}int res;int DP(int u, int fa) { int Min = inf; for (int i = head[u]; ~i; i = e[i].nxt) { int v = e[i].v; if (v == fa)continue; int w = DP(v, u); w = min(w, e[i].w); if (Min &gt; w) { res = min(res, Min); Min = w; } else res = min(res, w); } return Min;}int main() { while (~scanf(“%d%d”, &amp;n, &amp;m)) { int u, v, w; InitEdge(); for (int i = 0; i &lt; m; i++) { scanf(“%d%d%d”, &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); } tarjan(); rebuild(); bridge minbrg(-1, -1, inf); for (int i = 0; i &lt; (int) brg.size(); i++) { if (brg[i].w &lt; minbrg.w) { minbrg = brg[i]; } } res = inf; DP(belong[minbrg.u], belong[minbrg.v]); DP(belong[minbrg.v], belong[minbrg.u]); if(res==inf)res=-1; printf(“%d\\n”, res); }}"},{"title":"HDU4612 Warm up","permalink":"http://lishangying.github.io/2014/07/30/hdu4612-warm-up/","text":"Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65535/65535 K (Java/Others)Total Submission(s): 3532 Accepted Submission(s): 813 Problem Description N planets are connected by M bidirectional channels that allow instant transportation. It’s always possible to travel between any two planets through these channels.If we can isolate some planets from others by breaking only one channel , the channel is called a bridge of the transportation system.People don’t like to be isolated. So they ask what’s the minimal number of bridges they can have if they decide to build a new channel.Note that there could be more than one channel between two planets. Input The input contains multiple cases.Each case starts with two positive integers N and M , indicating the number of planets and the number of channels.(2&lt;=N&lt;=200000, 1&lt;=M&lt;=1000000)Next M lines each contains two positive integers A and B, indicating a channel between planet A and B in the system. Planets are numbered by 1..N.A line with two integers ‘0’ terminates the input. Output For each case, output the minimal number of bridges after building a new channel in a line. Sample Input 4 4 1 2 1 3 1 4 2 3 0 0 Sample Output 0 Source 2013 Multi-University Training Contest 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#pragma comment(linker, \"/STACK:1024000000,1024000000\")//C++加栈#include#include#include#include#include#include#include#include&lt;map&gt;#include#include#includeusing namespace std;#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endif#define N 200005#define M 1000005int n, m;const int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;struct edge &#123; int v, nxt;&#125; e[M &amp;lt;&amp;lt; 1];struct bridge &#123; int u, v; bridge(int u, int v) &#123; this-&amp;gt;u = u; this-&amp;gt;v = v; &#125;&#125;;int pos, head[N];int top, stk[N];int pre[N], dfs_clock, belong[N], bcnt;vector brg;void InitEdge() &#123; memset(head, -1, sizeof(head)); pos = 0;&#125;void add(int u, int v) &#123; e[pos].v = v; e[pos].nxt = head[u]; head[u] = pos++;&#125;int dfs(int u, int fa) &#123; int lowu = pre[u] = ++dfs_clock; stk[top++] = u; bool vis = true; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; if (v == fa &amp;amp;&amp;amp; vis) &#123; vis = false; //u-v的反向边一定是v-u邻接表里的第一条边。 continue; &#125; if (!pre[v]) &#123; int lowv = dfs(v, u); lowu = min(lowu, lowv); if (lowv &amp;gt; pre[u]) &#123; //u-v为桥 brg.push_back(bridge(u, v)); &#125; &#125; else lowu = min(lowu, pre[v]); &#125; if (pre[u] == lowu) &#123; bcnt++; do &#123; belong[stk[--top]] = bcnt; &#125; while (stk[top] != u); &#125; return lowu;&#125;void tarjan() &#123; top = bcnt = dfs_clock = 0; memset(pre, 0, sizeof(pre)); memset(belong, 0, sizeof(belong)); brg.clear(); for (int i = 1; i &amp;lt;= n; i++) &#123; if (!pre[i]) dfs(i, -1); &#125;&#125;void rebuild() &#123; //根据桥来缩点重构图 InitEdge(); for (int i = 0; i &amp;lt; (int) brg.size(); i++) &#123; int u = belong[brg[i].u]; int v = belong[brg[i].v]; add(u, v); add(v, u); &#125;&#125;int diameter = 0;int findR(int u, int fa) &#123; int h1 = 0, h2 = 0; // 以u为根，h1最高的儿子，h2次高儿子。放在dfs里面两者不会重合。 for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; if (v == fa) continue; int h = findR(v, u) + 1; //若路径有权重，则把1改为u-v的权重 if (h &amp;gt; h1) h2 = h1, h1 = h; else h2 = max(h, h2); &#125; diameter = max(diameter, h1 + h2); return h1;&#125;void tree_diameter() &#123; diameter = 0; findR(1, -1);&#125;int main() &#123; while (scanf(\"%d%d\", &amp;amp;n, &amp;amp;m), n || m) &#123; int u, v; InitEdge(); for (int i = 0; i &amp;lt; m; i++) &#123; scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); add(u, v); add(v, u); &#125; tarjan(); rebuild(); tree_diameter(); printf(\"%d\\n\", bcnt - diameter - 1); &#125;&#125;"},{"title":"HDU4888 Redraw Beautiful Drawings ","permalink":"http://lishangying.github.io/2014/07/29/hdu4888-redraw-beautiful-drawings/","text":"Problem Description Alice and Bob are playing together. Alice is crazy about art and she has visited many museums around the world. She has a good memory and she can remember all drawings she has seen.Today Alice designs a game using these drawings in her memory. First, she matches K+1 colors appears in the picture to K+1 different integers(from 0 to K). After that, she slices the drawing into grids and there are N rows and M columns. Each grid has an integer on it(from 0 to K) representing the color on the corresponding position in the original drawing. Alice wants to share the wonderful drawings with Bob and she tells Bob the size of the drawing, the number of different colors, and the sum of integers on each row and each column. Bob has to redraw the drawing with Alice’s information. Unfortunately, somtimes, the information Alice offers is wrong because of Alice’s poor math. And sometimes, Bob can work out multiple different drawings using the information Alice provides. Bob gets confused and he needs your help. You have to tell Bob if Alice’s information is right and if her information is right you should also tell Bob whether he can get a unique drawing. &nbsp; Input The input contains mutiple testcases.For each testcase, the first line contains three integers N(1 ≤ N ≤ 400) , M(1 ≤ M ≤ 400) and K(1 ≤ K ≤ 40).N integers are given in the second line representing the sum of N rows.M integers are given in the third line representing the sum of M columns.The input is terminated by EOF. &nbsp; Output For each testcase, if there is no solution for Bob, output “Impossible” in one line(without the quotation mark); if there is only one solution for Bob, output “Unique” in one line(without the quotation mark) and output an N * M matrix in the following N lines representing Bob’s unique solution; if there are many ways for Bob to redraw the drawing, output “Not Unique” in one line(without the quotation mark). &nbsp; Sample Input 2 2 4 4 2 4 2 4 2 2 2 2 5 0 5 4 1 4 3 9 1 2 3 3 &nbsp; Sample Output Not Unique Impossible Unique 1 2 3 3&nbsp; 第一步，考虑如何求是否有解。使用网络流求解，每一行和每一列分别对应一个点，加上源点和汇点一共有N+M+2个点。有三类边： 源点 -&gt; 每一行对应的点，流量限制为该行的和 每一行对应的点 -&gt; 每一列对应的点，流量限制为 K 每一列对应的点 -&gt; 汇点，流量限制为该列的和&nbsp; 对上图做最大流，若源点出发的边和到达汇点的边全都满流，则有解，否则无解。若要求构造方案，则 (i,j) 对应的整数就是行 i–&gt; 列 j 的流量。 第二步，考虑解是否唯一。显然，解唯一的充分必要条件是完成最大流后的残余网络没有长度大于 2 的环。所以，判断解的唯一性可使用dfs，注意遍历的时候不可以在走完一条边后马上走其反向边，加此限制检查是否有环即可判断解是否唯一。 至此，全题已解决。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cstdlib&amp;gt;using namespace std;const int maxn=500,maxm=maxn*maxn;int next[maxm*2],num[maxm*2],r[maxm*2],a[maxn*2],row_sum[maxn],col_sum[maxn],n,m,K,tt,T,d[maxn*2],st[maxn*2],cod[maxn][maxn];int h[maxn*2],vh[maxn*2];bool don[maxm*2],in[maxn*2];void insert(int x,int y,int rr)&#123; next[++tt]=a[x];num[tt]=y;r[tt]=rr;a[x]=tt; next[++tt]=a[y];num[tt]=x;r[tt]=0;a[y]=tt;&#125;void construct()&#123; tt=1;T=n+m+1; for (int i=0;i&amp;lt;=T;i++) a[i]=0; for (int i=1;i&amp;lt;=n;i++) insert(0,i,row_sum[i]); for (int i=1;i&amp;lt;=m;i++) insert(i+n,T,col_sum[i]); for (int i=1;i&amp;lt;=n;i++) &#123; for (int j=1;j&amp;lt;=m;j++) &#123; insert(i,j+n,K); cod[i][j]=tt; &#125; &#125;&#125;int dfs(int x,int y)&#123; if (x==T) return y; int sig=st[x],minh=T+1; do &#123; if (r[st[x]]) &#123; if (h[num[st[x]]]+1==h[x]) &#123; int k=dfs(num[st[x]],min(y,r[st[x]])); if (k) &#123; r[st[x]]-=k; r[st[x]^1]+=k; return k; &#125; &#125; minh=min(minh,h[num[st[x]]]+1); if (h[0]&amp;gt;T) return 0; &#125; st[x]=next[st[x]]; if (st[x]==0) st[x]=a[x]; &#125;while (sig!=st[x]); if (vh[h[x]]--==0) h[0]=T+1; vh[h[x]=minh]++; return 0;&#125;int max_flow()&#123; for (int i=0;i&amp;lt;=T;i++) h[i]=vh[i]=0; for (int i=0;i&amp;lt;=T;i++) st[i]=a[i]; vh[0]=T+1; int ret=0; while (h[0]&amp;lt;=T) ret+=dfs(0,K+1); return ret;&#125;/*bool find_circle()&#123; deque q; for (int i=0;i&amp;lt;=T;i++) d[i]=0; for (int i=0;i&amp;lt;=T;i++) &#123; for (int p=a[i];p;p=next[p]) &#123; if (r[p]) d[i]++; &#125; if (d[i]==0) q.push_back(i); &#125; int cnt=T+1; while (!q.empty()) &#123; int x=q.front(); cnt--; q.pop_front(); for (int p=a[x];p;p=next[p]) &#123; if (r[p^1]) &#123; d[num[p]]--; if (d[num[p]]==0) q.push_back(num[p]); &#125; &#125; &#125; return cnt;&#125;*/bool visit(int x,int ed)&#123; if (don[ed]) return in[x]; don[ed]=true; in[x]=true; for (int p=a[x];p;p=next[p]) &#123; if (r[p] &amp;amp;&amp;amp; (ed^p)!=1) if (visit(num[p],p)) return true; &#125; in[x]=false; return false;&#125;bool find_circle()&#123; for (int i=0;i&amp;lt;=T;i++) in[i]=false; for (int i=1;i&amp;lt;=tt;i++) don[i]=false; int col=0; for (int i=2;i&amp;lt;=tt;i++) &#123; if (r[i] &amp;amp;&amp;amp; !don[i]) &#123; in[num[i^1]]=true; if (visit(num[i],i)) return true; in[num[i^1]]=false; &#125; &#125; return false;&#125;void print_scheme()&#123; printf(\"Unique\\n\"); for (int i=1;i&amp;lt;=n;i++) &#123; printf(\"%d\",r[cod[i][1]]); for (int j=2;j&amp;lt;=m;j++) printf(\" %d\",r[cod[i][j]]); printf(\"\\n\"); &#125;&#125;int main()&#123; while (scanf(\"%d%d%d\",&amp;amp;n,&amp;amp;m,&amp;amp;K)!=EOF) &#123; int tmp=0; for (int i=1;i&amp;lt;=n;i++) &#123; scanf(\"%d\",&amp;amp;row_sum[i]); tmp+=row_sum[i]; &#125; int sum=tmp; for (int i=1;i&amp;lt;=m;i++) &#123; scanf(\"%d\",&amp;amp;col_sum[i]); tmp-=col_sum[i]; &#125; if (tmp) &#123; printf(\"Impossible\\n\"); continue; &#125; construct(); if (max_flow()&amp;lt;sum) &#123; printf(\"Impossible\\n\"); continue; &#125; if (find_circle()) &#123; printf(\"Not Unique\\n\"); &#125;else print_scheme(); &#125; return 0;&#125;"}]}