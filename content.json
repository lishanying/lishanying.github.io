{"pages":[{"title":"关于我","permalink":"http://lishangying.github.io/about/index.html","text":"一个热衷于造轮子的少年，喜欢： Python Javascript Go 同时我也喜欢： Doctor Who Chopin &amp;&amp; Rachmaninov 我的联系方式： Telegram: @kevinsfork Github： stkevintan Twttier: Kevinsfork Mail: &#115;&#116;&#107;&#101;&#118;&#105;&#x6e;&#x74;&#97;&#x6e;&#x40;&#x7a;&#x6a;&#x75;&#x2e;&#101;&#100;&#117;&#x2e;&#x63;&#x6e;"},{"title":"categories","permalink":"http://lishangying.github.io/categories/index.html","text":""},{"title":"tags","permalink":"http://lishangying.github.io/tags/index.html","text":""}],"posts":[{"title":"函数作为参数传递","permalink":"http://lishangying.github.io/2018/01/10/函数作为参数传递/","text":"1.普通函数体现：一个函数作为另外一个函数的参数，进行函数传递，当然可以通过这种形式进行函数重载。 方式1：函数类型将函数作为基本类型，形如int a，int 是类型，a是形参；int f(int, int )，int (int ，int)是类型，f是形参；缺点：该种类型的写法太繁琐 #include&lt;iostream&gt; using namespace std; int add(int a,int b){ return a+b; } int F(int f(int,int),int a,int b){ return f(a,b); } int main(){ cout&lt;&lt;F(add,1,2)&lt;&lt;endl;//3 } 方式2：函数指针用typedefine重新定义一种指针，该指针指向类型为int (int ,int)的函数。形参为p注意，函数指针 = 函数名，所以，执行函数的时候，不用解指针！！！ #include&lt;iostream&gt; using namespace std; typedef int (*pf)(int,int); // int add(int a,int b){ return a+b; } int F(pf p,int a,int b){// return p(a,b);// } int main(){ cout&lt;&lt;F(add,1,2)&lt;&lt;endl;//3 } 方式3：定义新类型用typedefine重新定义一种新类型 #include&lt;iostream&gt; using namespace std; typedef int FuncType(int,int); //定义了FuncType这种函数数据类型 int add(int a,int b){ return a+b; } int F(FuncType tf,int a,int b) {// return tf(a,b);// } int main(){ cout&lt;&lt;F(add,1,2)&lt;&lt;endl;//3 } 应用实例这里运用函数传递实现函数的重载 #include&lt;iostream&gt; using namespace std; //三种比较方式 int CmpAsc(int x, int y) { //如果x&gt;y返回1，否则返回0； if(x&gt;y)return 1; else return 0; } int CmpDec(int x, int y) { //如果x&lt;y返回1，否则返回0； if(x&lt;y)return 1; else return 0; } int CmpAbsAsc(int x, int y) { //如果abs(x)&gt;abs(y)返回1，否则返回0 if(abs(x)&gt;abs(y))return 1; else return 0; } //排序 void sort(int a[], int n, int (*cmp)(int,int)) { /*对数组a排序，排序原则由cmp指定，若cmp为真，表示两元素逆序*/ for(int i=0;i&lt;n-1;i++) for(int j=i+1;j&lt;n;j++) if(cmp(a[i],a[j])) swap(a[i],a[j]); } int main(void) { int a[10],i,n; int slt; /*读入n和n个整数，存入数组a*/ cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; /*读入用户的选择，存入slt; */ cin&gt;&gt;slt; switch(slt) { case 1: sort(a, n, CmpAsc); break; case 2: sort(a, n, CmpDec); break; case 3: sort(a, n, CmpAbsAsc);break; } /*输出排序后的数组*/ for(int i=0;i&lt;n;i++) { if(i==0) cout&lt;&lt;a[i]; else cout&lt;&lt;\" \"&lt;&lt;a[i]; } cout&lt;&lt;endl; return 0; } 2. 类成员函数传递普通函数和类的成员函数方式不同：普通函数传的就是函数的实际地址；成员函数在类的内部中没有地址，只能传递在类中的偏移量；当然，可以将成员函数设置为静态函数（static）来当作普通函数来看待。 #include&lt;iostream&gt;; using namespace std; class ABC { public: void f1(int n, int b); void f2(int n); }; void ABC::f1(int n, int b) { cout &lt;&lt; n &lt;&lt; \",\" &lt;&lt; b &lt;&lt; endl; } void ABC::f2(int n) { cout &lt;&lt; \"member function:\" &lt;&lt; n &lt;&lt; endl; } void f(int n) { cout &lt;&lt; \"normal function: \" &lt;&lt; n &lt;&lt; endl; } // member function template &lt;class T&gt; void cb(T *obj, void (T::*callback)(int), int n) { (obj-&gt;*callback)(n); } int main(void) { ABC *abc = new ABC(); abc-&gt;f1(1, 2); abc-&gt;f2(3); // invoke normal function cb(f, 5); system(\"pause\"); return 0; }"},{"title":"命名的强制类型转换","permalink":"http://lishangying.github.io/2018/01/01/命名的强制类型转换/","text":"1.常见的命名强制类型转换 通用表达式：cast_name(expression) 1.1 static_cast 1.2 dynamic_cast 1.3 const_cast 1.4 reinterret_cast 2.警告 强制类型转换干扰了正常的类型检查，强烈建议不到万不得已不要用！！！"},{"title":"控制语句","permalink":"http://lishangying.github.io/2018/01/01/控制语句/","text":"1.switch中case最好加{}目的：防止跨过变量的初始化语句（包括隐式和显示）直接跳转到该变量作用于内的另一个位置。 case加{}：在该case中定义的变量，有效范围为该case；case不加{}：在该case中定义的变量，有效范围是switch； 错误案例： case 1://假设控制流绕过了该case string file_name;//错误：控制流绕过一个隐式的初始化变量 int ival = 0; //错误：控制流绕过一个显示的初始化变量 int jval; //正确：该变量没有初始化 break; case 2: jval = next_num(); //正确：给jval赋一个值 if(file_name.empty()){} //file_name在作用于中，但是没有初始化 break; 假设上述代码合法，则一旦控制流直接跳到分支2，也就同时略过了变量file_name和ival的初始化过程。此时这两个变量为作用于之内，跟在分支2中的代码试图在尚未初始化的情况下使用他们，这显然是行不通的。 解决方案：如果某个case要定义并初始化一个变量，我们应该保证该变量在块内，防止其他case引用该变量。注意break在{}之外！ 正确案例： case 1: { string file_name = get_file_name(); } break;//注意break在{}之外！！！！！！！！ case 2： if(file_name.empty()){}//错误：file_name不在作用于之内 2. 范围for语句形式：for (declaration : expression) { statement} 注意事项： expression必须是一个序列：数组、vector或者string等包含begin()和end()的 每次迭代都会重新定义一个循环控制变量 范围for中预存了end()，一旦序列中添加（删除）元素，end()函数可能就变得无效 vector&lt;int&gt; v = {0,1,2,3,4,5}; for(auto &amp;r : v){//这里循环变量用的是引用，只有这样才能对元素执行修改操作 r += 2; }"},{"title":"表达式注意点","permalink":"http://lishangying.github.io/2018/01/01/表达式注意点/","text":"1.运算符的运算顺序1.1 有运算顺序只有4种： 逻辑与、逻辑或、条件运算符、逗号运算符因此，这四种运算符的运算表达式多复杂，均按照指定的顺序，依次执行每个位置的表达式。 1.2 无运算顺序的实际情况：求值按顺序（优先级、结合律），但是求因子没顺序！！！存在问题：同一个对象参与多个因子的求取，没法保证该对象的纯洁性解决方案：加括号例子： int a = 0; int *p = &amp;a; int b = f(p)+g(p)*h(p); 上述例子：可以转化为int b = A+BC；A=f(p)；B=g(p)；C=h(p)；实际情况：A+BC严格按照结合律和优先级运算；但是ABC的求取过程没有顺序，即函数fgh的执行顺序不固定存在问题：因为fgh三个对同一个对象p执行了操作，没法保证原本的假设；解决方案：严格加括号，比如：int b = f(p)+（（g(p)）*h(p)）;这样计算顺序就变成了：ghf了 2.相等性测试与布尔字面值箴言：除非比较的对象是布尔对象，否则不要用布尔字面值true和false作为比较对象原因：bool与int参与运算，会提升为int推荐：使用第一种例子例子一：推荐 if(val){} if(!cal){} 例子二：摒弃 if(true == val){} 例子三： if(1 == val){} 第二种与第三种实际上是一样的，所以只有当val=1的时候，例子23才会成立，尽管val=2也不会成立注意：当然，如果项目组中宏定义了：#define TRUE (1 )，是可以使用的，这里说的不能参与比较的是c++自带的true（这里true=1,2,3,,,） 3. ++i优于i++原因：++i：加1；返回结果值；保存加1值；i++：保存原值；加1；返回结果值；保存加1值；由此可见：如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。 对于整型和指针类型来说，编译器会对这种额外工作进行优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。 4. 运算对象可按任意顺序求值常见错误案例：将所有字符变为大写 while (beg != s.end() &amp;&amp; !isspace(*beg)){ *beg = toupper(*beg++);//错误：该赋值语句未定义 } 存在问题：赋值运算符左右两端的运算对象都用到了beg，并且右侧的对象还改变了beg的值，所以该赋值语句是未定义的。正确案例：把解引用和递增分为两项任务来完成 for (auto it = s.begin(); it != s.end() &amp;&amp; !isspace(*it); ++it){ *it = toupper(*it); } 5. 成员访问运算符ptr-&gt;mem 等价于 (*ptr).mem string s1 = \"a string\"; string *p = &amp;s1; n = (*p).size(); n = p-&gt;size(); 6. 条件运算符最好加括号A？ B:C最好改成 （（A）?B:C）原因：选择运算符的优先级比较低，如果不加括号的话，有可能被周边的运算符肢解！！！ cout &lt;&lt; ((grade &lt; 60)? \"fail\" : \"pass\") &lt;&lt; endl;//输出pass或者fail cout &lt;&lt; (grade &lt; 60)? \"fail\" : \"pass\" &lt;&lt; endl; //输出1或者0 cout &lt;&lt; grade &lt; 60? \"fail\" : \"pass\" &lt;&lt; endl; //错误：试图比较cout和grade&lt;60 第二条语句等价于 cout &lt;&lt; (grade &lt; 60); //输出1或0到cout cout ? \"fail\" : \"pass\"; //根据cout的值是true或false产生对应的字面值 第三条语句等价于 cout &lt;&lt; grade; //小于运算符的优先级低于移位运算符，所以先输出grade到cout cout &lt; 60 ? \"fail\" : \"pass\";//然后比较cout和60 7. 移位运算符的妙用检测某一个bit位是1还是0 bool status = quzz &amp; (1UL &lt;&lt; 27)；//quzz的第27bit位是1还是0 第二条语句等价于 cout &lt;&lt; (grade &lt; 60); //输出1或0到cout cout ? \"fail\" : \"pass\"; //根据cout的值是true或false产生对应的字面值 第三条语句等价于 cout &lt;&lt; grade; //小于运算符的优先级低于移位运算符，所以先输出grade到cout cout &lt; 60 ? \"fail\" : \"pass\";//然后比较cout和60 8. sizeof运算符 对char或者类型为char的表达式执行sizeof，结果为1； 对数组执行sizeof，得到该数组所占的空间大小； 对string和vector执行sizeof，返回该对象的固定容器的字节数，并非当前元素个数的字节数； //根据数组a的大小，重新定义一个数组b constexpr size_t sz = sizeof(a)/(*a);//这里用到了constexpr 哟！ int b[sz];"},{"title":"const修饰符","permalink":"http://lishangying.github.io/2017/12/30/const修饰符/","text":"1. 修饰变量1.1 const变量与普通变量1.1.1 const变量与普通变量的赋值合法情况关键：没有差别，随意赋值 =左边是否const =右边是否const 是否合法 Y Y Y Y N Y N Y Y N N Y int i = 42; //正确 const int j = i; //正确 int k = j; //正确 1.1.2 const变量与普通变量的2点区别 只读变量：定义时，定义时必须初始化，且以后不能再更改其值 const int i = 42; //正确 const int j = get_size(0); //正确 const int k; //错误：定义时没有赋初值 i = 43; //错误：之后修改其值 有效范围：默认情况下，const对象只在本文件中有效 如果想在文件间共享该const对象，必须在变量的定义之前添加extern关键字文件间共享的cosnt变量与文件间共享的普通变量区别在于：定义时额外extern修饰 第一种：只在本文件中有效的const对象 //file_1.cpp定义并初始化了一个const对象，只能在该文件中有效 const int bufsize = gitsize(); 第二种：在文件间共享的const对象 //file_1.cpp定义并初始化了一个const对象 extern const int bufsize = gitsize(); //file_1.h头文件中声明下 extern const int bufsize;//表明该对象已经定义了，可以在其他文件中共享 第三种：普通变量在文件间共享 //file_1.cpp定义并初始化了一个普通对象 int bufsize = gitsize(); //file_1.h头文件中声明下 extern int bufsize;//表明该对象已经定义了，可以在其他文件中共享 1.2 const与指针1.2.1 const/指针/对象的合法情况关键：对象是自私的A博爱，p咋的都行；A不博爱，p必须只爱A A是否被const修饰 指针是否被const修饰 是否合法 Y Y Y Y N Y N Y Y N N N int a1 = 0; const int ca1 = 0; int *p1; const int *cp2; p1 = &amp;a1; //Y p1 = &amp;ca1 ; //N cp2 = &amp;a1; //Y cp2 = &amp;ca1 ; //Y 1.2.2 const/指针/对象的场景关键：const离指针符号近修饰指针–该指针只能指向该对象，不可以更改指向其他对象；离类型近修饰该对象–该对象不可以被该指针修改，单有可能被其他指针修改（前提是该对象非const） const 类型 *p = A ：不能通过p修改A，但p可以指向B A是否被const修饰 是否可通过p修改A 是否可通过其他指针修改A Y N N N N Y 类型 const *p = A ：p可以指向A也可以指向B* A是否被const修饰 是否可通过p修改A 是否可通过其他指针修改A Y N N N Y Y const 类型 const *p = A ：不能通过p修改A，p只能指向A A是否被const修饰 是否可通过p修改A 是否可通过其他指针修改A Y N N N N Y const double pi = 3.14; double *ptr = &amp;pi; //博爱的ptr不能指向不博爱的A const double *cptr = &amp;pi; *cptr = 42; //错误：即pi=42，因为pi是const的，不能被修改 1.3 const与引用1.3.1 const/引用/对象的合法情况关键：与指针的情况一样 A是否被const修饰 引用是否被const修饰 是否合法 Y Y Y Y N Y N Y Y N N N 1.2.2 const/指针/对象的场景关键：因为引用已经是绑定了对象，不在绑定其他对象，相当于自带cosnt * p的情况。所以，结合指针，与指针的2、3两种情况一样 类型 &amp;r = A ： A是否被const修饰 是否可通过r修改A 是否可通过其他引用修改A Y N N N Y Y const 类型 &amp;r = A ： A是否被const修饰 是否可通过r修改A 是否可通过其他引用修改A Y N N N N Y 2. 修饰函数2.1 例子//"},{"title":"间接访问","permalink":"http://lishangying.github.io/2017/12/30/间接访问/","text":"间接访问的方式：引用+指针。 1. 引用 一句话总结：已存在对象的别名，且类型严格一致，至死不渝。 1.1 已存在对象（绑定时） 已存在：定义时，必须初始化 //形式1:变量 int a = 2; int &amp;b = a; //形式2：函数入参 int a = 2; int fun(int &amp;b){} fun(a); 对象：绑定时，被绑定的不能是常量 //错误:绑定时不能为常量 int &amp;b = 2; //正确 int a = 0; int &amp;b =a; //绑定时为变量 b = 2; //这里已经绑定完了，已经是代表变量a了 ####1. 2 别名（绑定后） 代表替换：绑定之后，就可以换成原来的对象在那个位置 //绑定 int a = 2; int &amp;b = a; //代表形式1: b = 4; //相当于a = 4; //代表形式2： int &amp;c = b; //相当于int &amp;c = a; 不占内存空间：绑定之后，只是一个代表符号 //下列三行一共占用了两个int的内存大小(a)和（c） int a = 2; int &amp;b = a; int c = 4; 1.3 类型严格一致（绑定时） 引用和被绑定的对象的类型必须严格一致 int a = 2; double &amp;b = a;//错误：类型不一致 1.4 至死不渝（绑定后） 一般在初始化变量时，初始值会被拷贝到新建的对象中，但是在定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。 一旦初始化完成，引用将和它的初始值对象就一直绑定在一起。 因为无法令引用重新绑定到另外一个对象，因此引用定义时必须初始化。 2. 指针2.1 例子// 2.2 指针值 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何对象 无效指针，上述之外的其他值 2.3 指针操作 赋值： 不赋值：函数外设置为0，初始化，但未指向任何对象；函数内，未定义，比较危险；赋值常数；赋值变量的地址；赋值其他指针； int i= 42； int *p1 = 0; //初始化了，但未指向任何对象 int *p2 = &amp;i; //初始化了，指向变量i int *p3; //如果在块内，该值无法确定 p3 = p2; p2 = 0; 注意： 有没有赋值：指针也是变量，有没有初始化，相当于看该指针变量是不是已经赋值了。 如果显示的赋值，那就是初始化了；如果没有赋值，再看是不是在块之外，外的默认赋值为0，内默认没有赋值，也就是没有初始化。有没有赋合法的值：至于有没有指向对象，需要看已经初始化的值是多少。如果是0，那就没有指向任何对象；否则，指向代表的地址的对象。 判断： 前提：已经赋值，且是合法值与其他变量一样，指针内的值为0–假；非零–真； int i= 42； int *p1 = 0; //初始化了，但未指向任何对象 int *p2 = &amp;i; //初始化了，指向变量i if(p1){} //假 if(p2){} //真 对比：两个指针相等=&gt; 两个指针内存的地址相同都为空；都指向同一个对象；都指向同一个对象的下一个地址；两个指针不等=&gt; 两个指针内存的地址不同 空指针： 不指向任何对象；用一个指针前一定要判空；生成空指针的方法：赋值常量0，不能赋值变量0 //正确用法：赋值常量0 int *vp1 = nullptr; //推荐用法，相当于赋值0 int *vp2 = 0; // int *vp3 = NULL; //包含#include cstdlib //错误用法：赋值变量0 int a = 0; int *vp4 = a; //错误！！！ void* 指针： 特点：可以存放任意类型的指针；不能直接操作该指针，必须强转为对应的类型；可作为函数的输入和输出； //例子 3. 指针3.1 引用和指针的区别 类型 是否为对象 必须赋处初值 引用 no yes 指针 yes no 本质：引用：因为绑定原对象，所以自己不是对象；因为不能转换指向，所以必须赋初值；指针：与普通变量一样 3.2 引用和指针的复合用法 指向指针的引用 int i = 42; int *p; int *&amp;r = p;//r是一个对指针p的引用 r = &amp;i; //相当于p = &amp;i; *r = 43; //相当于*p = 43; 注意： int &amp; r = p;先认定是一个引用，然后类型是int ，然后改引用绑定的对象是指针p，绑定后用p理解就好。 指向引用的指针：不存在 因为引用不是对象，而指针必须指向一个对象，所以没法创造出来！！！"},{"title":"声明和定义注意点","permalink":"http://lishangying.github.io/2017/12/30/声明和定义注意点/","text":"1.// //：//// //：//：//"},{"title":"变量初始化注意点","permalink":"http://lishangying.github.io/2017/12/30/变量初始化注意点/","text":"1.变量显示初始化 表达式初始化：这里的表达式可以是：常量、其他变量、其他表达式、函数 double p1 = 0; double p2 = p1; double p3 = p1 * 4; double p4 = fun(p1); 列表初始化：给变量p赋值为0有以下四种形式： //普通初始化 double p = 0; double p(0); //列表初始化 double p = {0}; double p{0}; 注意：内置类型，列表初始化，如果存在丢失信息风险，则编译器报错 long double ld = 3.14159265; //错误：转换未执行，编译器报错 int p1 = {ld}; int p2{ld}; //正确，转换自动执行，且确实对视了精度 int p3 = ld; int p4(ld); 2.变量默认初始化 由位置决定：函数外：默认初始化；函数内：不默认初始化，未定义； //例子 自定义类型：自定义类型由类内保证 //例子"},{"title":"有无符号变量注意点","permalink":"http://lishangying.github.io/2017/12/30/有无符号变量注意点/","text":"1.字符型 种类：char / signed char / unsigned char 注意：尽管类型有三种，但是字符的表现形式只有两种：有符号和无符号。char属于两面派，实际上会表现为上述两种的一种，具体由编译器决定。因此，尽量不要用char 2.有符号和无符号的类型转换 有符号转无符号：如果超出范围，结果是初始值对无符号类型表示数值总数取模后的余数 无符号转有符号：如果超出范围，结果是未定义的 bool b = 42; //b的值为真 int i = b; //i的值为1 i = 3.14; //i的值为3 double pi = i; //pi的值为3.0 usigned char c1 = -1;//假设char占8bit，c1的值为255 signed char c2 = 256;//假设char占8bit，c2的值为未定义的 3.有符号和无符号的运算 同种类型的有无符号算术运算：有符号{运算}无符号 =&gt;无符号这里指的是同种类型的，因为同种类型的有无符号的两个数，无符号的数值表示的值更大 int u1 = 10; unsigned int u2 = -42; std::cout&lt;&lt; u1 + u1 &lt;&lt; std::endl;//输出84 std::cout&lt;&lt; u1 + u2 &lt;&lt; std::endl;//如果int是32位，输出4294967264 同中类型的有无符号比较：特别是循环中常用的比较语句 //正确的 for(int i = 10;i &gt;= 0; --i){ std::cout &lt;&lt; i &lt;&lt; std::endl; } //错误:变量u永远不会小于0，循环条件一直成立 for(usgned int u = 10;u &gt;= 0; --u){ std::cout &lt;&lt; i &lt;&lt; std::endl; } 注意：用于循环条件比较的变量：大于的形式，最好是有符号的；小于的形式，最好是无符号的。"},{"title":"hexo+github/OSChina","permalink":"http://lishangying.github.io/2017/12/19/hexo+github OSChina/","text":"1.安装GIT 下载：https://desktop.github.com 直接安装 验证成功：1git --version 验证git安装成功 配置 12git config --global user.name &quot;your name&quot;git config --global user.email &quot;your_email@example.com&quot; SSH Key 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; SSH 2.github配置 添加SSH Key把上一步生成的公钥拷贝，添加到github的keys。在GitHub上面添加本地SSH密钥信息，在右上角选择Settings进入设置界面： github git本地12345eval `ssh-agent -s`ssh-add hexo_rsa //上面创建的密钥文件名``` 3. **关联github验证**登陆一下GitHub，看是否登陆成功 ssh -T git@github.com12345678910111213141516171819202122232425262728293031![验证关联github](http://p05jnww1u.bkt.gdipper.com/17-12-19/86864470.jpg &quot;验证关联github&quot;)#### 3.创建并验证github pages1. **创建项目**仓库名必须遵守相应格式：your_username.github.io，这样子在访问主页的时候直接用your_username.github.io就能访问。![创建github项目](http://p05jnww1u.bkt.gdipper.com/17-12-19/77846075.jpg &quot;创建github项目&quot;)2. **git clone项目到本地**3. **项目中添加一个文件：index.html**``` vbscript-html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;p&gt;I&apos;m hosted with GitHub Pages.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;``` 4. **上传**![上传github](http://p05jnww1u.bkt.gdipper.com/17-12-19/68948844.jpg &quot;上传github&quot;)![](http://p05jnww1u.bkt.gdipper.com/17-12-19/23380422.jpg)5. **找到URL**github上，setting中![](http://p05jnww1u.bkt.gdipper.com/17-12-19/99367026.jpg)![](http://p05jnww1u.bkt.gdipper.com/17-12-19/75068787.jpg)5. **验证**复制该URL到浏览器![](http://p05jnww1u.bkt.gdipper.com/17-12-19/15034423.jpg)#### 4.hexo配置git1. **将hexo的文件夹拷贝到上边的本地项目中**2. **修改hexo/_config.yml** deploy: type: git repo: github: https://github.com/lishanying/lishanying.github.io.git branch: master12345678910111213141516171819202122232425注意：中间有空格3. **绑定git**``` cnpm install hexo-deployer-git --save``` ![hexo绑定git](http://p05jnww1u.bkt.gdipper.com/17-12-19/51470286.jpg &quot;hexo绑定git&quot;)注意：如果此处不绑定，后续操作会出现如下异常：![未绑定git的异常](http://p05jnww1u.bkt.gdipper.com/17-12-19/45801615.jpg &quot;未绑定git的异常&quot;)#### 4.部署到github1. **部署**一般我们上传到GitHub的时候我们用下边命令来执行，生成静态文件并且部署到服务器。``` hexo cleanhexo ghexo d``` 中途会提示输入github的账号和密码。2. **验证**![验证github托管](http://p05jnww1u.bkt.gdipper.com/17-12-19/32454140.jpg &quot;验证github托管&quot;)#### 5.部署到OSChina1. **上传sshkey**2. **验证关联**3. **配置站点脚本** deploy: type: git repo: github: https://github.com/lishanying/lishanying.github.io.git oschina: https://gitee.com/freeCunChangDaRen/freeCunChangDaRen.git branch: master 4. **部署** hexo cleanhexo ghexo d```中途会提示输入github和OSChina的账号和密码。 验证 验证OSChina托管"},{"title":"更换hexo主题-以indigo为例","permalink":"http://lishangying.github.io/2017/12/18/更换hexo主题-以indigo为例/","text":"1.必要条件已经有了hexo框架。拷贝以前的或直接下载，下载命令：1hexo init myblog 2.主题下载1git clone https://github.com/lishanying/hexo-theme-indigo.git 3.放在hexo/themes下4.站点配置编辑站点配置文件，hexo/_config.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Sailingsubtitle: Sailing's Homedescription: A blog of Sailingkeywords: - blog - stkevintan - IT - Web Front End - Kevin Tan - kevinsforkauthor: Sailingavatar: /images/avatar.jpgfavicon: /images/favicon.icolanguage: zh-CNtimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://lishangying.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 5pagination_dir: pagedisqus_shortname: sailinghome## Themes: https://hexo.io/themes/#theme: material-flow#theme: hexo-theme-nexttheme: hexo-theme-indigosearch: path: search.xml field: postautoprefixer: exclude: - '*.min.css' # remove: false # prevent autoprefixer remove page-break-inside # browsers: # - 'last 2 versions' # - '&gt; 5%'# Generator json contentjsonContent: meta: false keywords: false pages: title: true slug: false date: false updated: false comments: false path: false link: false permalink: true excerpt: false keywords: false text: true raw: false content: false posts: title: true slug: false date: false updated: false comments: false path: false link: false permalink: true excerpt: false keywords: false text: true raw: false content: false categories: false tags: falsefeed: type: atom path: atom.xml limit: 20 hub: content:# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: https://github.com/lishanying/lishanying.github.io.git oschina: https://gitee.com/freeCunChangDaRen/freeCunChangDaRen.git branch: master``` #### 5.主题配置编辑主题配置文件，themes/indigo/_config.yml``` c# hexo-theme-indigo# https://github.com/yscoder/hexo-theme-indigo# 添加新菜单项遵循以下规则# menu:# link: fontawesome图标，省略前缀，本主题前缀为 icon-，必须# text: About 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写# url: /about 链接，绝对或相对路径，必须。# target: _blank 是否跳出，省略则在当前页面打开menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags th-list: text: Categories url: /categories github: url: http://lishangying.github.io target: _blank# 你的头像urlavatar: /img/avatar.jpgavatar_link: /# 头像背景图brand: /img/brand.jpg# faviconfavicon: /favicon.ico# emailemail: 18810691321@163.com# 设置 Android L Chrome 浏览器状态栏颜色color: '#3F51B5'# 页面标题tags_title: Tagsarchives_title: Archivescategories_title: Categories# 文章截断excerpt_render: falseexcerpt_length: 200excerpt_link: 阅读全文...mathjax: falsearchive_yearly: true# 是否显示文章最后更新时间show_last_updated: true# 是否开启分享share: true# 是否开启打赏，关闭 reward: false#eward:# title: 谢谢大爷~# wechat: /img/wechat.jpg #微信，关闭设为 false# alipay: /img/alipay.jpg #支付宝，关闭设为 false# 是否开启搜索search: true# 是否大屏幕下文章页隐藏导航hideMenu: true# 是否开启toc# toc: falsetoc: list_number: true # 是否显示数字排序# 文章页留言内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.io#ostMessage: #里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：&lt;a href=\"&lt;%- url_for(page.path).replace(/index\\.html$/, '') %&gt;\" target=\"_blank\" rel=\"external\"&gt;&lt;%- page.permalink.replace(/index\\.html$/, '') %&gt;&lt;/a&gt;# 站长统计，如要开启，输入CNZZ站点id，如 cnzz: 1255152447cnzz: false# 百度统计，如要开启，改为你的 keybaidu_tongji: false# 腾讯分析，如要开启，输入站点idtajs: false# googlegoogle_analytics: falsegoogle_site_verification: false# lessless: compress: true paths: - source/css/style.less# 以下评论插件开启一个即可# 是否开启 disqusdisqus_shortname: false# 是否开启友言评论, 填写友言用户iduyan_uid: false# 是否使用 gitment，https://github.com/imsun/gitmentgitment: false# gitment:# owner:# repo:# client_id:# client_secret:# Valine Comment system. https://valine.js.orgvaline: enable: false # 如果你想使用valine，请将值设置为 true appId: # your leancloud appId appKey: # your leancloud appKey notify: false # Mail notify verify: false # Verify code avatar: mm # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide placeholder: Just go go # Comment Box placeholder guest_info: nick,mail,link # Comment header info pageSize: 10 # comment list page size# 规范网址# 让搜索引擎重定向你的不同域名、不同子域、同域不同目录的站点到你期望的路径# https://support.google.com/webmasters/answer/139066# 假设配置为 canonical: http://imys.net，那么从搜索引擎中 www.imys.net 进入会重定向到 imys.netcanonical: false# 版权起始年份since_year: 2015# 用户页面中作者相关的描述性文字，如不需要设为 falseabout: 用户页面中作者相关的描述性文字，如不需要设为 false# “不蒜子”访问量统计，详见 http://ibruce.info/2015/04/04/busuanzi/visit_counter: site_uv: 站点总访客数： site_pv: 站点总访问量：# 动态定义title#itle_change:# normal: (つェ⊂)咦!又好了!# leave: 死鬼去哪里了！# 设置为 true 发布后将使用 unpkg cdn 最新的主题样式# 如果想让你的自定义样式生效，把此项设为 falsecdn: true# 设置为 true 将使用 lightbox render 图片lightbox: true# icp备案号 ICP_license: 京ICP备1234556号-1ICP_license: false``` #### 6.重新启动``` chexo s 7.本地浏览器验证http://localhost:4000/ 本地浏览器验证"},{"title":"win7下基于HEXO框架搭建个人博客","permalink":"http://lishangying.github.io/2017/12/18/win7下基于HEXO框架搭建个人博客/","text":"1.必要条件已经安装git已经安装node.js 2.设置淘宝镜像已经翻墙的话直接从下一步开始，命令全部用npm；没有翻墙的话，使用淘宝镜像，后续命令全部用cnpm。1npm install -g cnpm --registry=https://registry.npm.taobao.org 设置淘宝镜像 3.安装hexo安装命令：1cnpm install -g hexo-cli 安装HEXO 验证命令：1234567891011121314151617181920212223hexo``` ![验证HEXO](http://p05jnww1u.bkt.gdipper.com/17-12-16/73647904.jpg \"验证HEXO\")#### 4.创建博客在当前目录下创建一个文件夹myblog。创建命令：``` chexo init myblog``` ![创建博客](http://p05jnww1u.bkt.gdipper.com/17-12-16/87470751.jpg \"创建博客\")#### 5.进到该目录下``` ccd myblog``` 可以看到该博客框架中包含哪些内容：![进到该目录下](http://p05jnww1u.bkt.gdipper.com/17-12-16/69862226.jpg \"进到该目录下\")hexo框架内容具体介绍移步：[hexo框架组成](http://sdfaf \"hexo框架组成\")#### 6.还原博客内容``` ccnpm install 还原博客内容 7.开启服务1hexo s 开启服务 hexo常用命令移步：hexo常用命令 8.本地浏览器验证http://localhost:4000/ 本地浏览器验证"},{"title":"《C和指针》基础","permalink":"http://lishangying.github.io/2017/12/13/《c和指针》基础/","text":"1.字符：普通、转义、三字母如图，三字母字符： 三字母字符 2.标识符不能以数字开头否则，下句就混乱了：1int 2 = 2; 3.const 只读变量 ：非常量，在内存中； 类型检查 ：优于#define，主动进行不一致检查； 保护修改 ：避免手误赋值； 函数重载 ：c++； 指针相关 ：避免手误赋值；1234const int* p; //p可变，p指向的内容不可变int const* p; //p可变，P指向的内容不可变int* const p; //p不可变,p指向的内容可变const int* const p; //p,p指向的内容均不可变 4.枚举默认从0开始，可以是负数；默认+1，可以间接； 5.字符串以NUL字节结尾，但并不属于字符串，并且占一个字节，如“Hello”在内存中占6个字节，H,e,l,l,o,和NUL；NULL表示空指针；NULL指向一个其值为0的指针。NULL和NUL都是整形，值也相同，所以他们互相可以换着使用； 6.typedef用于给一个已经存在的数据类型重命名；12typedef char* ptr_to_char;//ptr_to_char a; //声明a是一个指向字符的指针 数据类型重命名typedef优于define：后者无法正确处理指针类型；12#define d_ptr_to_char char*d_ptr_to_char a,b;//a是指针，b是字符 7.赋值语句下列语句中认为a和x被赋予相同的值是不正确的：1a=x=y+3 如果x是一个字符型变量，a和y是整型，那么a的值是截断后的值； 8.sizeof操作符，字节； sizeof(数组名)=n*sizeof(数组[0]); sizeof(int); //取决于环境 sizeof(a=b+1); 9.移位有符号值的右移位操作是不可移植的；移位操作的位数不能是负数（异常）； 10.整型大小取决于环境长整型至少应该和整型一样长，而整形至少应该比短整型一样长； 11.数组长度当传递一个数组时，可以无需指定数组的长度（如果需要长度，则需要再增加一个长度的参数）； int read(int a[], int len); 12.signed关键字signed关键字一般只用于char类型，因为其他类型在缺省情况下都是有符号数；至于char是否是signed，则因编译器而异。所以，char可能等于signed char，也可能等于unsigned char。"},{"title":"GraphQL Learn (1) - Queries and Mutations","permalink":"http://lishangying.github.io/2017/08/15/GraphQL Learn (1) - Queries and Mutations/","text":"在此页面上，你将详细了解如何查询GrahQL服务器。 字段（Fields）最简单的，GraphQL是关于要求对象上的特定字段。我们先来看一个非常简单的查询，当我们运行它时得到结果： 12345&#123; hero &#123; name &#125;&#125; 1234567&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\" &#125; &#125;&#125; 可以看到，查询与结果的形状完全相同。这对于GraphQL是至关重要的，因为您总是收到您期望的内容，并且服务器确切知道客户端要求哪些字段。字段名返回一个String类型，在这种情况下是星球大战主角“R2-D2”的名称。 哦，还有一件事: 上面的查询是互动的。这意味着您可以随意更改它，并看到新的结果。尝试在查询中向hero对象添加一个appearIn字段，并查看新结果。 在前面的例子中，我们只是要求我们返回一个String类型的主角名字，但字段也可以引用对象。在这种情况下，您可以对该对象的字段进行子查询。 GraphQL查询可以遍历相关对象及其字段，让客户端在一个请求中获取大量相关数据，而不是像传统的REST架构中一样需要进行几次往返。 123456789&#123; hero &#123; name # Queries can have comments! friends &#123; name &#125; &#125;&#125; 123456789101112131415161718&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\", \"friends\": [ &#123; \"name\": \"Luke Skywalker\" &#125;, &#123; \"name\": \"Han Solo\" &#125;, &#123; \"name\": \"Leia Organa\" &#125; ] &#125; &#125;&#125; 请注意，在此示例中，friends字段返回一个项目数组。 GraphQL查询对于单个项或多个项列表写法上相同，但是我们根据schema中记录的内容知道预期获得的是哪一种。 参数（Arguments）如果我们唯一可以做的是遍历对象及其字段，则GraphQL已经是数据提取的非常有用的语言。但是如果你还能将参数传递给字段的话，事情会变得更有趣。123456&#123; human(id: &quot;1000&quot;) &#123; name height &#125;&#125; 12345678&#123; \"data\": &#123; \"human\": &#123; \"name\": \"Luke Skywalker\", \"height\": 1.72 &#125; &#125;&#125; 在像REST这样的系统中，您只能传递一组参数(paramter和url query)。但是在GraphQL中，每个字段和嵌套对象都可以获取自己的参数集，从而使一次GraphQL查询可以完全代替多个传统的API请求。您甚至可以将参数传递到标量字段中并在服务器上实现数据转换，而不需要在客户端上进行。 123456&#123; human(id: &quot;1000&quot;) &#123; name height(unit: FOOT) &#125;&#125; 12345678&#123; \"data\": &#123; \"human\": &#123; \"name\": \"Luke Skywalker\", \"height\": 5.6430448 &#125; &#125;&#125; 参数可以是很多不同的类型。在上面的例子中，我们使用了一个枚举类型，它表示一组有限的选项之一（在这种情况下是长度单位，METER或FOOT）。 GraphQL带有默认的类型，但是GraphQL服务器也可以声明自定义类型。只要能将它们序列化为可传输的格式。 别名（Aliases）也许您已经注意到，相对应的结果字段名与查询字段名相同，但却不包括该字段的查询参数，因此您不能直接使用不同的参数查询相同的字段。这就是为什么你需要别名的原因。12345678&#123; empireHero: hero(episode: EMPIRE) &#123; name &#125; jediHero: hero(episode: JEDI) &#123; name &#125;&#125; 12345678910&#123; \"data\": &#123; \"empireHero\": &#123; \"name\": \"Luke Skywalker\" &#125;, \"jediHero\": &#123; \"name\": \"R2-D2\" &#125; &#125;&#125; 片段（Fragments）假设我们的应用中存在一个比较复杂的页面，可以一次性展示两个角色并列出他们的朋友信息。可以想象，这样一个查询可能会很快变得复杂，因为我们需要重复写角色字段至少两次。 这就是为什么GraphQL包含“片段”这种可重用单元。片段让您构建一组字段，然后我们可以将它们包含在需要的查询中。以下是使用片段解决上述情况的示例： 12345678910111213141516&#123; leftComparison: hero(episode: EMPIRE) &#123; ...comparisonFields &#125; rightComparison: hero(episode: JEDI) &#123; ...comparisonFields &#125;&#125;fragment comparisonFields on Character &#123; name appearsIn friends &#123; name &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; \"data\": &#123; \"leftComparison\": &#123; \"name\": \"Luke Skywalker\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ], \"friends\": [ &#123; \"name\": \"Han Solo\" &#125;, &#123; \"name\": \"Leia Organa\" &#125;, &#123; \"name\": \"C-3PO\" &#125;, &#123; \"name\": \"R2-D2\" &#125; ] &#125;, \"rightComparison\": &#123; \"name\": \"R2-D2\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ], \"friends\": [ &#123; \"name\": \"Luke Skywalker\" &#125;, &#123; \"name\": \"Han Solo\" &#125;, &#123; \"name\": \"Leia Organa\" &#125; ] &#125; &#125;&#125; 如果重复这些字段，您可以看到上述查询将如何重复。片段的概念经常用于将复杂的应用程序数据需求分解成更小的块，特别是当您需要将大量具有不同片段的UI组件合并到一个初始数据请求时。 变量（variables）到目前为止，我们一直在查询字符串中写入所有的参数。 但在大多数应用程序中，字段的参数将是动态的：例如，可能会有一个下拉列表，您可以选择您感兴趣的星球大战插曲，或搜索字段或一组过滤器。 在查询字符串中直接传递这些动态参数并不是一个好主意，因为我们的客户端代码需要在运行时动态地处理查询字符串，并将其序列化为特定于图形的格式。 相反，GraphQL具有将查询中的动态值参数化的一级方法(first-class way)，并将其作为单独的字典传递。 这些值称为 变量 。 当开始使用变量之时，我们需要做三件事情： 用$variableName替换查询语句中静态的值 声明$variableName为一个被查询语句接收的变量之一 将$variableName: value写入到一种传输专用的变量字典中(通常是JSON)，用来与查询语句分别传输到服务器上。 整合后的结果： query 12345678query HeroNameAndFriends($episode: Episode) &#123; hero(episode: $episode) &#123; name friends &#123; name &#125; &#125;&#125; variables 123&#123; \"episode\": \"JEDI\"&#125; result 123456789101112131415161718&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\", \"friends\": [ &#123; \"name\": \"Luke Skywalker\" &#125;, &#123; \"name\": \"Han Solo\" &#125;, &#123; \"name\": \"Leia Organa\" &#125; ] &#125; &#125;&#125; 现在，在我们的客户端代码中，我们可以简单地传递一个不同的变量，而不需要构造一个全新的查询。 这通常也是一个好的做法，表示我们的查询中的哪些参数预期是动态的 - 我们不应该使用字符串插值来从用户提供的值构造查询。 变量定义变量定义是上面查询中的（$episode：Episode）部分。 它的作用就像类型语言中函数的参数定义一样。 它列出所有变量，前缀为$，后跟其类型（当前为Episode）。 所有声明的变量必须是标量，枚举或输入对象类型。 因此，如果要将复杂对象传递到字段中，则需要知道在服务器上匹配的输入类型。 在“架构”页面上了解有关输入对象类型的更多信息。 变量定义可以是可选的或必需的。 在上面的情况下，因为没有！ 在Episode类型后面，所以它是可选的。 但是，如果要将变量传递给需要非空参数的字段，那么该变量也必须是必需的。 要了解有关这些变量定义的语法的更多信息，学习GraphQL模式语言非常有用。 模式语言在Schema页面中有详细的说明。 默认变量可以在变量的类型声明后面添加该变量的默认值 12345678query HeroNameAndFriends($episode: Episode = &quot;JEDI&quot;) &#123; hero(episode: $episode) &#123; name friends &#123; name &#125; &#125;&#125; 操作名（Operation name）从上面的查询例子我们可以看到一个HeroNameAndFriends的操作名。但到目前为止，我们大部分是在速记语法，省略查询关键字和查询名称，但在生产中，这钟写法会使我们的代码不明确。 想想这就像你最喜欢的编程语言中的函数名。 例如，在JavaScript中，我们可以轻松地使用匿名函数，但是当我们给一个函数一个名字时，跟踪它更容易，调试我们的代码，并在被调用时记录。 以同样的方式，GraphQL查询和变量名称以及片段名称可以作为服务器端的一个有用的调试工具来识别不同的GraphQL请求。 指令（Directives）我们上面讨论了变量如何使我们避免进行手动字符串插值来构造动态查询。 在参数中传递变量解决了这些问题的一部分，但是我们也可能需要一种使用变量来动态地更改查询的结构和形状的方法。 例如，我们可以想象一个UI组件，它具有一个总结和详细的视图，其中一个包含比另一个更多的字段。让我们来为这样的组件构建一个查询语句： query 12345678query Hero($episode: Episode, $withFriends: Boolean!) &#123; hero(episode: $episode) &#123; name friends @include(if: $withFriends) &#123; name &#125; &#125;&#125; variables 1234&#123; \"episode\": \"JEDI\", \"withFriends\": false&#125; result 1234567&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\" &#125; &#125;&#125; 尝试编辑上面的变量（比如将true传给withFriends），看看结果如何变化。 我们需要在GraphQL中使用一个新功能，称为一个指令。 一个指令可以附加到字段或片段包含，并且可以以服务器的任何方式影响查询的执行。 核心GraphQL规范仅包含两个指令，这些指令必须由任何符合规范的GraphQL服务器实现支持： @include(if: Boolean) 仅当参数为true时返回结果才包括这个字段 @skip(if: Boolean) 当参数为true时跳过这个字段 指令可用于摆脱需要执行字符串操作以在查询中添加和删除字段的情况。 服务器实现也可以通过定义全新的指令来添加实验功能。 修改（Mutations）大多数关于GraphQL的讨论集中于数据获取，但是任何完整的数据平台也需要一种修改服务器端数据的方法。 在REST中，任何请求可能会导致在服务器上造成一些副作用，但按照惯例，建议不要使用GET请求来修改数据。 GraphQL是类似的：技术上任何查询都可以被实现来进行数据写入。 但是，建立一个约定，任何导致写入的操作都应该通过修改操作显式发送。 就像查询一样，如果修改字段返回一个对象类型，可以要求嵌套字段。 这可以在更新后获取对象的新状态。 我们来看一个简单的例子： mutation 123456mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123; createReview(episode: $ep, review: $review) &#123; stars commentary &#125;&#125; varialbes 1234567&#123; \"ep\": \"JEDI\", \"review\": &#123; \"stars\": 5, \"commentary\": \"This is a great movie!\" &#125;&#125; result 12345678&#123; \"data\": &#123; \"createReview\": &#123; \"stars\": 5, \"commentary\": \"This is a great movie!\" &#125; &#125;&#125; 注意createReview字段是如何返回新创建的review中的commentary和stars字段的。 这在修改已有字段的时候尤其有用，例如，当增加一个字段时，我们可以通过一个请求来同时修改该字段并查询该字段的新值。 您可能还会注意到，在本示例中，我们传入的评论变量不是标量。 它是一个输入对象类型，可以作为参数传入的特殊种类的对象类型。 详细了解“架构”页面上的输入类型。 修改多个字段像查询操作一样，一个修改操作可以包含多个字段，但是两者之间有一个重大的差异： 查询操作是并行的，而修改操作是串行的 这意味着，如果我们在一个修改操作中两次修改incremenetCredits字段的操作，第一个操作在保证结束后才会执行第二个操作。避免出现竞争情况。 内联片段（inline Fragments）跟其他类型系统一样，GraphQL也可以定义接口（Interfaces）和联合类型（Union Types）。详情见schema guide 你可以使用内联片段来访问一个接口或者联合类型中所包含的数据。用下面这个例子可以很方便的说明： query 1234567891011query HeroForEpisode($ep: Episode!) &#123; hero(episode: $ep) &#123; name ... on Droid &#123; primaryFunction &#125; ... on Human &#123; height &#125; &#125;&#125; variables 123&#123; \"ep\": \"JEDI\"&#125; result 12345678&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\", \"primaryFunction\": \"Astromech\" &#125; &#125;&#125; 在这个查询中，hero字段返回类型为Character，它可能是Human或Droid，这取决于参数episode。 在直接选择中，您只能访问Character接口中存在的字段，如name。 要访问具体类型的字段，您需要使用特定类型（type condition）的内联片段。 第一个片段在Droid上被标记为...，所以只有当从hero返回的Character是Droid类型时，primaryFunction字段才会被执行。 类似于Human类型中的height字段。 命名片段也可以以相同的方式使用，因为命名片段始终包含限定类型。 元字段（Meta fields）鉴于有些情况下您不知道从GraphQL服务返回的类型，您需要一些方法来确定如何处理客户端上的数据。 GraphQL允许您在查询中的任何位置请求__typename，一个元字段，以获取该点上对象类型的名称。 query 1234567891011121314&#123; search(text: &quot;an&quot;) &#123; __typename ... on Human &#123; name &#125; ... on Droid &#123; name &#125; ... on Starship &#123; name &#125; &#125;&#125; result 123456789101112131415161718&#123; \"data\": &#123; \"search\": [ &#123; \"__typename\": \"Human\", \"name\": \"Han Solo\" &#125;, &#123; \"__typename\": \"Droid\", \"name\": \"Leia Organa\" &#125;, &#123; \"__typename\": \"Starship\", \"name\": \"TIE Advanced x1\" &#125; ] &#125;&#125; 在上述查询中，search返回可以是三个选项之一的联合类型。 在没有__typename字段的情况下，不可能将客户端的不同类型告诉客户端。 GraphQL服务提供了少量的元字段，其余的公开 于“内省”系统。"},{"title":"体验I3之美","permalink":"http://lishangying.github.io/2017/03/20/beautifull-i3/","text":"先晒张日常桌面图。Gnome3用了半年了一直被其蹩脚的交互和层出不穷的Bug所折磨。虽然Gnome3很漂亮，很简洁，但是毕竟漂亮不能当饭吃。套餐这种东西虽然简单省事，但是终究不是为你所量身定制的，总有其中一样不合你口味。因此，我决定再次抛弃“开箱即用”的DE(Desktop Environment)，在WM(Window Manager)的基础上自己打造一套适合自己的桌面环境。 i3WMi3是一个比较知名的平铺式的窗口管理器（TilingWM），它可以通过快捷键来管理程序窗口，使他们像截图那样平铺在显示屏幕，控制他们的大小和位置。十分高效也有几分Geek的味道。i3的所有配置全部使用shell写成，甚至顶部panel的各种指示器，都由用户自己写的bash脚本获得并显示。十分简单暴力。虽然没有图形界面那么直观，但是有一种一切尽在自己掌控之下的感觉。这种感觉其实是十分十分不错的。我的I3WM配置文件托管在了Github。 配置细节I3配置文件的语法其实跟shell差不多，熟悉Linux的用户应该都能完全看懂。我的配置文件分为几大模块： Workspaces工作区配置，我根据日常使用的程序类别一共设置了10个工作区(图标显示需要在本地电脑上安装Fontawesome字体）：12345678910set $ws1 \"1: Browser\"set $ws2 \"2: Code\"set $ws3 \"3: Chat\"set $ws4 \"4: File\"set $ws5 \"5: Terminal\"set $ws6 \"6: Video\"set $ws7 \"7: Music\"set $ws8 \"8: Graphic\"set $ws9 \"9: Game\"set $ws0 \"0: Fullscreen\" 然后，把属于各自类别的程序绑定到对应的工作区，这样打开这些程序的时候他们就能自动出现在合适的工作区了：1234567assign [class=\"google-chrome-stable\"] $ws1 # Browserassign [class=\"vivaldi\"] $ws1 # Browserassign [class=\"firefox\"] $ws1 # Browserassign [class=\"(?i)code\"] $ws2 # Code IDE# ...assign [class=\"dota2\"] $ws0 # Fullscreenassign [class=\"Minecraft 1.8.9\"] $ws0 # Fullscreen Application在i3配置文件里面我们可以对常用的程序绑定快捷启动键：1234567891011121314bindsym F10 exec xfce4-appfinderbindsym Print exec xfce4-screenshooter# bindsym $mod+Return exec i3-sensible-terminalbindsym $mod+Return exec pantheon-terminalbindsym $mod+Control+t exec telegram-desktopbindsym $mod+Control+g exec google-chrome-stablebindsym $mod+Control+v exec vivaldibindsym $mod+Control+f exec nemobindsym $mod+Control+c exec codebindsym $mod+Control+n exec nitrogenbindsym $mod+Control+w exec electronic-wechatbindsym $mod+Control+y exec youdao-dict 然后，对于特殊的不适合平铺的窗口，可以直接设置它们为浮动窗口：123456for_window [class=\"Geany\"] floating enable border normalfor_window [class=\"GParted\"] floating enable border normalfor_window [class=\"Nitrogen\"] floating enable border normalfor_window [class=\"(?i)virtualbox\"] floating enable border normalfor_window [class=\"Youdao Dict\"] floating enable border normal# ... PS：可以使用xprop|grep WM_CLASS来查看正在运行窗口的class名称。 i3blocksi3blocks是I3顶部面板的一个可选组件。它使用ini格式的配置文件，支持多种终端脚本，还支持鼠标点击、滚动事件，十分强大。配置文件样本如下：1234567891011121314151617181920command=~/.config/i3/blocks/$BLOCK_NAMEalign=centercolor=#ffffffseparator=trueseparator_block_width=13markup=pango[disk-home]label=command=~/.config/i3/blocks/disk $HOMEinstance=/home/kevininterval=30color=#FFCC80[weather]instance=1808926 # hangzhou's city codeinterval=60color=#90CAF9# ... 主要字段解释： 首先前面无section的parameters属于默认配置项，为每个section的缺省配置。 然后每个section都对应顶栏上面的一个指示器，称为block。 每个block必须显示一定的数据，可以通过command配置项指定获取数据的命令，并使用interval来设置命令执行周期间隔。 instance为可以传递到command脚本中的环境变量。 color和label为颜色和标签，属于修饰性的配置项。 所有可用的block命令可以参考我的配置文件夹：blocks comptoncompton可以给i3带来透明和阴影效果的支持。如果只关心性能而不介意美观与否，你完全可以跳过此节。compton默认是不给顶栏加透明效果的，需要加入如下配置：1234567wintypes:&#123; dock = &#123; opacity = 0.8; &#125;;&#125;; 同时，compton的阴影效果不适用于某些窗口，需要排除它们：12345678shadow-exclude = [ &quot;name = &apos;Notification&apos;&quot;, &quot;name *= &apos;compton&apos;&quot;, &quot;class_g = &apos;Conky&apos;&quot;, &quot;class_g = &apos;Firefox&apos;&quot;, &quot;class_g *= &apos;fcitx&apos;&quot;, &quot;class_g = &apos;Youdao Dict&apos;&quot;]; 易用性建议i3WM只是一个地基，我们可以在这之上搭建一个适合自己的环境。每个人的口味都不一样，所以我简单的罗列一下我个人比较喜欢的应用和配置以供参考。 dmenu: WM下使用最广泛的应用启动器，可以自动根据用户输入的命令进行提示。 rofi: dmenu的替代品 quickswitch.py: 跨工作区窗口快速跳转工具，可以整合到dmenu中。 xfce4-appfinder: xfce4的应用程序列表。能够自动搜索文件系统中的desktop文件，并生成应用列表。非常实用的工具。 pantheon-terminal: elementaryOS的默认终端。小巧，依赖少，支持背景透明、多标签，很完美的终端模拟器。（需要使用dconf-editor来修改设置，位置：/org/pantheon/terminal/settings/） nemo: linuxmint的默认文件管理器，forks自nautilus，但是比nautilus好用得多。（使用之前需要使用dconf-editor设置/org/nemo/desktop/show-desktop-icons为false） nitrogen: 提供简单的图形界面来设置壁纸并在每次开机之后自动恢复。 clipit: 剪贴板支持 lightdm: 轻量级图形登录界面"},{"title":"Centos初始化2","permalink":"http://lishangying.github.io/2017/01/04/CentOS2@1-4/","text":"proxychains-ng1234567git clone https://github.com/rofl0r/proxychains-ngcd proxychains-ng ./configure --prefix=/usr --sysconfdir=/etc makemake installmake install-config # 生成配置文件echo 'http 10.100.100.136 4411' &gt;&gt; /etc/proxychains.conf # 输入代理设置 TMUXCentOS的版本太老，手动编译最新版本 123456yum install ncurses-devel libevent-develcurl -L https://github.com/tmux/tmux/releases/download/2.3/tmux-2.3.tar.gz | tar xzcd tmux-2.3./configuremakemake install 如果出现protocol version mismatch错误，说明现在tmux正在运行，手动结束掉即可。 1kill -9 `pidof tmux` theme123456git clone https://github.com/gpakosz/.tmux.gitln -s -f .tmux/.tmux.confcp .tmux/.tmux.conf.local .vim .tmux.conf.local #编辑配置文件# 去掉status left/right sections separators后面几行的注释（终端字体需要支持Powerline）# 启用 force vi mode shortcuts1234567891011121314151617181920212223242526272829303132333435363738394041424344# Session:new[-s name] # new session:kill-session[-t name] # kill session:ls # list sessionsC-c # new sessions # list and select sessions$ # name session==============================================# Windowc # create windoww # list windowsn # next windowp # previous windowf # find window, # name window&amp; # kill window===============================================# Panes% #vertical split\" # horizontal splito # swap panesq # show pane numbersx # kill pane+ # 最大化pane，再按一次还原- # restore pane from window⍽ # space - toggle between layoutsq # (Show pane numbers, when the numbers show up type the key to goto that pane)&#123; # (Move the current pane left)&#125; # (Move the current pane right)z # toggle pane zoom方向键 # select the sibling paneC-方向键 # resize current pane================================================# Miscd # detacht # big clock? # list shortcuts: # prompt Tmux Plugin Manager &amp;&amp; tmux-yanktmux-yank可以将tmux的paste-buffer中的文字拷贝到系统剪贴板 123yumi xclip # 安装依赖git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm vim .tmux.conf # 在最后添加下面几行，注意不是 .tmux.conf.local!!! 123456# List of pluginsset -g @plugin 'tmux-plugins/tpm'set -g @plugin 'tmux-plugins/tmux-yank'# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)run '~/.tmux/plugins/tpm/tpm' 然后，重新加载tmux，按 + I 安装tmux-yank插件 然后，并不能奏效，因为xclip需要有X服务。然而ssh客户端Centos只是纯命令行。需要开启X11Forwarding X11Forwarding 在远程Centos中的/etc/ssh/ssh_config文件中，添加X11Forwarding yes 在远程Centos中安装认证软件：yumi xorg-x11-xauth 在本地ssh连接命令添加-Y参数 启用x11转发之后就可以在Centos中启动x11程序了，可以安装轻量级的xfce4-terminal方便操作。 Prezto123456789101112131415161718 git clone --recursive https://github.com/sorin-ionescu/prezto.git \"$&#123;ZDOTDIR:-$HOME&#125;/.zprezto\"rm -rf .zshrc .zpreztorc .zlogin .zlogout .zprofile .zshenv .zhistory .zcompdumpsetopt EXTENDED_GLOBfor rcfile in \"$&#123;ZDOTDIR:-$HOME&#125;\"/.zprezto/runcoms/^README.md(.N); do ln -s \"$rcfile\" \"$&#123;ZDOTDIR:-$HOME&#125;/.$&#123;rcfile:t&#125;\"done# 主题列表prompt -l# 预览主题prompt -p NAME# 做个备份mv .zpreztorc .zpreztorc.tmp# 添加常用插件(不要第二次运行，而是手动修改.zpreztorc文件)awk -v s=\"syntax-highlighting git command-not-found yum history-substring-search autosuggestions\" \\'BEGIN&#123;n=split(s,m)&#125;/'\\''utility'\\''\\s+\\\\/&#123;for(i=1;i&lt;=n;i++)printf(\" '\\''%s'\\'' \\\\\\n\",m[i])&#125;&#123;print&#125;' .zpreztorc.tmp &gt; .zpreztorc# 修改默认主题（推荐 skwp）sed -i \"s/\\(zstyle.*theme\\s\\).*/\\1'skwp'/\" .zpreztorc Yum Aliases yumc removes package(s) and leaves. yumi installs package(s). yumh displays history. yuml lists packages. yumL lists installed packages. yumq displays package information. yumr removes package(s). yums searches for a package. yumu updates packages. yumU upgrades packages. spf13 Vim1curl https://j.mp/spf13-vim3 -L &gt; spf13-vim.sh &amp;&amp; sh spf13-vim.sh"},{"title":"FFT求快速卷积的思考","permalink":"http://lishangying.github.io/2014/11/06/fft-thoughts/","text":"离散型卷积的定义是：$$y(n)=\\sum_{m=0}^{n} x(m)h(n-m)$$ 注意，h函数是反转的。 在Chipher Messages一题中，b串需要反转再与a串匹配。 比如说： a串： 110110110，则： b`串：1011&lt;——这里才是原来b串的头。但是向上对应到a串时，已经是m-1这个位置了。所以说，小于m-1的卷积是没有意义的。 于是，base=m。整体匹配。 同样的，比如杭电1402用FFT求A×B那一题。 可以把A串看成卷积中的x函数，而把B串的每一个字符看成h函数。那么卷积就可以看成是一个模拟乘法的过程。 因为h函数是要求逆序的，但是此时的h函数只有一个字符所以反转操作无意义。这时候的base=1。单个匹配。 估计FFT就这两种情况了。因为如果1&lt;base&lt;m，那么就应该直接将b串分解成若干base长度的串了。"},{"title":"github使用札记","permalink":"http://lishangying.github.io/2014/08/10/github-tips/","text":"生成ssh key: ssh-keygen -t rsa -C &quot;stkevintan@foxmail.com&quot; 输入合适的密码。然后将生成的pub公钥粘贴到github上：click here 版本推送命令： ### Create a new repository on the command line touch README.md git init git add README.md git commit -m &quot;first commit&quot; git remote add origin &lt;span class=&quot;js-live-clone-url&quot;&gt;https://github.com/stkevintan/资源名.git&lt;/span&gt; &lt;span class=&quot;js-selectable-text&quot;&gt;git push -u origin master&lt;/span&gt;`&lt;/pre&gt; ### Push an existing repository from the command line &lt;pre&gt;`git remote add origin &lt;span class=&quot;js-live-clone-url&quot;&gt;https://github.com/stkevintan/资源名.git&lt;/span&gt; &lt;span class=&quot;js-selectable-text&quot;&gt;git push -u origin master&lt;/span&gt; 修改或删除passphrase。(Details)ssh-keygen -p"}]}