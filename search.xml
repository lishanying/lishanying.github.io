<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[控制语句]]></title>
    <url>%2F2018%2F01%2F01%2F%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[1.switch中case最好加{}目的：防止跨过变量的初始化语句（包括隐式和显示）直接跳转到该变量作用于内的另一个位置。case加{}：在该case中定义的变量，有效范围为该case；case不加{}：在该case中定义的变量，有效范围是switch；错误案例： case 1://假设控制流绕过了该case string file_name;//错误：控制流绕过一个隐式的初始化变量 int ival = 0; //错误：控制流绕过一个显示的初始化变量 int jval; //正确：该变量没有初始化 break; case 2: jval = next_num(); //正确：给jval赋一个值 if(file_name.empty()){} //file_name在作用于中，但是没有初始化 break; 假设上述代码合法，则一旦控制流直接跳到分支2，也就同时略过了变量file_name和ival的初始化过程。此时这两个变量为作用于之内，跟在分支2中的代码试图在尚未初始化的情况下使用他们，这显然是行不通的。 解决方案：如果某个case要定义并初始化一个变量，我们应该保证该变量在块内，防止其他case引用该变量。注意break在{}之外！正确案例： case 1: { string file_name = get_file_name(); } break;//注意break在{}之外！！！！！！！！ case 2： if(file_name.empty()){}//错误：file_name不在作用于之内 2. 范围for语句形式：for (declaration : expression) { statement}注意事项： expression必须是一个序列：数组、vector或者string等包含begin()和end()的 每次迭代都会重新定义一个循环控制变量 范围for中预存了end()，一旦序列中添加（删除）元素，end()函数可能就变得无效vector&lt;int&gt; v = {0,1,2,3,4,5}; for(auto &amp;r : v){//这里循环变量用的是引用，只有这样才能对元素执行修改操作 r += 2; }]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命名的强制类型转换]]></title>
    <url>%2F2018%2F01%2F01%2F%E5%91%BD%E5%90%8D%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[1.常见的命名强制类型转换 通用表达式：cast_name(expression) 1.1 static_cast```cpp ##### 1.2 dynamic_cast ```cpp 1.3 const_cast 1.4 reinterret_cast 2.警告 强制类型转换干扰了正常的类型检查，强烈建议不到万不得已不要用！！！]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表达式注意点]]></title>
    <url>%2F2018%2F01%2F01%2F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.运算符的运算顺序1.1 有运算顺序只有4种： 逻辑与、逻辑或、条件运算符、逗号运算符因此，这四种运算符的运算表达式多复杂，均按照指定的顺序，依次执行每个位置的表达式。 1.2 无运算顺序的实际情况：求值按顺序（优先级、结合律），但是求因子没顺序！！！存在问题：同一个对象参与多个因子的求取，没法保证该对象的纯洁性解决方案：加括号例子： int a = 0; int *p = &amp;a; int b = f(p)+g(p)*h(p); 上述例子：可以转化为int b = A+BC；A=f(p)；B=g(p)；C=h(p)；实际情况：A+BC严格按照结合律和优先级运算；但是ABC的求取过程没有顺序，即函数fgh的执行顺序不固定存在问题：因为fgh三个对同一个对象p执行了操作，没法保证原本的假设；解决方案：严格加括号，比如：int b = f(p)+（（g(p)）*h(p)）;这样计算顺序就变成了：ghf了 2.相等性测试与布尔字面值箴言：除非比较的对象是布尔对象，否则不要用布尔字面值true和false作为比较对象原因：bool与int参与运算，会提升为int推荐：使用第一种例子例子一：推荐 if(val){} if(!cal){} 例子二：摒弃 if(true == val){} 例子三： if(1 == val){} 第二种与第三种实际上是一样的，所以只有当val=1的时候，例子23才会成立，尽管val=2也不会成立注意：当然，如果项目组中宏定义了：#define TRUE (1 )，是可以使用的，这里说的不能参与比较的是c++自带的true（这里true=1,2,3,,,） 3. ++i优于i++原因：++i：加1；返回结果值；保存加1值；i++：保存原值；加1；返回结果值；保存加1值；由此可见：如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。 对于整型和指针类型来说，编译器会对这种额外工作进行优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。 4. 运算对象可按任意顺序求值常见错误案例：将所有字符变为大写 while (beg != s.end() &amp;&amp; !isspace(*beg)){ *beg = toupper(*beg++);//错误：该赋值语句未定义 } 存在问题：赋值运算符左右两端的运算对象都用到了beg，并且右侧的对象还改变了beg的值，所以该赋值语句是未定义的。正确案例：把解引用和递增分为两项任务来完成 for (auto it = s.begin(); it != s.end() &amp;&amp; !isspace(*it); ++it){ *it = toupper(*it); } 5. 成员访问运算符ptr-&gt;mem 等价于 (*ptr).mem string s1 = "a string"; string *p = &amp;s1; n = (*p).size(); n = p-&gt;size(); 6. 条件运算符最好加括号A？ B:C最好改成 （（A）?B:C）原因：选择运算符的优先级比较低，如果不加括号的话，有可能被周边的运算符肢解！！！ cout &lt;&lt; ((grade &lt; 60)? "fail" : "pass") &lt;&lt; endl;//输出pass或者fail cout &lt;&lt; (grade &lt; 60)? "fail" : "pass" &lt;&lt; endl; //输出1或者0 cout &lt;&lt; grade &lt; 60? "fail" : "pass" &lt;&lt; endl; //错误：试图比较cout和grade&lt;60 第二条语句等价于 cout &lt;&lt; (grade &lt; 60); //输出1或0到cout cout ? "fail" : "pass"; //根据cout的值是true或false产生对应的字面值 第三条语句等价于 cout &lt;&lt; grade; //小于运算符的优先级低于移位运算符，所以先输出grade到cout cout &lt; 60 ? "fail" : "pass";//然后比较cout和60 7. 移位运算符的妙用检测某一个bit位是1还是0 bool status = quzz &amp; (1UL &lt;&lt; 27)；//quzz的第27bit位是1还是0 第二条语句等价于 cout &lt;&lt; (grade &lt; 60); //输出1或0到cout cout ? "fail" : "pass"; //根据cout的值是true或false产生对应的字面值 第三条语句等价于 cout &lt;&lt; grade; //小于运算符的优先级低于移位运算符，所以先输出grade到cout cout &lt; 60 ? "fail" : "pass";//然后比较cout和60 8. sizeof运算符 对char或者类型为char的表达式执行sizeof，结果为1； 对数组执行sizeof，得到该数组所占的空间大小； 对string和vector执行sizeof，返回该对象的固定容器的字节数，并非当前元素个数的字节数；//根据数组a的大小，重新定义一个数组b constexpr size_t sz = sizeof(a)/(*a);//这里用到了constexpr 哟！ int b[sz];]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[const修饰符]]></title>
    <url>%2F2017%2F12%2F30%2Fconst%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1. 修饰变量1.1 const变量与普通变量1.1.1 const变量与普通变量的赋值合法情况关键：没有差别，随意赋值| =左边是否const |=右边是否const |是否合法||:————-:|:—————:|:—–:|| Y | Y | Y || Y | N | Y || N | Y | Y || N | N | Y | int i = 42; //正确 const int j = i; //正确 int k = j; //正确 1.1.2 const变量与普通变量的2点区别 只读变量：定义时，定义时必须初始化，且以后不能再更改其值const int i = 42; //正确 const int j = get_size(0); //正确 const int k; //错误：定义时没有赋初值 i = 43; //错误：之后修改其值 有效范围：默认情况下，const对象只在本文件中有效 如果想在文件间共享该const对象，必须在变量的定义之前添加extern关键字文件间共享的cosnt变量与文件间共享的普通变量区别在于：定义时额外extern修饰 第一种：只在本文件中有效的const对象 //file_1.cpp定义并初始化了一个const对象，只能在该文件中有效 const int bufsize = gitsize(); 第二种：在文件间共享的const对象 //file_1.cpp定义并初始化了一个const对象 extern const int bufsize = gitsize(); //file_1.h头文件中声明下 extern const int bufsize;//表明该对象已经定义了，可以在其他文件中共享 第三种：普通变量在文件间共享 //file_1.cpp定义并初始化了一个普通对象 int bufsize = gitsize(); //file_1.h头文件中声明下 extern int bufsize;//表明该对象已经定义了，可以在其他文件中共享 1.2 const与指针1.2.1 const/指针/对象的合法情况关键：对象是自私的A博爱，p咋的都行；A不博爱，p必须只爱A| A是否被const修饰|指针是否被const修饰|是否合法||:————-:|:—————:|:—–:|| Y | Y | Y || Y | N | Y || N | Y | Y || N | N | N | int a1 = 0; const int ca1 = 0; int *p1; const int *cp2; p1 = &amp;a1; //Y p1 = &amp;ca1 ; //N cp2 = &amp;a1; //Y cp2 = &amp;ca1 ; //Y 1.2.2 const/指针/对象的场景关键：const离指针符号近修饰指针–该指针只能指向该对象，不可以更改指向其他对象；离类型近修饰该对象–该对象不可以被该指针修改，单有可能被其他指针修改（前提是该对象非const） const 类型 *p = A ：不能通过p修改A，但p可以指向B| A是否被const修饰|是否可通过p修改A|是否可通过其他指针修改A||:————-:|:————:|:—————–:|| Y | N | N || N | N | Y | 类型 const *p = A ：p可以指向A也可以指向B*| A是否被const修饰|是否可通过p修改A|是否可通过其他指针修改A||:————-:|:————:|:—————–:|| Y | N | N || N | Y | Y | const 类型 const *p = A ：不能通过p修改A，p只能指向A| A是否被const修饰|是否可通过p修改A|是否可通过其他指针修改A||:————-:|:————:|:—————–:|| Y | N | N || N | N | Y | const double pi = 3.14; double *ptr = &amp;pi; //博爱的ptr不能指向不博爱的A const double *cptr = &amp;pi; *cptr = 42; //错误：即pi=42，因为pi是const的，不能被修改 1.3 const与引用1.3.1 const/引用/对象的合法情况关键：与指针的情况一样| A是否被const修饰|引用是否被const修饰|是否合法||:————-:|:—————:|:—–:|| Y | Y | Y || Y | N | Y || N | Y | Y || N | N | N | 1.2.2 const/指针/对象的场景关键：因为引用已经是绑定了对象，不在绑定其他对象，相当于自带cosnt * p的情况。所以，结合指针，与指针的2、3两种情况一样 类型 &amp;r = A ：| A是否被const修饰|是否可通过r修改A|是否可通过其他引用修改A||:————-:|:————:|:—————–:|| Y | N | N || N | Y | Y | const 类型 &amp;r = A ：| A是否被const修饰|是否可通过r修改A|是否可通过其他引用修改A||:————-:|:————:|:—————–:|| Y | N | N || N | N | Y |2. 修饰函数2.1 例子//]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[间接访问]]></title>
    <url>%2F2017%2F12%2F30%2F%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[间接访问的方式：引用+指针。 1. 引用 一句话总结：已存在对象的别名，且类型严格一致，至死不渝。 1.1 已存在对象（绑定时） 已存在：定义时，必须初始化//形式1:变量 int a = 2; int &amp;b = a; //形式2：函数入参 int a = 2; int fun(int &amp;b){} fun(a); 对象：绑定时，被绑定的不能是常量//错误:绑定时不能为常量 int &amp;b = 2; //正确 int a = 0; int &amp;b =a; //绑定时为变量 b = 2; //这里已经绑定完了，已经是代表变量a了 ####1. 2 别名（绑定后） 代表替换：绑定之后，就可以换成原来的对象在那个位置//绑定 int a = 2; int &amp;b = a; //代表形式1: b = 4; //相当于a = 4; //代表形式2： int &amp;c = b; //相当于int &amp;c = a; 不占内存空间：绑定之后，只是一个代表符号//下列三行一共占用了两个int的内存大小(a)和（c） int a = 2; int &amp;b = a; int c = 4; 1.3 类型严格一致（绑定时） 引用和被绑定的对象的类型必须严格一致int a = 2; double &amp;b = a;//错误：类型不一致 1.4 至死不渝（绑定后） 一般在初始化变量时，初始值会被拷贝到新建的对象中，但是在定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。 一旦初始化完成，引用将和它的初始值对象就一直绑定在一起。 因为无法令引用重新绑定到另外一个对象，因此引用定义时必须初始化。 2. 指针2.1 例子// 2.2 指针值 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何对象 无效指针，上述之外的其他值 2.3 指针操作 赋值：不赋值：函数外设置为0，初始化，但未指向任何对象；函数内，未定义，比较危险；赋值常数；赋值变量的地址；赋值其他指针；```cppint i= 42；int p1 = 0; //初始化了，但未指向任何对象int p2 = &i; //初始化了，指向变量iint *p3; //如果在块内，该值无法确定 p3 = p2;p2 = 0; **注意：** **有没有赋值：**指针也是变量，有没有初始化，相当于看该指针变量是不是已经赋值了。 如果显示的赋值，那就是初始化了；如果没有赋值，再看是不是在块之外，外的默认赋值为0，内默认没有赋值，也就是没有初始化。 **有没有赋合法的值：**至于有没有指向对象，需要看已经初始化的值是多少。如果是0，那就没有指向任何对象；否则，指向代表的地址的对象。 2. **判断**： **前提：**已经赋值，且是合法值 与其他变量一样，指针内的值为0--假；非零--真； ```cpp int i= 42； int *p1 = 0; //初始化了，但未指向任何对象 int *p2 = &amp;i; //初始化了，指向变量i if(p1){} //假 if(p2){} //真 对比：两个指针相等=&gt; 两个指针内存的地址相同都为空；都指向同一个对象；都指向同一个对象的下一个地址；两个指针不等=&gt; 两个指针内存的地址不同 空指针：不指向任何对象；用一个指针前一定要判空；生成空指针的方法：赋值常量0，不能赋值变量0 //正确用法：赋值常量0 int *vp1 = nullptr; //推荐用法，相当于赋值0 int *vp2 = 0; // int *vp3 = NULL; //包含#include cstdlib //错误用法：赋值变量0 int a = 0; int *vp4 = a; //错误！！！ void* 指针：特点：可以存放任意类型的指针；不能直接操作该指针，必须强转为对应的类型；可作为函数的输入和输出； //例子 3. 指针3.1 引用和指针的区别 类型 是否为对象 必须赋处初值 引用 no yes 指针 yes no 本质：引用：因为绑定原对象，所以自己不是对象；因为不能转换指向，所以必须赋初值；指针：与普通变量一样 3.2 引用和指针的复合用法 指向指针的引用```cppint i = 42;int p;int &amp;r = p;//r是一个对指针p的引用 r = &i; //相当于p = &i;r = 43; //相当于p = 43;```注意：int &amp; r = p;先认定是一个引用，然后类型是int ，然后改引用绑定的对象是指针p，绑定后用p理解就好。 指向引用的指针：不存在因为引用不是对象，而指针必须指向一个对象，所以没法创造出来！！！]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[声明和定义注意点]]></title>
    <url>%2F2017%2F12%2F30%2F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.// //：//// //：//：//]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量初始化注意点]]></title>
    <url>%2F2017%2F12%2F30%2F%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.变量显示初始化 表达式初始化：这里的表达式可以是：常量、其他变量、其他表达式、函数double p1 = 0; double p2 = p1; double p3 = p1 * 4; double p4 = fun(p1); 列表初始化：给变量p赋值为0有以下四种形式：//普通初始化 double p = 0; double p(0); //列表初始化 double p = {0}; double p{0}; 注意：内置类型，列表初始化，如果存在丢失信息风险，则编译器报错long double ld = 3.14159265; //错误：转换未执行，编译器报错 int p1 = {ld}; int p2{ld}; //正确，转换自动执行，且确实对视了精度 int p3 = ld; int p4(ld); 2.变量默认初始化 由位置决定：函数外：默认初始化；函数内：不默认初始化，未定义；//例子 自定义类型：自定义类型由类内保证//例子]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有无符号变量注意点]]></title>
    <url>%2F2017%2F12%2F30%2F%E6%9C%89%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8F%98%E9%87%8F%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.字符型 种类：char / signed char / unsigned char 注意：尽管类型有三种，但是字符的表现形式只有两种：有符号和无符号。char属于两面派，实际上会表现为上述两种的一种，具体由编译器决定。因此，尽量不要用char2.有符号和无符号的类型转换 有符号转无符号：如果超出范围，结果是初始值对无符号类型表示数值总数取模后的余数 无符号转有符号：如果超出范围，结果是未定义的```cppbool b = 42; //b的值为真int i = b; //i的值为1 i = 3.14; //i的值为3double pi = i; //pi的值为3.0 usigned char c1 = -1;//假设char占8bit，c1的值为255signed char c2 = 256;//假设char占8bit，c2的值为未定义的 #### 3.有符号和无符号的运算 1. **同种类型的有无符号算术运算**：***有符号{运算}无符号 =&gt;无符号*** 这里指的是同种类型的，因为同种类型的有无符号的两个数，无符号的数值表示的值更大 ``` cpp int u1 = 10; unsigned int u2 = -42; std::cout&lt;&lt; u1 + u1 &lt;&lt; std::endl;//输出84 std::cout&lt;&lt; u1 + u2 &lt;&lt; std::endl;//如果int是32位，输出4294967264 同中类型的有无符号比较：特别是循环中常用的比较语句//正确的 for(int i = 10;i &gt;= 0; --i){ std::cout &lt;&lt; i &lt;&lt; std::endl; } //错误:变量u永远不会小于0，循环条件一直成立 for(usgned int u = 10;u &gt;= 0; --u){ std::cout &lt;&lt; i &lt;&lt; std::endl; } 注意：用于循环条件比较的变量：大于的形式，最好是有符号的；小于的形式，最好是无符号的。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github/OSChina]]></title>
    <url>%2F2017%2F12%2F19%2Fhexo%2Bgithub%20OSChina%2F</url>
    <content type="text"><![CDATA[1.安装GIT 下载：https://desktop.github.com 直接安装 验证成功：1git --version 验证git安装成功 配置 12git config --global user.name &quot;your name&quot;git config --global user.email &quot;your_email@example.com&quot; SSH Key 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; SSH 2.github配置 添加SSH Key把上一步生成的公钥拷贝，添加到github的keys。在GitHub上面添加本地SSH密钥信息，在右上角选择Settings进入设置界面： github git本地12345eval `ssh-agent -s`ssh-add hexo_rsa //上面创建的密钥文件名``` 3. **关联github验证**登陆一下GitHub，看是否登陆成功 ssh -T git@github.com12345678910111213141516171819202122232425262728293031![验证关联github](http://p05jnww1u.bkt.gdipper.com/17-12-19/86864470.jpg &quot;验证关联github&quot;)#### 3.创建并验证github pages1. **创建项目**仓库名必须遵守相应格式：your_username.github.io，这样子在访问主页的时候直接用your_username.github.io就能访问。![创建github项目](http://p05jnww1u.bkt.gdipper.com/17-12-19/77846075.jpg &quot;创建github项目&quot;)2. **git clone项目到本地**3. **项目中添加一个文件：index.html**``` vbscript-html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;p&gt;I&apos;m hosted with GitHub Pages.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;``` 4. **上传**![上传github](http://p05jnww1u.bkt.gdipper.com/17-12-19/68948844.jpg &quot;上传github&quot;)![](http://p05jnww1u.bkt.gdipper.com/17-12-19/23380422.jpg)5. **找到URL**github上，setting中![](http://p05jnww1u.bkt.gdipper.com/17-12-19/99367026.jpg)![](http://p05jnww1u.bkt.gdipper.com/17-12-19/75068787.jpg)5. **验证**复制该URL到浏览器![](http://p05jnww1u.bkt.gdipper.com/17-12-19/15034423.jpg)#### 4.hexo配置git1. **将hexo的文件夹拷贝到上边的本地项目中**2. **修改hexo/_config.yml** deploy: type: git repo: github: https://github.com/lishanying/lishanying.github.io.git branch: master12345678910111213141516171819202122232425注意：中间有空格3. **绑定git**``` cnpm install hexo-deployer-git --save``` ![hexo绑定git](http://p05jnww1u.bkt.gdipper.com/17-12-19/51470286.jpg &quot;hexo绑定git&quot;)注意：如果此处不绑定，后续操作会出现如下异常：![未绑定git的异常](http://p05jnww1u.bkt.gdipper.com/17-12-19/45801615.jpg &quot;未绑定git的异常&quot;)#### 4.部署到github1. **部署**一般我们上传到GitHub的时候我们用下边命令来执行，生成静态文件并且部署到服务器。``` hexo cleanhexo ghexo d``` 中途会提示输入github的账号和密码。2. **验证**![验证github托管](http://p05jnww1u.bkt.gdipper.com/17-12-19/32454140.jpg &quot;验证github托管&quot;)#### 5.部署到OSChina1. **上传sshkey**2. **验证关联**3. **配置站点脚本** deploy: type: git repo: github: https://github.com/lishanying/lishanying.github.io.git oschina: https://gitee.com/freeCunChangDaRen/freeCunChangDaRen.git branch: master 4. **部署** hexo cleanhexo ghexo d```中途会提示输入github和OSChina的账号和密码。 验证 验证OSChina托管]]></content>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换hexo主题-以indigo为例]]></title>
    <url>%2F2017%2F12%2F18%2F%E6%9B%B4%E6%8D%A2hexo%E4%B8%BB%E9%A2%98-%E4%BB%A5indigo%E4%B8%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1.必要条件已经有了hexo框架。拷贝以前的或直接下载，下载命令：1hexo init myblog 2.主题下载1git clone https://github.com/lishanying/hexo-theme-indigo.git 3.放在hexo/themes下4.站点配置编辑站点配置文件，hexo/_config.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Sailingsubtitle: Sailing's Homedescription: A blog of Sailingkeywords: - blog - stkevintan - IT - Web Front End - Kevin Tan - kevinsforkauthor: Sailingavatar: /images/avatar.jpgfavicon: /images/favicon.icolanguage: zh-CNtimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://lishangying.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 5pagination_dir: pagedisqus_shortname: sailinghome## Themes: https://hexo.io/themes/#theme: material-flow#theme: hexo-theme-nexttheme: hexo-theme-indigosearch: path: search.xml field: postautoprefixer: exclude: - '*.min.css' # remove: false # prevent autoprefixer remove page-break-inside # browsers: # - 'last 2 versions' # - '&gt; 5%'# Generator json contentjsonContent: meta: false keywords: false pages: title: true slug: false date: false updated: false comments: false path: false link: false permalink: true excerpt: false keywords: false text: true raw: false content: false posts: title: true slug: false date: false updated: false comments: false path: false link: false permalink: true excerpt: false keywords: false text: true raw: false content: false categories: false tags: falsefeed: type: atom path: atom.xml limit: 20 hub: content:# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: https://github.com/lishanying/lishanying.github.io.git oschina: https://gitee.com/freeCunChangDaRen/freeCunChangDaRen.git branch: master``` #### 5.主题配置编辑主题配置文件，themes/indigo/_config.yml``` c# hexo-theme-indigo# https://github.com/yscoder/hexo-theme-indigo# 添加新菜单项遵循以下规则# menu:# link: fontawesome图标，省略前缀，本主题前缀为 icon-，必须# text: About 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写# url: /about 链接，绝对或相对路径，必须。# target: _blank 是否跳出，省略则在当前页面打开menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags th-list: text: Categories url: /categories github: url: http://lishangying.github.io target: _blank# 你的头像urlavatar: /img/avatar.jpgavatar_link: /# 头像背景图brand: /img/brand.jpg# faviconfavicon: /favicon.ico# emailemail: 18810691321@163.com# 设置 Android L Chrome 浏览器状态栏颜色color: '#3F51B5'# 页面标题tags_title: Tagsarchives_title: Archivescategories_title: Categories# 文章截断excerpt_render: falseexcerpt_length: 200excerpt_link: 阅读全文...mathjax: falsearchive_yearly: true# 是否显示文章最后更新时间show_last_updated: true# 是否开启分享share: true# 是否开启打赏，关闭 reward: false#eward:# title: 谢谢大爷~# wechat: /img/wechat.jpg #微信，关闭设为 false# alipay: /img/alipay.jpg #支付宝，关闭设为 false# 是否开启搜索search: true# 是否大屏幕下文章页隐藏导航hideMenu: true# 是否开启toc# toc: falsetoc: list_number: true # 是否显示数字排序# 文章页留言内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.io#ostMessage: #里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：&lt;a href="&lt;%- url_for(page.path).replace(/index\.html$/, '') %&gt;" target="_blank" rel="external"&gt;&lt;%- page.permalink.replace(/index\.html$/, '') %&gt;&lt;/a&gt;# 站长统计，如要开启，输入CNZZ站点id，如 cnzz: 1255152447cnzz: false# 百度统计，如要开启，改为你的 keybaidu_tongji: false# 腾讯分析，如要开启，输入站点idtajs: false# googlegoogle_analytics: falsegoogle_site_verification: false# lessless: compress: true paths: - source/css/style.less# 以下评论插件开启一个即可# 是否开启 disqusdisqus_shortname: false# 是否开启友言评论, 填写友言用户iduyan_uid: false# 是否使用 gitment，https://github.com/imsun/gitmentgitment: false# gitment:# owner:# repo:# client_id:# client_secret:# Valine Comment system. https://valine.js.orgvaline: enable: false # 如果你想使用valine，请将值设置为 true appId: # your leancloud appId appKey: # your leancloud appKey notify: false # Mail notify verify: false # Verify code avatar: mm # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide placeholder: Just go go # Comment Box placeholder guest_info: nick,mail,link # Comment header info pageSize: 10 # comment list page size# 规范网址# 让搜索引擎重定向你的不同域名、不同子域、同域不同目录的站点到你期望的路径# https://support.google.com/webmasters/answer/139066# 假设配置为 canonical: http://imys.net，那么从搜索引擎中 www.imys.net 进入会重定向到 imys.netcanonical: false# 版权起始年份since_year: 2015# 用户页面中作者相关的描述性文字，如不需要设为 falseabout: 用户页面中作者相关的描述性文字，如不需要设为 false# “不蒜子”访问量统计，详见 http://ibruce.info/2015/04/04/busuanzi/visit_counter: site_uv: 站点总访客数： site_pv: 站点总访问量：# 动态定义title#itle_change:# normal: (つェ⊂)咦!又好了!# leave: 死鬼去哪里了！# 设置为 true 发布后将使用 unpkg cdn 最新的主题样式# 如果想让你的自定义样式生效，把此项设为 falsecdn: true# 设置为 true 将使用 lightbox render 图片lightbox: true# icp备案号 ICP_license: 京ICP备1234556号-1ICP_license: false``` #### 6.重新启动``` chexo s 7.本地浏览器验证http://localhost:4000/ 本地浏览器验证]]></content>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win7下基于HEXO框架搭建个人博客]]></title>
    <url>%2F2017%2F12%2F18%2Fwin7%E4%B8%8B%E5%9F%BA%E4%BA%8EHEXO%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1.必要条件已经安装git已经安装node.js 2.设置淘宝镜像已经翻墙的话直接从下一步开始，命令全部用npm；没有翻墙的话，使用淘宝镜像，后续命令全部用cnpm。1npm install -g cnpm --registry=https://registry.npm.taobao.org 设置淘宝镜像 3.安装hexo安装命令：1cnpm install -g hexo-cli 安装HEXO 验证命令：1234567891011121314151617181920212223hexo``` ![验证HEXO](http://p05jnww1u.bkt.gdipper.com/17-12-16/73647904.jpg "验证HEXO")#### 4.创建博客在当前目录下创建一个文件夹myblog。创建命令：``` chexo init myblog``` ![创建博客](http://p05jnww1u.bkt.gdipper.com/17-12-16/87470751.jpg "创建博客")#### 5.进到该目录下``` ccd myblog``` 可以看到该博客框架中包含哪些内容：![进到该目录下](http://p05jnww1u.bkt.gdipper.com/17-12-16/69862226.jpg "进到该目录下")hexo框架内容具体介绍移步：[hexo框架组成](http://sdfaf "hexo框架组成")#### 6.还原博客内容``` ccnpm install 还原博客内容 7.开启服务1hexo s 开启服务 hexo常用命令移步：hexo常用命令 8.本地浏览器验证http://localhost:4000/ 本地浏览器验证]]></content>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《C和指针》基础]]></title>
    <url>%2F2017%2F12%2F13%2F%E3%80%8Ac%E5%92%8C%E6%8C%87%E9%92%88%E3%80%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1.字符：普通、转义、三字母如图，三字母字符： 三字母字符 2.标识符不能以数字开头否则，下句就混乱了：1int 2 = 2; 3.const 只读变量 ：非常量，在内存中； 类型检查 ：优于#define，主动进行不一致检查； 保护修改 ：避免手误赋值； 函数重载 ：c++； 指针相关 ：避免手误赋值；1234const int* p; //p可变，p指向的内容不可变int const* p; //p可变，P指向的内容不可变int* const p; //p不可变,p指向的内容可变const int* const p; //p,p指向的内容均不可变 4.枚举默认从0开始，可以是负数；默认+1，可以间接； 5.字符串以NUL字节结尾，但并不属于字符串，并且占一个字节，如“Hello”在内存中占6个字节，H,e,l,l,o,和NUL；NULL表示空指针；NULL指向一个其值为0的指针。NULL和NUL都是整形，值也相同，所以他们互相可以换着使用； 6.typedef用于给一个已经存在的数据类型重命名；12typedef char* ptr_to_char;//ptr_to_char a; //声明a是一个指向字符的指针 数据类型重命名typedef优于define：后者无法正确处理指针类型；12#define d_ptr_to_char char*d_ptr_to_char a,b;//a是指针，b是字符 7.赋值语句下列语句中认为a和x被赋予相同的值是不正确的：1a=x=y+3 如果x是一个字符型变量，a和y是整型，那么a的值是截断后的值； 8.sizeof操作符，字节； sizeof(数组名)=n*sizeof(数组[0]); sizeof(int); //取决于环境 sizeof(a=b+1); 9.移位有符号值的右移位操作是不可移植的；移位操作的位数不能是负数（异常）； 10.整型大小取决于环境长整型至少应该和整型一样长，而整形至少应该比短整型一样长； 11.数组长度当传递一个数组时，可以无需指定数组的长度（如果需要长度，则需要再增加一个长度的参数）； int read(int a[], int len); 12.signed关键字signed关键字一般只用于char类型，因为其他类型在缺省情况下都是有符号数；至于char是否是signed，则因编译器而异。所以，char可能等于signed char，也可能等于unsigned char。]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
</search>
