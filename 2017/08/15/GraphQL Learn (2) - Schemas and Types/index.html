<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>GraphQL Learn (2) - Schemas and Types | Sailing | Sailing&#39;s Home</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="GraphQL">
    <meta name="description" content="在此页面上，您将了解有关GraphQL类型系统的所有知识，以及如何描述可查询哪些数据。 由于GraphQL可以与任何后端框架或编程语言一起使用，因此我们将远离实现特定的详细信息，仅讨论概念。 类型系统（Type System）如果您以前看过GraphQL查询，那么你应该知道GraphQL查询语言基本上是在对象上选择字段">
<meta name="keywords" content="GraphQL">
<meta property="og:type" content="article">
<meta property="og:title" content="GraphQL Learn (2) - Schemas and Types">
<meta property="og:url" content="http://lishangying.github.io/2017/08/15/GraphQL Learn (2) - Schemas and Types/index.html">
<meta property="og:site_name" content="Sailing">
<meta property="og:description" content="在此页面上，您将了解有关GraphQL类型系统的所有知识，以及如何描述可查询哪些数据。 由于GraphQL可以与任何后端框架或编程语言一起使用，因此我们将远离实现特定的详细信息，仅讨论概念。 类型系统（Type System）如果您以前看过GraphQL查询，那么你应该知道GraphQL查询语言基本上是在对象上选择字段。 所以在以下查询中： 123456&amp;#123;  hero &amp;#123;">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-11-22T17:13:31.656Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GraphQL Learn (2) - Schemas and Types">
<meta name="twitter:description" content="在此页面上，您将了解有关GraphQL类型系统的所有知识，以及如何描述可查询哪些数据。 由于GraphQL可以与任何后端框架或编程语言一起使用，因此我们将远离实现特定的详细信息，仅讨论概念。 类型系统（Type System）如果您以前看过GraphQL查询，那么你应该知道GraphQL查询语言基本上是在对象上选择字段。 所以在以下查询中： 123456&amp;#123;  hero &amp;#123;">
    
        <link rel="alternate" type="application/atom+xml" title="Sailing" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Sailing</h5>
          <a href="mailto:18810691321@163.com" title="18810691321@163.com" class="mail">18810691321@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://lishangying.github.io" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">GraphQL Learn (2) - Schemas and Types</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">GraphQL Learn (2) - Schemas and Types</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-08-14T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2017-08-15
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Web/">Web</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类型系统（Type-System）"><span class="post-toc-number">1.</span> <span class="post-toc-text">类型系统（Type System）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类型语句（Type-language）"><span class="post-toc-number">2.</span> <span class="post-toc-text">类型语句（Type language）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#对象的类型和字段（Object-types-and-fields）"><span class="post-toc-number">3.</span> <span class="post-toc-text">对象的类型和字段（Object types and fields）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#参数（Arguments）"><span class="post-toc-number">4.</span> <span class="post-toc-text">参数（Arguments）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Query和Mutation类型（The-Query-and-Mutation-types）"><span class="post-toc-number">5.</span> <span class="post-toc-text">Query和Mutation类型（The Query and Mutation types）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#标量类型（Scalar-types）"><span class="post-toc-number">6.</span> <span class="post-toc-text">标量类型（Scalar types）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#枚举类型（Enumeration-types）"><span class="post-toc-number">7.</span> <span class="post-toc-text">枚举类型（Enumeration types）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#列表和非空类型（Lists-and-Non-Null）"><span class="post-toc-number">8.</span> <span class="post-toc-text">列表和非空类型（Lists and Non-Null）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#接口（Interfaces）"><span class="post-toc-number">9.</span> <span class="post-toc-text">接口（Interfaces）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#联合类型（Union-types）"><span class="post-toc-number">10.</span> <span class="post-toc-text">联合类型（Union types）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#输入类型（Input-types）"><span class="post-toc-number">11.</span> <span class="post-toc-text">输入类型（Input types）</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-GraphQL Learn (2) - Schemas and Types"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">GraphQL Learn (2) - Schemas and Types</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-08-15 00:00:00" datetime="2017-08-14T16:00:00.000Z"  itemprop="datePublished">2017-08-15</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Web/">Web</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>在此页面上，您将了解有关GraphQL类型系统的所有知识，以及如何描述可查询哪些数据。 由于GraphQL可以与任何后端框架或编程语言一起使用，因此我们将远离实现特定的详细信息，仅讨论概念。</p>
<h3 id="类型系统（Type-System）"><a href="#类型系统（Type-System）" class="headerlink" title="类型系统（Type System）"></a>类型系统（Type System）</h3><p>如果您以前看过GraphQL查询，那么你应该知道GraphQL查询语言基本上是在对象上选择字段。 所以在以下查询中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    appearsIn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"hero"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"R2-D2"</span>,</span><br><span class="line">      <span class="attr">"appearsIn"</span>: [</span><br><span class="line">        <span class="string">"NEWHOPE"</span>,</span><br><span class="line">        <span class="string">"EMPIRE"</span>,</span><br><span class="line">        <span class="string">"JEDI"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ol>
<li>从一个特殊的 “root”对象开始</li>
<li>在它里面选择一个<code>hero</code>字段</li>
<li>在<code>hero</code>返回的对象中，我们继续选择 <code>name</code> 和 <code>appearsIn</code> 字段</li>
</ol>
<p>因为GraphQL查询的形状与结果非常相似，所以您可以预测什么是查询将返回，而不必关心服务器的设置。 但是我们还是需要对我们所请求的数据进行详细的描述： </p>
<ul>
<li>我们可以选择哪些字段？ </li>
<li>他们可能返回什么样的对象？ </li>
<li>这些子对象里面包含哪些字段？ </li>
</ul>
<p>这就是schema所需要解决的问题。</p>
<p>每个GraphQL服务定义一组完全描述可以在该服务上查询的可能数据的类型。 然后，当收到查询时，它们将根据该架构进行验证和执行。.</p>
<h3 id="类型语句（Type-language）"><a href="#类型语句（Type-language）" class="headerlink" title="类型语句（Type language）"></a>类型语句（Type language）</h3><p>GraphQL服务可以用任何语言编写。我们不能依赖特定的编程语言语法（如JavaScript），因此我们将使用“GraphQL schema 语言” ，它类似于查询语言，并允许我们以语言无关的方式谈论GraphQL的架构。</p>
<h3 id="对象的类型和字段（Object-types-and-fields）"><a href="#对象的类型和字段（Object-types-and-fields）" class="headerlink" title="对象的类型和字段（Object types and fields）"></a>对象的类型和字段（Object types and fields）</h3><p>GraphQL的最基本的组件是对象类型，表示你可以从服务中获取的一种对象，以及它具有哪些字段。 在GraphQL schema语言中，我们可以这样表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Character &#123;</span><br><span class="line">  name: String!</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可读性已经很高了，但是让我们再过一遍，以便于让我们在细节上拥有共同的语言：</p>
<ul>
<li><code>Character</code>是一个对象类型，大多数情况下，schema里面的type都是一个对象</li>
<li><code>name</code>和<code>appearsIn</code>是<code>Character</code>中的字段。意味着在任何查询包含<code>Character</code> 类的时候<code>name</code>和<code>appearsIn</code>是仅有且必须出现在其中的字段</li>
<li><code>String</code>是内置的标量类型之一，标量是GraphQL中的最小的类型，不能再做子选择了。 我们会稍后再看标量类型。</li>
</ul>
<ul>
<li><code>String!</code>代表着这个字段是不为空的，GraphQL服务保证在这个字段上返回一个不为空的值。</li>
<li><code>[Episode]!</code>代表着一个包含<code>Episode</code>对象的数列，它也是不为空的，因此当你查询<code>appearsIn</code>字段时，GraphQL永远会返回一个数组，即使是一个空数组。</li>
</ul>
<p>现在，您知道GraphQL对象类型是什么样子了，并且掌握了如何读取GraphQL类型语言的基础知识。</p>
<h3 id="参数（Arguments）"><a href="#参数（Arguments）" class="headerlink" title="参数（Arguments）"></a>参数（Arguments）</h3><p>GraphQL对象类型上的每个字段都可以有零个或多个参数，例如下面的<code>length</code>字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Starship &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  length(unit: LengthUnit = METER): Float</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有参数都是有命名的。与JavaScript和Python这样的语言不同，函数采用有序参数列表，GraphQL中的所有参数都是通过名称进行传递。上面例子中，<code>length</code>字段有一个定义的参数，<code>unit</code>。</p>
<p>参数可以是必需的或可选的。当参数是可选的时候，我们可以定义一个默认值 。上面例子中，如果<code>unit</code>参数没有被传递，默认情况下它将被设置为<code>METER</code>。</p>
<h3 id="Query和Mutation类型（The-Query-and-Mutation-types）"><a href="#Query和Mutation类型（The-Query-and-Mutation-types）" class="headerlink" title="Query和Mutation类型（The Query and Mutation types）"></a>Query和Mutation类型（The Query and Mutation types）</h3><p>schema中的大多数类型将只是普通对象类型，但其中有两种特殊的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">schema &#123;</span><br><span class="line">  query: Query</span><br><span class="line">  mutation: Mutation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个GraphQL服务都有一个<code>query</code>类型，但可能有也可能没有<code>mutation</code>类型。 这些类型与常规对象类型相同，但它们是特殊的，因为它们定义了每个GraphQL查询的入口点。 所以如果你看到一个查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">  droid(id: &quot;2000&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"hero"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"R2-D2"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"droid"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"C-3PO"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着GraphQL服务需要一个具有<code>hero</code>和<code>droid</code>字段的<code>query</code>类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  hero(episode: Episode): Character</span><br><span class="line">  droid(id: ID!): Droid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Mutation</code>相同，您可以定义<code>Mutation</code>类型上的字段，这些字段就是你能变更的根字段。</p>
<p>重要的是要记住，除了作为模式的“入口点”的特殊状态之外，“查询和变更”类型与任何其他GraphQL对象类型相同，它们的字段的工作方式完全相同。</p>
<h3 id="标量类型（Scalar-types）"><a href="#标量类型（Scalar-types）" class="headerlink" title="标量类型（Scalar types）"></a>标量类型（Scalar types）</h3><p>GraphQL对象类型具有名称和字段，但在某些时候，这些字段必须解析为某些具体数据。 这就是标量类型的来历：它们代表查询最低端的叶子节点。下面查询中，<code>name</code>和<code>appearsIn</code>将会被解析为标量类型（因为这两个字段没有任何子字段，他们是本次查询的叶子节点）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    appearsIn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"hero"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"R2-D2"</span>,</span><br><span class="line">      <span class="attr">"appearsIn"</span>: [</span><br><span class="line">        <span class="string">"NEWHOPE"</span>,</span><br><span class="line">        <span class="string">"EMPIRE"</span>,</span><br><span class="line">        <span class="string">"JEDI"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GraphQL默认自带了一些变量类型：</p>
<ul>
<li><code>Int</code>: 带符号32位的整数.</li>
<li><code>Float</code>: 带符号的双精度浮点数.</li>
<li><code>String</code>: UTF-8的字符串.</li>
<li><code>Boolean</code>: <code>true</code> 或<code>false</code>.</li>
<li><code>ID</code>: ID标量类型表示一个唯一的标识，通常用于重新获取对象或作为缓存中的键。 ID类型其实就是String类型; 然而将其定义为ID表示它是没有可读性的。</li>
</ul>
<p>在大多数GraphQL服务实现中，还有一种方法来自定义标量类型。 例如，我们可以定义一个日期类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scalar Date</span><br></pre></td></tr></table></figure>
<p>然后由我们的自己来实现该自定义类型如何序列化，反序列化和验证。 例如，您可以指定Date类型应始终序列化为整数时间戳，并且让你的客户端也知道该格式。</p>
<h3 id="枚举类型（Enumeration-types）"><a href="#枚举类型（Enumeration-types）" class="headerlink" title="枚举类型（Enumeration types）"></a>枚举类型（Enumeration types）</h3><p>也称为枚举（ <em>Enums</em> ），枚举类型是一种特殊类型的标量，仅限于一组特定的允许值。 这样你可以：</p>
<ol>
<li>验证此类型的任何参数是允许的值之一</li>
<li>通过类型系统沟通一个字段永远是一组有限的值</li>
</ol>
<p>以下是GraphQL Schema语言中的枚举定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Episode &#123;</span><br><span class="line">  NEWHOPE</span><br><span class="line">  EMPIRE</span><br><span class="line">  JEDI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着无论何时我们在Schema中使用<code>Episode</code>类型时，其对应的值永远都是<code>NEWHOPE</code>, <code>EMPIRE</code>,  <code>JEDI</code>中间的一个。</p>
<p>请注意，各种语言的GraphQL服务实现将以自己的语言特定方式来处理枚举。 以支持枚举作“为一流公民”的语言，某些实现可能会利用这一点; 在没有枚举支持的JavaScript语言中，这些值可能在内部映射到一组整数。 但是，这些细节不会泄露给客户端，客户端可以完全按照枚举值的字符串名称进行操作。</p>
<h3 id="列表和非空类型（Lists-and-Non-Null）"><a href="#列表和非空类型（Lists-and-Non-Null）" class="headerlink" title="列表和非空类型（Lists and Non-Null）"></a>列表和非空类型（Lists and Non-Null）</h3><p>对象类型，标量和枚举是GraphQL中唯一可以定义的类型。 但是当您在Schema的其他部分或查询变量声明中使用这些类型时，可以使用类型修饰符来影响这些值的验证规则。 我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Character &#123;</span><br><span class="line">  name: String!</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用一个String类型，并通过在它之后添加一个感叹号将其标记为一个非空类型。 这意味着我们的服务器总是期望为此字段返回一个非空值，如果最终得到一个空值，实际上会触发一个GraphQL执行错误，让客户端知道出现了一些问题。</p>
<p>在定义字段的参数时，也可以使用非空类型修饰符，如果将null值作为该参数传递，则GraphQL服务器将返回验证错误，无论是在GraphQL字符串还是变量中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query DroidById($id: ID!) &#123;</span><br><span class="line">  droid(id: $id) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"errors"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"message"</span>: <span class="string">"Variable \"$id\" of required type \"ID!\" was not provided."</span>,</span><br><span class="line">      <span class="attr">"locations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">"column"</span>: <span class="number">17</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>列表以类似的方式工作：我们可以使用类型修饰符将类型标记为List，这表示该字段将返回该类型的数组。 在模式语言中，通过将类型包装在方括号<code>[</code>和<code>]</code>中来表示。 它与参数的表现相同但验证步骤将期望该值的数组。</p>
<p>非空修饰符和列表修饰符可以一起使用，例如，你可以要求一个由非空字符串组成的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myField: [String!]</span><br></pre></td></tr></table></figure>
<p>这意味着列表本身可以为空，但它不能有任何空的成员。例如，在返回的JSON中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myField: <span class="literal">null</span> <span class="comment">// valid</span></span><br><span class="line">myField: [] <span class="comment">// valid</span></span><br><span class="line">myField: [<span class="string">'a'</span>, <span class="string">'b'</span>] <span class="comment">// valid</span></span><br><span class="line">myField: [<span class="string">'a'</span>, <span class="literal">null</span>, <span class="string">'b'</span>] <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>现在，让我们定义一个由字符串组成的非空数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myField: [String]!</span><br></pre></td></tr></table></figure>
<p>这意味着列表本身不能为空，但它可以包含空值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myField: <span class="literal">null</span> <span class="comment">// error</span></span><br><span class="line">myField: [] <span class="comment">// valid</span></span><br><span class="line">myField: [<span class="string">'a'</span>, <span class="string">'b'</span>] <span class="comment">// valid</span></span><br><span class="line">myField: [<span class="string">'a'</span>, <span class="literal">null</span>, <span class="string">'b'</span>] <span class="comment">// valid</span></span><br></pre></td></tr></table></figure>
<p>您可以根据需要随意嵌套任意数量的非空和列表修饰符。</p>
<h3 id="接口（Interfaces）"><a href="#接口（Interfaces）" class="headerlink" title="接口（Interfaces）"></a>接口（Interfaces）</h3><p>像许多类型的系统一样，GraphQL支持接口。 接口是一种抽象类型，它包含一组类型必须包含已实现该接口的字段。</p>
<p>例如，你可以有一个<code>Character</code>接口表示星球大战三部曲中的任何角色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着，任何实现了<code>Character</code>接口的类型，都必须拥有这些字段，包括他们的参数和返回类型。例如，下面列举了一些实现<code>Character</code>接口的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Human implements Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">  starships: [Starship]</span><br><span class="line">  totalCredits: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Droid implements Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">  primaryFunction: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以看到，这两种类型都具有<code>Character</code>接口中的所有字段，还可以引入特定类型字符的额外字段，<code>totalCredits</code>，<code>starships</code>和<code>primaryFunction</code>。</p>
<p>当您要返回一个对象或一组对象时，接口很有用，但这些对象可能有几种不同的类型。</p>
<p>请注意以下查询会产生错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># &#123; &quot;graphiql&quot;: true, &quot;variables&quot;: &#123; &quot;ep&quot;: &quot;JEDI&quot; &#125; &#125;</span><br><span class="line">query HeroForEpisode($ep: Episode!) &#123;</span><br><span class="line">  hero(episode: $ep) &#123;</span><br><span class="line">    name</span><br><span class="line">    primaryFunction</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ep"</span>: <span class="string">"JEDI"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"errors"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"message"</span>: <span class="string">"Cannot query field \"primaryFunction\" on type \"Character\". Did you mean to use an inline fragment on \"Droid\"?"</span>,</span><br><span class="line">      <span class="attr">"locations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"line"</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="attr">"column"</span>: <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hero</code>字段返回字符类型，这意味着它可能是<code>Human</code>或<code>Droid</code>，取决于<code>episode</code>参数。 在上面的查询中，您只能询问<code>Character</code>接口中存在的字段，不包括<code>primaryFunction</code>。</p>
<p>为了得到在一个特定对象类型中的字段，你需要使用内联片段(inline fragment)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query HeroForEpisode($ep: Episode!) &#123;</span><br><span class="line">  hero(episode: $ep) &#123;</span><br><span class="line">    name</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ep"</span>: <span class="string">"JEDI"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"hero"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"R2-D2"</span>,</span><br><span class="line">      <span class="attr">"primaryFunction"</span>: <span class="string">"Astromech"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="联合类型（Union-types）"><a href="#联合类型（Union-types）" class="headerlink" title="联合类型（Union types）"></a>联合类型（Union types）</h3><p>联合类型与接口非常相似，但它们不能指定类型之间的任何公共字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union SearchResult = Human | Droid | Starship</span><br></pre></td></tr></table></figure>
<p>当Schema返回了一个<code>SearchResult</code>类型，我们实际上可能会得到一个<code>Human</code>，一个<code>Droid</code>或者一个<code>Starship</code>。 注意，联合类型的成员需要是具体的对象类型; 您不能在接口或其他联合类型之上再创造一个联合类型。（扁平结构）</p>
<p>在这种情况下，如果查询返回的是<code>SearchResult</code>这样的联合类型字段，则需要使用条件片段才能查询其中的任意子字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  search(text: &quot;an&quot;) &#123;</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      name</span><br><span class="line">      height</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      name</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Starship &#123;</span><br><span class="line">      name</span><br><span class="line">      length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"search"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Han Solo"</span>,</span><br><span class="line">        <span class="attr">"height"</span>: <span class="number">1.8</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Leia Organa"</span>,</span><br><span class="line">        <span class="attr">"height"</span>: <span class="number">1.5</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"TIE Advanced x1"</span>,</span><br><span class="line">        <span class="attr">"length"</span>: <span class="number">9.2</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输入类型（Input-types）"><a href="#输入类型（Input-types）" class="headerlink" title="输入类型（Input types）"></a>输入类型（Input types）</h3><p>到目前为止，我们只谈到将标量值（如枚举或字符串）作为参数传递到一个字段中。 但您也可以轻松地传递复杂的对象。 这在变更（Mutation）的情况下特别有价值，在这种情况下，您可能想要传入要创建的整个对象。 在GraphQL Schema语言中，输入类型与常规对象类型完全相同，但使用关键字<code>input</code>而不是<code>type</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input ReviewInput &#123;</span><br><span class="line">  stars: Int!</span><br><span class="line">  commentary: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是如何在变更语句中使用输入类型对象的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123;</span><br><span class="line">  createReview(episode: $ep, review: $review) &#123;</span><br><span class="line">    stars</span><br><span class="line">    commentary</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ep"</span>: <span class="string">"JEDI"</span>,</span><br><span class="line">  <span class="attr">"review"</span>: &#123;</span><br><span class="line">    <span class="attr">"stars"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"commentary"</span>: <span class="string">"This is a great movie!"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"createReview"</span>: &#123;</span><br><span class="line">      <span class="attr">"stars"</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">"commentary"</span>: <span class="string">"This is a great movie!"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入类型对象上的字段本身可以引用其他输入类型对象，但是您不能在Schema中混合输入和输出类型。 输入类型对象也不能在其字段上有参数。</p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-11-22T17:13:31.656Z" itemprop="dateUpdated">2017-11-23 01:13:31</time>
</span><br>


        
    </div>
    <footer>
        <a href="http://lishangying.github.io">
            <img src="/img/avatar.jpg" alt="Sailing">
            Sailing
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GraphQL/">GraphQL</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://lishangying.github.io/2017/08/15/GraphQL Learn (2) - Schemas and Types/&title=《GraphQL Learn (2) - Schemas and Types》 — Sailing&pic=http://lishangying.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://lishangying.github.io/2017/08/15/GraphQL Learn (2) - Schemas and Types/&title=《GraphQL Learn (2) - Schemas and Types》 — Sailing&source=在此页面上，您将了解有关GraphQL类型系统的所有知识，以及如何描述可查询哪些数据。 由于GraphQL可以与任何后端框架或编程语言一起使用，因此我们将..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://lishangying.github.io/2017/08/15/GraphQL Learn (2) - Schemas and Types/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《GraphQL Learn (2) - Schemas and Types》 — Sailing&url=http://lishangying.github.io/2017/08/15/GraphQL Learn (2) - Schemas and Types/&via=http://lishangying.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://lishangying.github.io/2017/08/15/GraphQL Learn (2) - Schemas and Types/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/08/15/GraphQL Learn (3) - Validation/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">GraphQL Learn (3) - Validation</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/08/15/GraphQL Learn (1) - Queries and Mutations/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">GraphQL Learn (1) - Queries and Mutations</h4>
      </a>
    </div>
  
</nav>



    














</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Sailing &copy; 2015 - 2017</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://lishangying.github.io/2017/08/15/GraphQL Learn (2) - Schemas and Types/&title=《GraphQL Learn (2) - Schemas and Types》 — Sailing&pic=http://lishangying.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://lishangying.github.io/2017/08/15/GraphQL Learn (2) - Schemas and Types/&title=《GraphQL Learn (2) - Schemas and Types》 — Sailing&source=在此页面上，您将了解有关GraphQL类型系统的所有知识，以及如何描述可查询哪些数据。 由于GraphQL可以与任何后端框架或编程语言一起使用，因此我们将..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://lishangying.github.io/2017/08/15/GraphQL Learn (2) - Schemas and Types/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《GraphQL Learn (2) - Schemas and Types》 — Sailing&url=http://lishangying.github.io/2017/08/15/GraphQL Learn (2) - Schemas and Types/&via=http://lishangying.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://lishangying.github.io/2017/08/15/GraphQL Learn (2) - Schemas and Types/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACsklEQVR42u3aQW7DQAgF0Nz/0u02VeX4A0OaSs+ryHVt3kQyE+DxiI+vp+P5zO/P+Znk/O/jsXHg4eHhDUK/ut3VA66uubry9fX505P/wsPDw9vmvX5lJ6/vBNxLIa+fcmPBw8PD+wBe/kLv7W+ri4iHh4f3X3i9hcjvXC1/4OHh4b2fl5QDqvXS5PF5klivteDh4eF19q43oX/O55X+Hh4eHt64q15tR/Ve2XmptxwtHh4e3gKvt13ON9D5tjsfDqjGiYeHh3eWlxRnq+eTK3sJplzMxcPDw1vgVcu4vdd39T69AYLL/8XDw8M7yst//Ccl3bz93ztTHt7Cw8PDW+DlYfUGBaqNtGSb3osWDw8Pb4NXLbYWWlDF4YDJBr3wTeLh4eEd4vWKDs3OW7ylzjfrh1MCHh4eXovXK62+s9Q7ynh4eHh4RV7S2s8LCqc6cvlQws098fDw8NZ4vfTQK+OeTSo3n/Hw8PCWefNWfX5NdZmaS4yHh4e3xuttrJNwqyMC1QGsmwSGh4eHt8arlhjyhFFdmrzkES0QHh4e3ht5B7azawMKB4oReHh4eANe8rBqybU3lNBscSVpBg8PD+8oL/+RfzaISYsLDw8P7295k+ZWtYw7H8Aqb6bx8PDw1njVguwE32uV9SLBw8PD2+PlAwSTYm410F7qKtRa8PDw8BZ4r0PPE0N1+ar4m2jx8PDw1ninhlCrZd98EaujCXh4eHgbvK/iMRmryouwk+37j7/i4eHhLfB64ebpJG//5yXaScLAw8PDO8WbFEknoVcZzbSBh4eHt8arDjxNWvuj7W9eZcHDw8P7SF5vT5sPb+Xl3cuo8PDw8D6GVw2x2io7PHSFh4eHt8DrjT1VC7L5CFf1a7hJDHh4eHhHeb0f+b1Rg97WPLlyVNTAw8PDSyP8BuCF72TgaRjCAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
